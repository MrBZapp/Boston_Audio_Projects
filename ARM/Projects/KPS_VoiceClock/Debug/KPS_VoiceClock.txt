
KPS_VoiceClock.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 04 00 10 03 01 00 00 d5 00 00 00 d7 00 00 00     ................
	...
  2c:	d9 00 00 00 00 00 00 00 00 00 00 00 db 00 00 00     ................
  3c:	dd 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  4c:	ed 06 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  5c:	00 00 00 00 df 00 00 00 19 04 00 00 df 00 00 00     ................
  6c:	df 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  7c:	df 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................
  b0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000ef8 	.word	0x00000ef8
  c4:	10000100 	.word	0x10000100
  c8:	00000018 	.word	0x00000018

000000cc <__bss_section_table>:
  cc:	10000118 	.word	0x10000118
  d0:	00000044 	.word	0x00000044

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>

000000d6 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d6:	e7fe      	b.n	d6 <HardFault_Handler>

000000d8 <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  d8:	e7fe      	b.n	d8 <SVC_Handler>

000000da <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  da:	e7fe      	b.n	da <PendSV_Handler>

000000dc <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  dc:	e7fe      	b.n	dc <SysTick_Handler>

000000de <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  de:	e7fe      	b.n	de <BOD_IRQHandler>

000000e0 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
  e0:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  e2:	2300      	movs	r3, #0
  e4:	4293      	cmp	r3, r2
  e6:	d203      	bcs.n	f0 <data_init+0x10>
        *pulDest++ = *pulSrc++;
  e8:	581c      	ldr	r4, [r3, r0]
  ea:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  ec:	3304      	adds	r3, #4
  ee:	e7f9      	b.n	e4 <data_init+0x4>
        *pulDest++ = *pulSrc++;
}
  f0:	bd10      	pop	{r4, pc}

000000f2 <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  f2:	2300      	movs	r3, #0
  f4:	428b      	cmp	r3, r1
  f6:	d203      	bcs.n	100 <bss_init+0xe>
        *pulDest++ = 0;
  f8:	2200      	movs	r2, #0
  fa:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  fc:	3304      	adds	r3, #4
  fe:	e7f9      	b.n	f4 <bss_init+0x2>
        *pulDest++ = 0;
}
 100:	4770      	bx	lr

00000102 <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
 102:	b510      	push	{r4, lr}
    //
    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;
 104:	4c0c      	ldr	r4, [pc, #48]	; (138 <ResetISR+0x36>)

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 106:	4b0d      	ldr	r3, [pc, #52]	; (13c <ResetISR+0x3a>)
 108:	429c      	cmp	r4, r3
 10a:	d207      	bcs.n	11c <ResetISR+0x1a>
        LoadAddr = *SectionTableAddr++;
 10c:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
 10e:	6861      	ldr	r1, [r4, #4]
 110:	340c      	adds	r4, #12
 112:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
 114:	681a      	ldr	r2, [r3, #0]
 116:	f7ff ffe3 	bl	e0 <data_init>
 11a:	e7f4      	b.n	106 <ResetISR+0x4>
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 11c:	4b08      	ldr	r3, [pc, #32]	; (140 <ResetISR+0x3e>)
 11e:	429c      	cmp	r4, r3
 120:	d205      	bcs.n	12e <ResetISR+0x2c>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
 122:	6820      	ldr	r0, [r4, #0]
 124:	6861      	ldr	r1, [r4, #4]
 126:	f7ff ffe4 	bl	f2 <bss_init>
 12a:	3408      	adds	r4, #8
 12c:	e7f6      	b.n	11c <ResetISR+0x1a>
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 12e:	f000 f97f 	bl	430 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 132:	f000 fd55 	bl	be0 <__weak_main>
 136:	e7fe      	b.n	136 <ResetISR+0x34>
 138:	000000c0 	.word	0x000000c0
 13c:	000000cc 	.word	0x000000cc
 140:	000000d4 	.word	0x000000d4
 144:	ffffffff 	.word	0xffffffff
 148:	ffffffff 	.word	0xffffffff
 14c:	ffffffff 	.word	0xffffffff
 150:	ffffffff 	.word	0xffffffff
 154:	ffffffff 	.word	0xffffffff
 158:	ffffffff 	.word	0xffffffff
 15c:	ffffffff 	.word	0xffffffff
 160:	ffffffff 	.word	0xffffffff
 164:	ffffffff 	.word	0xffffffff
 168:	ffffffff 	.word	0xffffffff
 16c:	ffffffff 	.word	0xffffffff
 170:	ffffffff 	.word	0xffffffff
 174:	ffffffff 	.word	0xffffffff
 178:	ffffffff 	.word	0xffffffff
 17c:	ffffffff 	.word	0xffffffff
 180:	ffffffff 	.word	0xffffffff
 184:	ffffffff 	.word	0xffffffff
 188:	ffffffff 	.word	0xffffffff
 18c:	ffffffff 	.word	0xffffffff
 190:	ffffffff 	.word	0xffffffff
 194:	ffffffff 	.word	0xffffffff
 198:	ffffffff 	.word	0xffffffff
 19c:	ffffffff 	.word	0xffffffff
 1a0:	ffffffff 	.word	0xffffffff
 1a4:	ffffffff 	.word	0xffffffff
 1a8:	ffffffff 	.word	0xffffffff
 1ac:	ffffffff 	.word	0xffffffff
 1b0:	ffffffff 	.word	0xffffffff
 1b4:	ffffffff 	.word	0xffffffff
 1b8:	ffffffff 	.word	0xffffffff
 1bc:	ffffffff 	.word	0xffffffff
 1c0:	ffffffff 	.word	0xffffffff
 1c4:	ffffffff 	.word	0xffffffff
 1c8:	ffffffff 	.word	0xffffffff
 1cc:	ffffffff 	.word	0xffffffff
 1d0:	ffffffff 	.word	0xffffffff
 1d4:	ffffffff 	.word	0xffffffff
 1d8:	ffffffff 	.word	0xffffffff
 1dc:	ffffffff 	.word	0xffffffff
 1e0:	ffffffff 	.word	0xffffffff
 1e4:	ffffffff 	.word	0xffffffff
 1e8:	ffffffff 	.word	0xffffffff
 1ec:	ffffffff 	.word	0xffffffff
 1f0:	ffffffff 	.word	0xffffffff
 1f4:	ffffffff 	.word	0xffffffff
 1f8:	ffffffff 	.word	0xffffffff
 1fc:	ffffffff 	.word	0xffffffff
 200:	ffffffff 	.word	0xffffffff
 204:	ffffffff 	.word	0xffffffff
 208:	ffffffff 	.word	0xffffffff
 20c:	ffffffff 	.word	0xffffffff
 210:	ffffffff 	.word	0xffffffff
 214:	ffffffff 	.word	0xffffffff
 218:	ffffffff 	.word	0xffffffff
 21c:	ffffffff 	.word	0xffffffff
 220:	ffffffff 	.word	0xffffffff
 224:	ffffffff 	.word	0xffffffff
 228:	ffffffff 	.word	0xffffffff
 22c:	ffffffff 	.word	0xffffffff
 230:	ffffffff 	.word	0xffffffff
 234:	ffffffff 	.word	0xffffffff
 238:	ffffffff 	.word	0xffffffff
 23c:	ffffffff 	.word	0xffffffff
 240:	ffffffff 	.word	0xffffffff
 244:	ffffffff 	.word	0xffffffff
 248:	ffffffff 	.word	0xffffffff
 24c:	ffffffff 	.word	0xffffffff
 250:	ffffffff 	.word	0xffffffff
 254:	ffffffff 	.word	0xffffffff
 258:	ffffffff 	.word	0xffffffff
 25c:	ffffffff 	.word	0xffffffff
 260:	ffffffff 	.word	0xffffffff
 264:	ffffffff 	.word	0xffffffff
 268:	ffffffff 	.word	0xffffffff
 26c:	ffffffff 	.word	0xffffffff
 270:	ffffffff 	.word	0xffffffff
 274:	ffffffff 	.word	0xffffffff
 278:	ffffffff 	.word	0xffffffff
 27c:	ffffffff 	.word	0xffffffff
 280:	ffffffff 	.word	0xffffffff
 284:	ffffffff 	.word	0xffffffff
 288:	ffffffff 	.word	0xffffffff
 28c:	ffffffff 	.word	0xffffffff
 290:	ffffffff 	.word	0xffffffff
 294:	ffffffff 	.word	0xffffffff
 298:	ffffffff 	.word	0xffffffff
 29c:	ffffffff 	.word	0xffffffff
 2a0:	ffffffff 	.word	0xffffffff
 2a4:	ffffffff 	.word	0xffffffff
 2a8:	ffffffff 	.word	0xffffffff
 2ac:	ffffffff 	.word	0xffffffff
 2b0:	ffffffff 	.word	0xffffffff
 2b4:	ffffffff 	.word	0xffffffff
 2b8:	ffffffff 	.word	0xffffffff
 2bc:	ffffffff 	.word	0xffffffff
 2c0:	ffffffff 	.word	0xffffffff
 2c4:	ffffffff 	.word	0xffffffff
 2c8:	ffffffff 	.word	0xffffffff
 2cc:	ffffffff 	.word	0xffffffff
 2d0:	ffffffff 	.word	0xffffffff
 2d4:	ffffffff 	.word	0xffffffff
 2d8:	ffffffff 	.word	0xffffffff
 2dc:	ffffffff 	.word	0xffffffff
 2e0:	ffffffff 	.word	0xffffffff
 2e4:	ffffffff 	.word	0xffffffff
 2e8:	ffffffff 	.word	0xffffffff
 2ec:	ffffffff 	.word	0xffffffff
 2f0:	ffffffff 	.word	0xffffffff
 2f4:	ffffffff 	.word	0xffffffff
 2f8:	ffffffff 	.word	0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffffffff                                ....

00000300 <main>:

/********************************************************************************************************
 * 											MAIN														*
 *******************************************************************************************************/
int main(void)
{
 300:	b530      	push	{r4, r5, lr}
 302:	b08b      	sub	sp, #44	; 0x2c
	// Standard boot procedure
	CoreClockInit_30Hz();
 304:	f000 f924 	bl	550 <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 308:	4b33      	ldr	r3, [pc, #204]	; (3d8 <main+0xd8>)
 30a:	2280      	movs	r2, #128	; 0x80
 30c:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 30e:	0052      	lsls	r2, r2, #1
 310:	430a      	orrs	r2, r1
 312:	67da      	str	r2, [r3, #124]	; 0x7c
 314:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 316:	2280      	movs	r2, #128	; 0x80
 318:	01d2      	lsls	r2, r2, #7
 31a:	430a      	orrs	r2, r1
 31c:	67da      	str	r2, [r3, #124]	; 0x7c
 31e:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 320:	2280      	movs	r2, #128	; 0x80
 322:	0112      	lsls	r2, r2, #4
 324:	430a      	orrs	r2, r1
 326:	67da      	str	r2, [r3, #124]	; 0x7c
 328:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 32a:	2280      	movs	r2, #128	; 0x80
 32c:	0312      	lsls	r2, r2, #12
 32e:	430a      	orrs	r2, r1
 330:	67da      	str	r2, [r3, #124]	; 0x7c
 332:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 334:	2180      	movs	r1, #128	; 0x80
 336:	430a      	orrs	r2, r1
 338:	67da      	str	r2, [r3, #124]	; 0x7c
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 33a:	4828      	ldr	r0, [pc, #160]	; (3dc <main+0xdc>)
 33c:	4a28      	ldr	r2, [pc, #160]	; (3e0 <main+0xe0>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 33e:	2401      	movs	r4, #1
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 340:	6010      	str	r0, [r2, #0]
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 342:	4828      	ldr	r0, [pc, #160]	; (3e4 <main+0xe4>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 344:	4264      	negs	r4, r4

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 346:	60d0      	str	r0, [r2, #12]
    /* SPI0_MOSI */
    /* SPI0_SSEL */
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
 348:	4827      	ldr	r0, [pc, #156]	; (3e8 <main+0xe8>)
 34a:	6110      	str	r0, [r2, #16]
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;
 34c:	4827      	ldr	r0, [pc, #156]	; (3ec <main+0xec>)
 34e:	6190      	str	r0, [r2, #24]

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 350:	20e0      	movs	r0, #224	; 0xe0
 352:	0040      	lsls	r0, r0, #1
 354:	5014      	str	r4, [r2, r0]
 * @param	clk	: Clock to disable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL &= ~(1 << clk);
 356:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 358:	438a      	bics	r2, r1
 35a:	67da      	str	r2, [r3, #124]	; 0x7c

	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);
	/*END OF PIN ASSIGNMENTS*/

	// Configure the SPI to use TLC DAC settings
	TLC_Init();
 35c:	f000 f9d0 	bl	700 <TLC_Init>


	// Initialize the frequency generation timer
	WaveGenInit(&Generator1, 200);
 360:	4c23      	ldr	r4, [pc, #140]	; (3f0 <main+0xf0>)
 362:	4924      	ldr	r1, [pc, #144]	; (3f4 <main+0xf4>)
 364:	1c20      	adds	r0, r4, #0
 366:	f000 fa31 	bl	7cc <WaveGenInit>
	WaveGenStart(&Generator1);
 36a:	1c20      	adds	r0, r4, #0
 36c:	f000 f9fc 	bl	768 <WaveGenStart>

	// Initialize the exciter envelope
	envNode_t ADSRarr[3] = {
 370:	a901      	add	r1, sp, #4
 372:	4a21      	ldr	r2, [pc, #132]	; (3f8 <main+0xf8>)
 374:	1c0b      	adds	r3, r1, #0
 376:	ca31      	ldmia	r2!, {r0, r4, r5}
 378:	c331      	stmia	r3!, {r0, r4, r5}
 37a:	ca31      	ldmia	r2!, {r0, r4, r5}
 37c:	c331      	stmia	r3!, {r0, r4, r5}
 37e:	ca31      	ldmia	r2!, {r0, r4, r5}
 380:	c331      	stmia	r3!, {r0, r4, r5}
			{ATTACK, ENVAMP_MAX, FALSE},
			{DECAY, RELEASE, TRUE},
			{RELEASE, 0, TRUE}
	};
	EnvInit(&GlobalEnv, ADSRarr, 3);
 382:	4c1e      	ldr	r4, [pc, #120]	; (3fc <main+0xfc>)
 384:	2203      	movs	r2, #3
 386:	1c20      	adds	r0, r4, #0
 388:	f000 f900 	bl	58c <EnvInit>

    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
 38c:	2102      	movs	r1, #2
 38e:	481c      	ldr	r0, [pc, #112]	; (400 <main+0x100>)
 390:	f000 f92e 	bl	5f0 <MIDI_USARTInit>
	MIDI_SetAddress(LOCAL_ADDRESS);
 394:	2000      	movs	r0, #0
 396:	f000 f957 	bl	648 <MIDI_SetAddress>

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 39a:	4a1a      	ldr	r2, [pc, #104]	; (404 <main+0x104>)
 39c:	4b1a      	ldr	r3, [pc, #104]	; (408 <main+0x108>)
	MIDI_NoteOffFunc = &MIDI_NoteOff;

	MIDI_Enable(LPC_USART0);
 39e:	4818      	ldr	r0, [pc, #96]	; (400 <main+0x100>)
    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
	MIDI_SetAddress(LOCAL_ADDRESS);

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 3a0:	601a      	str	r2, [r3, #0]
	MIDI_NoteOffFunc = &MIDI_NoteOff;
 3a2:	4a1a      	ldr	r2, [pc, #104]	; (40c <main+0x10c>)
 3a4:	4b1a      	ldr	r3, [pc, #104]	; (410 <main+0x110>)
 3a6:	1c25      	adds	r5, r4, #0
 3a8:	601a      	str	r2, [r3, #0]

	MIDI_Enable(LPC_USART0);
 3aa:	f000 f953 	bl	654 <MIDI_Enable>
	uint8_t prev_Value = 0;

/////////////////////////////////////////////MAINLOOP.////////////////////////////////////////////////////
	while (1) {
		// Check if we've received any data
		MIDI_ProcessRXBuffer();
 3ae:	f000 f957 	bl	660 <MIDI_ProcessRXBuffer>

		// If the timer has requested a sample from the exciter...
		if (triggered != 0)
 3b2:	4c18      	ldr	r4, [pc, #96]	; (414 <main+0x114>)
 3b4:	7823      	ldrb	r3, [r4, #0]
 3b6:	2b00      	cmp	r3, #0
 3b8:	d0f9      	beq.n	3ae <main+0xae>
		{
			// Get a sample
			uint8_t DAC_Value = GenExciter(&GlobalEnv);
 3ba:	1c28      	adds	r0, r5, #0
 3bc:	f000 f83c 	bl	438 <GenExciter>
 3c0:	466a      	mov	r2, sp
 3c2:	3203      	adds	r2, #3
 3c4:	7010      	strb	r0, [r2, #0]

			// check if it's different from the previous value
			if (DAC_Value != prev_Value)
 3c6:	2800      	cmp	r0, #0
 3c8:	d003      	beq.n	3d2 <main+0xd2>
			{
				TLC_SetDACValue(PulseDAC, 1, &DAC_Value);
 3ca:	2003      	movs	r0, #3
 3cc:	2101      	movs	r1, #1
 3ce:	f000 f9b9 	bl	744 <TLC_SetDACValue>
			}

			// Clear the triggered variable
			triggered = 0;
 3d2:	2300      	movs	r3, #0
 3d4:	7023      	strb	r3, [r4, #0]
 3d6:	e7ea      	b.n	3ae <main+0xae>
 3d8:	40048004 	.word	0x40048004
 3dc:	ffff00ff 	.word	0xffff00ff
 3e0:	4000c000 	.word	0x4000c000
 3e4:	05ffffff 	.word	0x05ffffff
 3e8:	ff03ff04 	.word	0xff03ff04
 3ec:	02ffffff 	.word	0x02ffffff
 3f0:	10000108 	.word	0x10000108
 3f4:	43480000 	.word	0x43480000
 3f8:	00000e04 	.word	0x00000e04
 3fc:	10000148 	.word	0x10000148
 400:	40064000 	.word	0x40064000
 404:	0000047d 	.word	0x0000047d
 408:	10000124 	.word	0x10000124
 40c:	00000521 	.word	0x00000521
 410:	10000120 	.word	0x10000120
 414:	10000118 	.word	0x10000118

00000418 <SCT_IRQHandler>:
/********************************************************************************************************
 * 										Functions														*
 *******************************************************************************************************/
void SCT_IRQHandler(void)
{
	triggered = 1;
 418:	4b03      	ldr	r3, [pc, #12]	; (428 <SCT_IRQHandler+0x10>)
 41a:	2201      	movs	r2, #1
 41c:	701a      	strb	r2, [r3, #0]
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVFLAG |= evt;
 41e:	4b03      	ldr	r3, [pc, #12]	; (42c <SCT_IRQHandler+0x14>)
 420:	6819      	ldr	r1, [r3, #0]
 422:	430a      	orrs	r2, r1
 424:	601a      	str	r2, [r3, #0]
	// reset the interrupt flag
	Chip_SCT_ClearEventFlag(LPC_SCT, SCT_EVT_0);
}
 426:	4770      	bx	lr
 428:	10000118 	.word	0x10000118
 42c:	500040f4 	.word	0x500040f4

00000430 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 430:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 432:	f000 fb45 	bl	ac0 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 436:	bd08      	pop	{r3, pc}

00000438 <GenExciter>:
 */
#include "KPS_Exciter.h"
#include "BAP_math.h"

uint8_t GenExciter(env_t* env)
{
 438:	b537      	push	{r0, r1, r2, r4, r5, lr}
 43a:	1c05      	adds	r5, r0, #0
	// Gen the envelope value
	int32_t envVal = EnvGenSample(env);
 43c:	f000 f8ad 	bl	59a <EnvGenSample>
 440:	1c04      	adds	r4, r0, #0

	// Get a bit of noise
	int32_t noise = LFSR() & 0x7F;
 442:	f000 fa23 	bl	88c <LFSR>

	// Generate the attack
	if (env->index == 0)
 446:	89ab      	ldrh	r3, [r5, #12]
	{
		noise = (uint8_t) envVal;
 448:	b2e2      	uxtb	r2, r4

	// Get a bit of noise
	int32_t noise = LFSR() & 0x7F;

	// Generate the attack
	if (env->index == 0)
 44a:	2b00      	cmp	r3, #0
 44c:	d001      	beq.n	452 <GenExciter+0x1a>
{
	// Gen the envelope value
	int32_t envVal = EnvGenSample(env);

	// Get a bit of noise
	int32_t noise = LFSR() & 0x7F;
 44e:	227f      	movs	r2, #127	; 0x7f
 450:	4002      	ands	r2, r0
	{
		noise = (uint8_t) envVal;
	}

	// scale the amplitude
	noise = i_lscale(0, 127, 0, pluckStrength, noise);
 452:	4b09      	ldr	r3, [pc, #36]	; (478 <GenExciter+0x40>)
 454:	2000      	movs	r0, #0
 456:	781b      	ldrb	r3, [r3, #0]
 458:	217f      	movs	r1, #127	; 0x7f
 45a:	9200      	str	r2, [sp, #0]
 45c:	1c02      	adds	r2, r0, #0
 45e:	f000 fa05 	bl	86c <i_lscale>
	noise = i_lscale(0,127, 0, envVal, noise);
 462:	9000      	str	r0, [sp, #0]
 464:	2000      	movs	r0, #0
 466:	217f      	movs	r1, #127	; 0x7f
 468:	1c02      	adds	r2, r0, #0
 46a:	1c23      	adds	r3, r4, #0
 46c:	f000 f9fe 	bl	86c <i_lscale>

	// Set bias to be 1/2 available range
	noise = 127 + noise;
 470:	307f      	adds	r0, #127	; 0x7f
	return (uint8_t) noise;
 472:	b2c0      	uxtb	r0, r0
}
 474:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 476:	46c0      	nop			; (mov r8, r8)
 478:	10000119 	.word	0x10000119

0000047c <MIDI_NoteOn>:
#include "BAP_TLC_DAC.h"
#include "BAP_WaveGen.h"
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 47c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	// Load global variables
	activeNote = num;
 47e:	4b20      	ldr	r3, [pc, #128]	; (500 <MIDI_NoteOn+0x84>)
#include "BAP_TLC_DAC.h"
#include "BAP_WaveGen.h"
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 480:	1c05      	adds	r5, r0, #0
	// Load global variables
	activeNote = num;
 482:	7018      	strb	r0, [r3, #0]
	pluckStrength = vel;
 484:	4b1f      	ldr	r3, [pc, #124]	; (504 <MIDI_NoteOn+0x88>)

	// Reset the Envelope
	EnvReset(&GlobalEnv);
 486:	4820      	ldr	r0, [pc, #128]	; (508 <MIDI_NoteOn+0x8c>)

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
 488:	7019      	strb	r1, [r3, #0]

	// Reset the Envelope
	EnvReset(&GlobalEnv);
 48a:	f000 f8ac 	bl	5e6 <EnvReset>

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
 48e:	237f      	movs	r3, #127	; 0x7f
 490:	1b5b      	subs	r3, r3, r5
 492:	466c      	mov	r4, sp
 494:	71e3      	strb	r3, [r4, #7]
 496:	3407      	adds	r4, #7
	TLC_SetDACValue(FilterDAC, 1, &value);
 498:	1c22      	adds	r2, r4, #0
 49a:	2000      	movs	r0, #0
 49c:	2101      	movs	r1, #1
 49e:	f000 f951 	bl	744 <TLC_SetDACValue>
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 4a2:	1c28      	adds	r0, r5, #0
 4a4:	2143      	movs	r1, #67	; 0x43
 4a6:	f000 fba2 	bl	bee <__aeabi_uidiv>
 4aa:	b2ce      	uxtb	r6, r1
 4ac:	1c30      	adds	r0, r6, #0
 4ae:	210c      	movs	r1, #12
 4b0:	f000 fb9d 	bl	bee <__aeabi_uidiv>
 4b4:	2106      	movs	r1, #6
 4b6:	b2c0      	uxtb	r0, r0
 4b8:	f000 fb99 	bl	bee <__aeabi_uidiv>
 4bc:	1c28      	adds	r0, r5, #0
 4be:	b2cf      	uxtb	r7, r1
 4c0:	210c      	movs	r1, #12
 4c2:	f000 fb94 	bl	bee <__aeabi_uidiv>
 4c6:	4b11      	ldr	r3, [pc, #68]	; (50c <MIDI_NoteOn+0x90>)
	TLC_SetDACValue(AmpDAC, 0, &value);
 4c8:	1c22      	adds	r2, r4, #0
	EnvReset(&GlobalEnv);

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 4ca:	5ddb      	ldrb	r3, [r3, r7]
	TLC_SetDACValue(AmpDAC, 0, &value);
 4cc:	2001      	movs	r0, #1
	EnvReset(&GlobalEnv);

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 4ce:	1859      	adds	r1, r3, r1
 4d0:	7021      	strb	r1, [r4, #0]
	TLC_SetDACValue(AmpDAC, 0, &value);
 4d2:	2100      	movs	r1, #0
 4d4:	f000 f936 	bl	744 <TLC_SetDACValue>

	// Set frequency generator's frequency.
	setReload(&Generator1, MIDIto30MhzReload[num % 67]);
 4d8:	4c0d      	ldr	r4, [pc, #52]	; (510 <MIDI_NoteOn+0x94>)
 4da:	4b0e      	ldr	r3, [pc, #56]	; (514 <MIDI_NoteOn+0x98>)
 4dc:	0076      	lsls	r6, r6, #1
 4de:	5af1      	ldrh	r1, [r6, r3]
 4e0:	1c20      	adds	r0, r4, #0
 4e2:	f000 f9a5 	bl	830 <setReload>
	updateFreq(&Generator1);
 4e6:	1c20      	adds	r0, r4, #0
 4e8:	f000 f9aa 	bl	840 <updateFreq>
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVEN |= evt;
 4ec:	4b0a      	ldr	r3, [pc, #40]	; (518 <MIDI_NoteOn+0x9c>)
 4ee:	2101      	movs	r1, #1
 4f0:	681a      	ldr	r2, [r3, #0]
 4f2:	430a      	orrs	r2, r1
 4f4:	601a      	str	r2, [r3, #0]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 4f6:	4b09      	ldr	r3, [pc, #36]	; (51c <MIDI_NoteOn+0xa0>)
 4f8:	2280      	movs	r2, #128	; 0x80
 4fa:	0092      	lsls	r2, r2, #2
 4fc:	601a      	str	r2, [r3, #0]

	// start the exciter
	Chip_SCT_EnableEventInt(LPC_SCT, SCT_EVT_0);
	NVIC_EnableIRQ(SCT_IRQn);
}
 4fe:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 500:	10000106 	.word	0x10000106
 504:	10000119 	.word	0x10000119
 508:	10000148 	.word	0x10000148
 50c:	10000100 	.word	0x10000100
 510:	10000108 	.word	0x10000108
 514:	00000e30 	.word	0x00000e30
 518:	500040f0 	.word	0x500040f0
 51c:	e000e100 	.word	0xe000e100

00000520 <MIDI_NoteOff>:

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
 520:	b513      	push	{r0, r1, r4, lr}
	if (note == activeNote)
 522:	4c09      	ldr	r4, [pc, #36]	; (548 <MIDI_NoteOff+0x28>)
 524:	7823      	ldrb	r3, [r4, #0]
 526:	b25a      	sxtb	r2, r3
 528:	4290      	cmp	r0, r2
 52a:	d10c      	bne.n	546 <MIDI_NoteOff+0x26>
	{
		uint8_t value = 255 - activeNote;
 52c:	466a      	mov	r2, sp
 52e:	43db      	mvns	r3, r3
 530:	3207      	adds	r2, #7
		TLC_SetDACValue(FilterDAC, 1, &value);
 532:	2000      	movs	r0, #0
 534:	2101      	movs	r1, #1

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
	if (note == activeNote)
	{
		uint8_t value = 255 - activeNote;
 536:	7013      	strb	r3, [r2, #0]
		TLC_SetDACValue(FilterDAC, 1, &value);
 538:	f000 f904 	bl	744 <TLC_SetDACValue>

		// set to Idle
		activeNote = -1;
 53c:	23ff      	movs	r3, #255	; 0xff

		// reset envelope to release
		EnvRelease(&GlobalEnv);
 53e:	4803      	ldr	r0, [pc, #12]	; (54c <MIDI_NoteOff+0x2c>)
	{
		uint8_t value = 255 - activeNote;
		TLC_SetDACValue(FilterDAC, 1, &value);

		// set to Idle
		activeNote = -1;
 540:	7023      	strb	r3, [r4, #0]

		// reset envelope to release
		EnvRelease(&GlobalEnv);
 542:	f000 f84a 	bl	5da <EnvRelease>
	}
}
 546:	bd13      	pop	{r0, r1, r4, pc}
 548:	10000106 	.word	0x10000106
 54c:	10000148 	.word	0x10000148

00000550 <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 550:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 552:	4b0d      	ldr	r3, [pc, #52]	; (588 <CoreClockInit_30Hz+0x38>)
 554:	2224      	movs	r2, #36	; 0x24
 556:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 558:	228e      	movs	r2, #142	; 0x8e
 55a:	0092      	lsls	r2, r2, #2
 55c:	5899      	ldr	r1, [r3, r2]
 55e:	2080      	movs	r0, #128	; 0x80
 560:	4381      	bics	r1, r0
 562:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 564:	68d8      	ldr	r0, [r3, #12]
 566:	2101      	movs	r1, #1
 568:	4a07      	ldr	r2, [pc, #28]	; (588 <CoreClockInit_30Hz+0x38>)
 56a:	4208      	tst	r0, r1
 56c:	d0fa      	beq.n	564 <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 56e:	2003      	movs	r0, #3
 570:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 572:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 574:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 576:	07d1      	lsls	r1, r2, #31
 578:	d5fc      	bpl.n	574 <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 57a:	4b03      	ldr	r3, [pc, #12]	; (588 <CoreClockInit_30Hz+0x38>)
 57c:	2202      	movs	r2, #2
 57e:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 580:	f000 f992 	bl	8a8 <SystemCoreClockUpdate>
}
 584:	bd08      	pop	{r3, pc}
 586:	46c0      	nop			; (mov r8, r8)
 588:	40048000 	.word	0x40048000

0000058c <EnvInit>:
}


void EnvReset(env_t* env)
{
	env->index = 0;
 58c:	2300      	movs	r3, #0
#include "BAP_Envelope.h"
#include "BAP_math.h"

void EnvInit(env_t* env, envNode_t* nodes, uint16_t size)
{
	env->node = nodes;
 58e:	6001      	str	r1, [r0, #0]
	env->size = size;
 590:	81c2      	strh	r2, [r0, #14]
}


void EnvReset(env_t* env)
{
	env->index = 0;
 592:	8183      	strh	r3, [r0, #12]
	env->position = 0;
 594:	6083      	str	r3, [r0, #8]
	env->value = 0;
 596:	6043      	str	r3, [r0, #4]
void EnvInit(env_t* env, envNode_t* nodes, uint16_t size)
{
	env->node = nodes;
	env->size = size;
	EnvReset(env);
}
 598:	4770      	bx	lr

0000059a <EnvGenSample>:


int32_t EnvGenSample(env_t* env)
{
 59a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	// get node
	envNode_t node = env->node[env->index];
 59c:	6805      	ldr	r5, [r0, #0]
	EnvReset(env);
}


int32_t EnvGenSample(env_t* env)
{
 59e:	1c04      	adds	r4, r0, #0
	// get node
	envNode_t node = env->node[env->index];
 5a0:	89a0      	ldrh	r0, [r4, #12]
 5a2:	220c      	movs	r2, #12
 5a4:	4342      	muls	r2, r0
 5a6:	18aa      	adds	r2, r5, r2
 5a8:	6811      	ldr	r1, [r2, #0]
 5aa:	6853      	ldr	r3, [r2, #4]
 5ac:	7a16      	ldrb	r6, [r2, #8]

	// get the length of the current node
	uint32_t len = node.length;

	// if we're holding... well... hold.
	if (env->position > len && node.hold)
 5ae:	68a2      	ldr	r2, [r4, #8]
 5b0:	428a      	cmp	r2, r1
 5b2:	d909      	bls.n	5c8 <EnvGenSample+0x2e>
 5b4:	2e00      	cmp	r6, #0
 5b6:	d002      	beq.n	5be <EnvGenSample+0x24>
	{
		env->position = len;
 5b8:	60a1      	str	r1, [r4, #8]
		return node.level;
 5ba:	1c18      	adds	r0, r3, #0
 5bc:	e00c      	b.n	5d8 <EnvGenSample+0x3e>

	// if the position falls outside the node
	if ((env->position > len))
	{
		// shorten the length
		env->position -= len;
 5be:	1a51      	subs	r1, r2, r1

		// advance the node
		env->index++;
 5c0:	3001      	adds	r0, #1

	// if the position falls outside the node
	if ((env->position > len))
	{
		// shorten the length
		env->position -= len;
 5c2:	60a1      	str	r1, [r4, #8]

		// advance the node
		env->index++;
 5c4:	81a0      	strh	r0, [r4, #12]

		// and try again
		return EnvGenSample(env);
 5c6:	e7eb      	b.n	5a0 <EnvGenSample+0x6>
	}

	// scale between the current value and the desired result
	int32_t value = i_lscale(0, len, env->value, node.level, env->position);
 5c8:	9200      	str	r2, [sp, #0]
 5ca:	2000      	movs	r0, #0
 5cc:	6862      	ldr	r2, [r4, #4]
 5ce:	f000 f94d 	bl	86c <i_lscale>

	// advance the position
	env->position++;
 5d2:	68a3      	ldr	r3, [r4, #8]
 5d4:	3301      	adds	r3, #1
 5d6:	60a3      	str	r3, [r4, #8]

	// return the value
	return value;
}
 5d8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

000005da <EnvRelease>:


void EnvRelease(env_t* env)
{
	// Jump to the last node
	env->index = env->size - 1;
 5da:	89c3      	ldrh	r3, [r0, #14]
 5dc:	3b01      	subs	r3, #1
 5de:	8183      	strh	r3, [r0, #12]
	env->position = 0;
 5e0:	2300      	movs	r3, #0
 5e2:	6083      	str	r3, [r0, #8]
}
 5e4:	4770      	bx	lr

000005e6 <EnvReset>:


void EnvReset(env_t* env)
{
	env->index = 0;
 5e6:	2300      	movs	r3, #0
 5e8:	8183      	strh	r3, [r0, #12]
	env->position = 0;
 5ea:	6083      	str	r3, [r0, #8]
	env->value = 0;
 5ec:	6043      	str	r3, [r0, #4]
}
 5ee:	4770      	bx	lr

000005f0 <MIDI_USARTInit>:

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 5f0:	b538      	push	{r3, r4, r5, lr}
 * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetUARTClockDiv(uint32_t div)
{
	LPC_SYSCTL->UARTCLKDIV = div;
 5f2:	4b0f      	ldr	r3, [pc, #60]	; (630 <MIDI_USARTInit+0x40>)
 5f4:	2501      	movs	r5, #1
 5f6:	601d      	str	r5, [r3, #0]
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	uint32_t reg;

	reg = pUART->CFG & ~((0x3 << 2) | (0x3 << 4) | (0x1 << 6));
 5f8:	6803      	ldr	r3, [r0, #0]
 5fa:	227c      	movs	r2, #124	; 0x7c
 5fc:	4393      	bics	r3, r2
	pUART->CFG = reg | config;
 5fe:	2204      	movs	r2, #4
 600:	4313      	orrs	r3, r2
 602:	6003      	str	r3, [r0, #0]

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 604:	490b      	ldr	r1, [pc, #44]	; (634 <MIDI_USARTInit+0x44>)

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 606:	1c04      	adds	r4, r0, #0

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 608:	f000 fa86 	bl	b18 <Chip_UART_SetBaud>
	/***
	 *  Initialize the RX and TX specific functions
	 **/
#ifdef MIDI_RX_ENABLE
		// Initialize the Receive buffer
		RingBuffer_Init(&MIDI_RxBuffer, &MIDI_RxData, sizeof(uint8_t), MIDI_RXBUFFERSIZE);
 60c:	1c2a      	adds	r2, r5, #0
 60e:	490a      	ldr	r1, [pc, #40]	; (638 <MIDI_USARTInit+0x48>)
 610:	230a      	movs	r3, #10
 612:	480a      	ldr	r0, [pc, #40]	; (63c <MIDI_USARTInit+0x4c>)
 614:	f000 f9e2 	bl	9dc <RingBuffer_Init>

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 618:	4b09      	ldr	r3, [pc, #36]	; (640 <MIDI_USARTInit+0x50>)
 61a:	2200      	movs	r2, #0
 61c:	701a      	strb	r2, [r3, #0]
 61e:	705a      	strb	r2, [r3, #1]
 620:	709a      	strb	r2, [r3, #2]
 622:	70da      	strb	r2, [r3, #3]
 624:	4b07      	ldr	r3, [pc, #28]	; (644 <MIDI_USARTInit+0x54>)
 626:	2208      	movs	r2, #8
 * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
 *			to enable specific UART interrupts.
 */
STATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
{
	pUART->INTENSET = intMask;
 628:	60e5      	str	r5, [r4, #12]
 62a:	601a      	str	r2, [r3, #0]
		Chip_UART_IntEnable(USARTNumber, UART_INTEN_TXRDY);
#endif

	MIDI_ClearStatus0();
	NVIC_EnableIRQ(UART0_IRQn);
}
 62c:	bd38      	pop	{r3, r4, r5, pc}
 62e:	46c0      	nop			; (mov r8, r8)
 630:	40048094 	.word	0x40048094
 634:	00007a12 	.word	0x00007a12
 638:	10000128 	.word	0x10000128
 63c:	10000134 	.word	0x10000134
 640:	1000011b 	.word	0x1000011b
 644:	e000e100 	.word	0xe000e100

00000648 <MIDI_SetAddress>:
/***
 * Sets the address of the current receiver
 **/
void inline MIDI_SetAddress(uint8_t addr)
{
	MIDI_Address = addr;
 648:	4b01      	ldr	r3, [pc, #4]	; (650 <MIDI_SetAddress+0x8>)
 64a:	7018      	strb	r0, [r3, #0]
}
 64c:	4770      	bx	lr
 64e:	46c0      	nop			; (mov r8, r8)
 650:	1000011a 	.word	0x1000011a

00000654 <MIDI_Enable>:
 */

void inline MIDI_Enable(LPC_USART_T* USARTNumber)
{
	// Enable the UART to start receiving messages
	USARTNumber->CFG |= UART_CFG_ENABLE;
 654:	6803      	ldr	r3, [r0, #0]
 656:	2201      	movs	r2, #1
 658:	4313      	orrs	r3, r2
 65a:	6003      	str	r3, [r0, #0]
}
 65c:	4770      	bx	lr
	...

00000660 <MIDI_ProcessRXBuffer>:
	}
}


void MIDI_ProcessRXBuffer()
{
 660:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t byte = 0;
 662:	2400      	movs	r4, #0
 664:	466d      	mov	r5, sp
 666:	71ec      	strb	r4, [r5, #7]
 668:	3507      	adds	r5, #7
	// Pop a value off the buffer

	if(Chip_UART_ReadRB(LPC_USART0, &MIDI_RxBuffer, &byte, 1) != 0)
 66a:	481a      	ldr	r0, [pc, #104]	; (6d4 <MIDI_ProcessRXBuffer+0x74>)
 66c:	491a      	ldr	r1, [pc, #104]	; (6d8 <MIDI_ProcessRXBuffer+0x78>)
 66e:	1c2a      	adds	r2, r5, #0
 670:	2301      	movs	r3, #1
 672:	f000 fa83 	bl	b7c <Chip_UART_ReadRB>
 676:	42a0      	cmp	r0, r4
 678:	d02b      	beq.n	6d2 <MIDI_ProcessRXBuffer+0x72>
	{
		// Is it a status bit
		if((byte & MIDI_STATBIT))
 67a:	7829      	ldrb	r1, [r5, #0]
 67c:	4b17      	ldr	r3, [pc, #92]	; (6dc <MIDI_ProcessRXBuffer+0x7c>)
 67e:	b24a      	sxtb	r2, r1
 680:	42a2      	cmp	r2, r4
 682:	da0c      	bge.n	69e <MIDI_ProcessRXBuffer+0x3e>
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 684:	4a16      	ldr	r2, [pc, #88]	; (6e0 <MIDI_ProcessRXBuffer+0x80>)
 686:	200f      	movs	r0, #15
 688:	7812      	ldrb	r2, [r2, #0]
		// Is it a status bit
		if((byte & MIDI_STATBIT))
		{
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;
 68a:	7019      	strb	r1, [r3, #0]

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 68c:	705c      	strb	r4, [r3, #1]
 68e:	709c      	strb	r4, [r3, #2]
 690:	70dc      	strb	r4, [r3, #3]
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 692:	4001      	ands	r1, r0
 694:	428a      	cmp	r2, r1
 696:	d11a      	bne.n	6ce <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_Status0.Addressed = 1;
 698:	2201      	movs	r2, #1
 69a:	705a      	strb	r2, [r3, #1]
 69c:	e017      	b.n	6ce <MIDI_ProcessRXBuffer+0x6e>
			}
		}
		else if (MIDI_Status0.Addressed)
 69e:	785a      	ldrb	r2, [r3, #1]
 6a0:	2a00      	cmp	r2, #0
 6a2:	d014      	beq.n	6ce <MIDI_ProcessRXBuffer+0x6e>
		{
			MIDI_Status0.DataCount++;
 6a4:	789a      	ldrb	r2, [r3, #2]
 6a6:	3201      	adds	r2, #1
 6a8:	b2d2      	uxtb	r2, r2
 6aa:	709a      	strb	r2, [r3, #2]


static void MIDI_ByteProcessor(uint8_t byte)
{
	// If it's the first byte, store it.
	if ((MIDI_Status0.DataCount % 2))
 6ac:	07d0      	lsls	r0, r2, #31
 6ae:	d501      	bpl.n	6b4 <MIDI_ProcessRXBuffer+0x54>
		MIDI_Status0.DB1 = byte;
 6b0:	70d9      	strb	r1, [r3, #3]
 6b2:	e00c      	b.n	6ce <MIDI_ProcessRXBuffer+0x6e>
	// else, send it to a function
	else
	{
		switch(MIDI_Status0.Status)
 6b4:	781a      	ldrb	r2, [r3, #0]
 6b6:	2a80      	cmp	r2, #128	; 0x80
 6b8:	d003      	beq.n	6c2 <MIDI_ProcessRXBuffer+0x62>
 6ba:	2a90      	cmp	r2, #144	; 0x90
 6bc:	d107      	bne.n	6ce <MIDI_ProcessRXBuffer+0x6e>
		{
		case MIDI_NOTEON:
			if ( MIDI_NoteOnFunc != 0)
 6be:	4a09      	ldr	r2, [pc, #36]	; (6e4 <MIDI_ProcessRXBuffer+0x84>)
 6c0:	e000      	b.n	6c4 <MIDI_ProcessRXBuffer+0x64>
			{
				MIDI_NoteOnFunc(MIDI_Status0.DB1, byte);
			}
			break;
		case MIDI_NOTEOFF:
			if ( MIDI_NoteOffFunc != 0)
 6c2:	4a09      	ldr	r2, [pc, #36]	; (6e8 <MIDI_ProcessRXBuffer+0x88>)
 6c4:	6812      	ldr	r2, [r2, #0]
 6c6:	2a00      	cmp	r2, #0
 6c8:	d001      	beq.n	6ce <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_NoteOffFunc(MIDI_Status0.DB1, byte);
 6ca:	78d8      	ldrb	r0, [r3, #3]
 6cc:	4790      	blx	r2
			MIDI_Status0.DataCount++;
			MIDI_ByteProcessor(byte);
		}

		// Process the next byte
		MIDI_ProcessRXBuffer();
 6ce:	f7ff ffc7 	bl	660 <MIDI_ProcessRXBuffer>
	}
}
 6d2:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 6d4:	40064000 	.word	0x40064000
 6d8:	10000134 	.word	0x10000134
 6dc:	1000011b 	.word	0x1000011b
 6e0:	1000011a 	.word	0x1000011a
 6e4:	10000124 	.word	0x10000124
 6e8:	10000120 	.word	0x10000120

000006ec <UART0_IRQHandler>:


void UART0_IRQHandler(void)
{
 6ec:	b508      	push	{r3, lr}
	// Insert value into RB
	Chip_UART_RXIntHandlerRB(LPC_USART0, &MIDI_RxBuffer);
 6ee:	4802      	ldr	r0, [pc, #8]	; (6f8 <UART0_IRQHandler+0xc>)
 6f0:	4902      	ldr	r1, [pc, #8]	; (6fc <UART0_IRQHandler+0x10>)
 6f2:	f000 fa2f 	bl	b54 <Chip_UART_RXIntHandlerRB>
}
 6f6:	bd08      	pop	{r3, pc}
 6f8:	40064000 	.word	0x40064000
 6fc:	10000134 	.word	0x10000134

00000700 <TLC_Init>:

#include "chip.h"
#include "BAP_TLC_DAC.h"

void TLC_Init()
{
 700:	b510      	push	{r4, lr}
	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_HI)) & ~((uint32_t) SPI_CFG_SPI_EN);
 702:	2392      	movs	r3, #146	; 0x92
 704:	4c0c      	ldr	r4, [pc, #48]	; (738 <TLC_Init+0x38>)
 706:	005b      	lsls	r3, r3, #1
 708:	6023      	str	r3, [r4, #0]

	// Set the rate to 1MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 1000000));
 70a:	1c20      	adds	r0, r4, #0
 70c:	490b      	ldr	r1, [pc, #44]	; (73c <TLC_Init+0x3c>)
 70e:	f000 f9c5 	bl	a9c <Chip_SPI_CalClkRateDivider>
 712:	b280      	uxth	r0, r0
 714:	6260      	str	r0, [r4, #36]	; 0x24
 * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_CLR_*)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
{
	pSPI->STAT |= Flag;
 716:	68a3      	ldr	r3, [r4, #8]
 718:	223c      	movs	r2, #60	; 0x3c
 71a:	4313      	orrs	r3, r2
 71c:	60a3      	str	r3, [r4, #8]

	// Clear status flags
	Chip_SPI_ClearStatus(LPC_SPI0, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);

	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN | SPI_INTENCLR_RXDYEN | SPI_INTENCLR_RXOVEN | SPI_INTENCLR_TXUREN, DISABLE);
 71e:	1c20      	adds	r0, r4, #0
 720:	210f      	movs	r1, #15
 722:	2200      	movs	r2, #0
 724:	f000 f9c2 	bl	aac <Chip_SPI_Int_Cmd>
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
{
	pSPI->CFG |= SPI_CFG_SPI_EN;
 728:	6822      	ldr	r2, [r4, #0]
 72a:	2301      	movs	r3, #1
 72c:	431a      	orrs	r2, r3
 72e:	6022      	str	r2, [r4, #0]
 730:	4a03      	ldr	r2, [pc, #12]	; (740 <TLC_Init+0x40>)
 732:	6013      	str	r3, [r2, #0]

	// Enable the SPI
	Chip_SPI_Enable(LPC_SPI0);
 	NVIC_EnableIRQ(SPI0_IRQn);
}
 734:	bd10      	pop	{r4, pc}
 736:	46c0      	nop			; (mov r8, r8)
 738:	40058000 	.word	0x40058000
 73c:	000f4240 	.word	0x000f4240
 740:	e000e100 	.word	0xe000e100

00000744 <TLC_SetDACValue>:


void TLC_SetDACValue(TLC_DACNumber DAC, TLC_Range range, uint8_t* value)
{
	// A frame is 11 bits: 2 bit address, 1 bit range, 8 bits data.
	uint16_t frame = (uint16_t)(TLC_DAC(DAC) | TLC_RNG(range) | TLC_Datamask(*value));
 744:	7813      	ldrb	r3, [r2, #0]
 746:	0209      	lsls	r1, r1, #8
 748:	4319      	orrs	r1, r3
 74a:	0240      	lsls	r0, r0, #9
 74c:	4301      	orrs	r1, r0
 74e:	b289      	uxth	r1, r1
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
 */
STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
{
	return pSPI->STAT;
 750:	4b04      	ldr	r3, [pc, #16]	; (764 <TLC_SetDACValue+0x20>)
 752:	689a      	ldr	r2, [r3, #8]

	// Wait for the SPI to be ready
	// This is a blocking method
	while (!(Chip_SPI_GetStatus(LPC_SPI0) & SPI_STAT_TXRDY)){/*do nothing*/}
 754:	0790      	lsls	r0, r2, #30
 756:	d5fb      	bpl.n	750 <TLC_SetDACValue+0xc>
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 758:	20a7      	movs	r0, #167	; 0xa7
 75a:	0500      	lsls	r0, r0, #20
 75c:	4308      	orrs	r0, r1
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 75e:	6198      	str	r0, [r3, #24]
	// Send a frame.
	// Since there is no need to read a response,
	// and the full message fits with a frame,
	// we assume this will be the final frame.
	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 11);
}
 760:	4770      	bx	lr
 762:	46c0      	nop			; (mov r8, r8)
 764:	40058000 	.word	0x40058000

00000768 <WaveGenStart>:
}


void WaveGenStart(WaveGen* Generator)
{
	switch(Generator->ID)
 768:	7803      	ldrb	r3, [r0, #0]
 76a:	2b00      	cmp	r3, #0
 76c:	d104      	bne.n	778 <WaveGenStart+0x10>
	{
	case 0:
		LPC_SCT->CTRL_U &= ~(1 << 2);
 76e:	4b03      	ldr	r3, [pc, #12]	; (77c <WaveGenStart+0x14>)
 770:	2104      	movs	r1, #4
 772:	685a      	ldr	r2, [r3, #4]
 774:	438a      	bics	r2, r1
 776:	605a      	str	r2, [r3, #4]
		break;
	case 1:
		break;
	}
}
 778:	4770      	bx	lr
 77a:	46c0      	nop			; (mov r8, r8)
 77c:	50004000 	.word	0x50004000

00000780 <setWidth>:


void setWidth(WaveGen* Generator, uint8_t percentage)
{
 780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 782:	1c05      	adds	r5, r0, #0
 784:	1c0c      	adds	r4, r1, #0
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 786:	f000 f91f 	bl	9c8 <Chip_Clock_GetSystemClockRate>
	int genID = Generator->ID;
 78a:	782f      	ldrb	r7, [r5, #0]


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 78c:	686e      	ldr	r6, [r5, #4]
	int genID = Generator->ID;

	// TODO: actually write some good code here instead of dumb code.
	if ((genID < 0) || (genID > 3)) {
 78e:	2f03      	cmp	r7, #3
 790:	d818      	bhi.n	7c4 <setWidth+0x44>
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
 792:	2301      	movs	r3, #1
	if ((genID < 0) || (genID > 3)) {
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
 794:	2c63      	cmp	r4, #99	; 0x63
 796:	d810      	bhi.n	7ba <setWidth+0x3a>


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 798:	f000 fb17 	bl	dca <__aeabi_ui2f>
 79c:	1c31      	adds	r1, r6, #0
 79e:	f000 fa61 	bl	c64 <__aeabi_fdiv>
 7a2:	f000 facf 	bl	d44 <__aeabi_f2uiz>
 7a6:	1c06      	adds	r6, r0, #0
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
		value = reload + 1;
 7a8:	1c43      	adds	r3, r0, #1
	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
 7aa:	2c00      	cmp	r4, #0
 7ac:	d005      	beq.n	7ba <setWidth+0x3a>
		value = reload + 1;
	}
	else {
		uint32_t newTicks;

		newTicks = (reload * percentage)/100;
 7ae:	1c20      	adds	r0, r4, #0
 7b0:	4370      	muls	r0, r6
 7b2:	2164      	movs	r1, #100	; 0x64
 7b4:	f000 fa1b 	bl	bee <__aeabi_uidiv>

		/* Approximate duty cycle rate */
		value = reload - newTicks;
 7b8:	1a33      	subs	r3, r6, r0
	}

	LPC_SCT->MATCHREL[genID + 1].U = value;
 7ba:	3781      	adds	r7, #129	; 0x81
 7bc:	4a02      	ldr	r2, [pc, #8]	; (7c8 <setWidth+0x48>)
 7be:	00bf      	lsls	r7, r7, #2
 7c0:	50bb      	str	r3, [r7, r2]
	Generator->width = percentage;
 7c2:	722c      	strb	r4, [r5, #8]
}
 7c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 7c6:	46c0      	nop			; (mov r8, r8)
 7c8:	50004000 	.word	0x50004000

000007cc <WaveGenInit>:

/********************************************************************************************************
 * 											FUNCTIONS													*
 *******************************************************************************************************/
void WaveGenInit(WaveGen* Generator, float freq)
{
 7cc:	b538      	push	{r3, r4, r5, lr}
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 7ce:	4c14      	ldr	r4, [pc, #80]	; (820 <WaveGenInit+0x54>)
 7d0:	2301      	movs	r3, #1

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 7d2:	2207      	movs	r2, #7
void WaveGenInit(WaveGen* Generator, float freq)
{
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 7d4:	6023      	str	r3, [r4, #0]

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 7d6:	6522      	str	r2, [r4, #80]	; 0x50
	{
		freq = 1;
	}

	/* Setup for match mode */
	LPC_SCT->REGMODE_L = 0;
 7d8:	1c22      	adds	r2, r4, #0
 7da:	2500      	movs	r5, #0
 7dc:	324c      	adds	r2, #76	; 0x4c
 7de:	8015      	strh	r5, [r2, #0]

	// what does this do?
	LPC_SCT->EVENT[0].CTRL = 0x00001000;
 7e0:	2180      	movs	r1, #128	; 0x80
 7e2:	22c1      	movs	r2, #193	; 0xc1
 7e4:	0149      	lsls	r1, r1, #5
 7e6:	0092      	lsls	r2, r2, #2
 7e8:	50a1      	str	r1, [r4, r2]

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;
 7ea:	22c0      	movs	r2, #192	; 0xc0
 7ec:	4259      	negs	r1, r3
 7ee:	0092      	lsls	r2, r2, #2
 7f0:	50a1      	str	r1, [r4, r2]
	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 7f2:	4a0c      	ldr	r2, [pc, #48]	; (824 <WaveGenInit+0x58>)

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;

	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);
 7f4:	8123      	strh	r3, [r4, #8]

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 7f6:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[1].CLR = (1 << 0);
 7f8:	4a0b      	ldr	r2, [pc, #44]	; (828 <WaveGenInit+0x5c>)

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 7fa:	490c      	ldr	r1, [pc, #48]	; (82c <WaveGenInit+0x60>)
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
	LPC_SCT->OUT[1].CLR = (1 << 0);
 7fc:	50a3      	str	r3, [r4, r2]

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 7fe:	22c3      	movs	r2, #195	; 0xc3
 800:	0092      	lsls	r2, r2, #2
 802:	50a1      	str	r1, [r4, r2]
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
 804:	22c2      	movs	r2, #194	; 0xc2
 806:	0092      	lsls	r2, r2, #2
 808:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[0].SET = (1 << 1);
 80a:	23a0      	movs	r3, #160	; 0xa0
 80c:	2202      	movs	r2, #2
 80e:	00db      	lsls	r3, r3, #3
 810:	50e2      	str	r2, [r4, r3]

	setWidth(Generator, 50);
 812:	2132      	movs	r1, #50	; 0x32

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 814:	3406      	adds	r4, #6
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
	LPC_SCT->OUT[0].SET = (1 << 1);

	setWidth(Generator, 50);
 816:	f7ff ffb3 	bl	780 <setWidth>

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 81a:	87e5      	strh	r5, [r4, #62]	; 0x3e
}
 81c:	bd38      	pop	{r3, r4, r5, pc}
 81e:	46c0      	nop			; (mov r8, r8)
 820:	50004000 	.word	0x50004000
 824:	00000504 	.word	0x00000504
 828:	0000050c 	.word	0x0000050c
 82c:	00001001 	.word	0x00001001

00000830 <setReload>:
}


void setReload(WaveGen* Generator, int reload)
{
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
 830:	7802      	ldrb	r2, [r0, #0]
 832:	4b02      	ldr	r3, [pc, #8]	; (83c <setReload+0xc>)
 834:	3280      	adds	r2, #128	; 0x80
 836:	0092      	lsls	r2, r2, #2
 838:	50d1      	str	r1, [r2, r3]
}
 83a:	4770      	bx	lr
 83c:	50004000 	.word	0x50004000

00000840 <updateFreq>:

void updateFreq(WaveGen* Generator)
{
 840:	b510      	push	{r4, lr}
 842:	1c04      	adds	r4, r0, #0
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 844:	f000 f8c0 	bl	9c8 <Chip_Clock_GetSystemClockRate>
 848:	7822      	ldrb	r2, [r4, #0]
 84a:	4b07      	ldr	r3, [pc, #28]	; (868 <updateFreq+0x28>)
 84c:	3280      	adds	r2, #128	; 0x80
 84e:	0092      	lsls	r2, r2, #2
 850:	58d1      	ldr	r1, [r2, r3]
 852:	f000 f9cc 	bl	bee <__aeabi_uidiv>
 856:	f000 fab8 	bl	dca <__aeabi_ui2f>
	setWidth(Generator, Generator->width);
 85a:	7a21      	ldrb	r1, [r4, #8]
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
}

void updateFreq(WaveGen* Generator)
{
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 85c:	6060      	str	r0, [r4, #4]
	setWidth(Generator, Generator->width);
 85e:	1c20      	adds	r0, r4, #0
 860:	f7ff ff8e 	bl	780 <setWidth>
}
 864:	bd10      	pop	{r4, pc}
 866:	46c0      	nop			; (mov r8, r8)
 868:	50004000 	.word	0x50004000

0000086c <i_lscale>:
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 86c:	b538      	push	{r3, r4, r5, lr}
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
 86e:	1a09      	subs	r1, r1, r0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 870:	1c05      	adds	r5, r0, #0
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
	{
		return y;
 872:	2000      	movs	r0, #0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 874:	1c14      	adds	r4, r2, #0
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
 876:	4281      	cmp	r1, r0
 878:	d007      	beq.n	88a <i_lscale+0x1e>
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
 87a:	1a9b      	subs	r3, r3, r2
	int32_t X = x - minX;
 87c:	9a04      	ldr	r2, [sp, #16]
 87e:	1b55      	subs	r5, r2, r5
	{
		return y;
	}

	// calculate scaled position
	y = minY + ((DeltaY *X) /DeltaX);
 880:	1c28      	adds	r0, r5, #0
 882:	4358      	muls	r0, r3
 884:	f000 f9b0 	bl	be8 <__aeabi_idiv>
 888:	1820      	adds	r0, r4, r0
	//{
	//	y += (maxY > minY ? maxY : minY);
	//}

	return y;
}
 88a:	bd38      	pop	{r3, r4, r5, pc}

0000088c <LFSR>:
}

uint32_t LFSR()
{
	static uint32_t lfsr = 0xACE1u;
	uint8_t lsb = lfsr & 1;
 88c:	4b05      	ldr	r3, [pc, #20]	; (8a4 <LFSR+0x18>)
 88e:	6819      	ldr	r1, [r3, #0]
	lfsr >>= 1;
 890:	084a      	lsrs	r2, r1, #1

	if (lsb == 1)
 892:	07c8      	lsls	r0, r1, #31
 894:	d502      	bpl.n	89c <LFSR+0x10>
	{
		/* Only apply toggle mask if output bit is 1. */
		lfsr ^= 0xB400u;
 896:	21b4      	movs	r1, #180	; 0xb4
 898:	0209      	lsls	r1, r1, #8
 89a:	404a      	eors	r2, r1
 89c:	601a      	str	r2, [r3, #0]
	}
	return lfsr;
 89e:	6818      	ldr	r0, [r3, #0]
}
 8a0:	4770      	bx	lr
 8a2:	46c0      	nop			; (mov r8, r8)
 8a4:	10000114 	.word	0x10000114

000008a8 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 8a8:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 8aa:	f000 f88d 	bl	9c8 <Chip_Clock_GetSystemClockRate>
 8ae:	4b01      	ldr	r3, [pc, #4]	; (8b4 <SystemCoreClockUpdate+0xc>)
 8b0:	6018      	str	r0, [r3, #0]
}
 8b2:	bd08      	pop	{r3, pc}
 8b4:	10000158 	.word	0x10000158

000008b8 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 8b8:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 8ba:	05c2      	lsls	r2, r0, #23
 8bc:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 8be:	211f      	movs	r1, #31
 8c0:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 8c2:	0092      	lsls	r2, r2, #2
 8c4:	4b03      	ldr	r3, [pc, #12]	; (8d4 <Chip_Clock_GetWDTLFORate+0x1c>)
 8c6:	58d0      	ldr	r0, [r2, r3]
 8c8:	3101      	adds	r1, #1
 8ca:	0049      	lsls	r1, r1, #1
 8cc:	f000 f98f 	bl	bee <__aeabi_uidiv>
}
 8d0:	bd08      	pop	{r3, pc}
 8d2:	46c0      	nop			; (mov r8, r8)
 8d4:	00000eb8 	.word	0x00000eb8

000008d8 <Chip_Clock_GetPLLFreq>:

/* Compute a PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t msel = ((PLLReg & 0x1F) + 1);
 8d8:	231f      	movs	r3, #31
 8da:	4018      	ands	r0, r3
 8dc:	3001      	adds	r0, #1

	return inputRate * msel;
 8de:	4348      	muls	r0, r1
}
 8e0:	4770      	bx	lr
 8e2:	46c0      	nop			; (mov r8, r8)

000008e4 <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 8e4:	4b03      	ldr	r3, [pc, #12]	; (8f4 <Chip_Clock_SetSystemPLLSource+0x10>)
 8e6:	6418      	str	r0, [r3, #64]	; 0x40
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;
 8e8:	2200      	movs	r2, #0
 8ea:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;
 8ec:	2201      	movs	r2, #1
 8ee:	645a      	str	r2, [r3, #68]	; 0x44
}
 8f0:	4770      	bx	lr
 8f2:	46c0      	nop			; (mov r8, r8)
 8f4:	40048000 	.word	0x40048000

000008f8 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 8f8:	4b03      	ldr	r3, [pc, #12]	; (908 <Chip_Clock_SetMainClockSource+0x10>)
 8fa:	6718      	str	r0, [r3, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN  = 0;
 8fc:	2200      	movs	r2, #0
 8fe:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 900:	2201      	movs	r2, #1
 902:	675a      	str	r2, [r3, #116]	; 0x74
}
 904:	4770      	bx	lr
 906:	46c0      	nop			; (mov r8, r8)
 908:	40048000 	.word	0x40048000

0000090c <Chip_Clock_SetCLKOUTSource>:

/* Set CLKOUT clock source and divider */
void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
{
	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
 90c:	4b05      	ldr	r3, [pc, #20]	; (924 <Chip_Clock_SetCLKOUTSource+0x18>)
 90e:	22e0      	movs	r2, #224	; 0xe0
 910:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 0;
 912:	22e4      	movs	r2, #228	; 0xe4
 914:	2000      	movs	r0, #0
 916:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 1;
 918:	2001      	movs	r0, #1
 91a:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTDIV = div;
 91c:	22e8      	movs	r2, #232	; 0xe8
 91e:	5099      	str	r1, [r3, r2]
}
 920:	4770      	bx	lr
 922:	46c0      	nop			; (mov r8, r8)
 924:	40048000 	.word	0x40048000

00000928 <Chip_Clock_GetWDTOSCRate>:

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 928:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 92a:	4b02      	ldr	r3, [pc, #8]	; (934 <Chip_Clock_GetWDTOSCRate+0xc>)
 92c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 92e:	f7ff ffc3 	bl	8b8 <Chip_Clock_GetWDTLFORate>
}
 932:	bd08      	pop	{r3, pc}
 934:	40048000 	.word	0x40048000

00000938 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 938:	4b09      	ldr	r3, [pc, #36]	; (960 <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 93a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 93c:	2303      	movs	r3, #3
 93e:	4013      	ands	r3, r2
 940:	2b01      	cmp	r3, #1
 942:	d005      	beq.n	950 <Chip_Clock_GetSystemPLLInClockRate+0x18>
 944:	2b03      	cmp	r3, #3
 946:	d006      	beq.n	956 <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 948:	2b00      	cmp	r3, #0
 94a:	d107      	bne.n	95c <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 94c:	4805      	ldr	r0, [pc, #20]	; (964 <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 94e:	e006      	b.n	95e <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 950:	4b05      	ldr	r3, [pc, #20]	; (968 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 952:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 954:	e003      	b.n	95e <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 956:	4b05      	ldr	r3, [pc, #20]	; (96c <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 958:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 95a:	e000      	b.n	95e <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 95c:	2000      	movs	r0, #0
		break;
	}

	return clkRate;
}
 95e:	4770      	bx	lr
 960:	40048000 	.word	0x40048000
 964:	00b71b00 	.word	0x00b71b00
 968:	00000e28 	.word	0x00000e28
 96c:	00000e2c 	.word	0x00000e2c

00000970 <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 970:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 972:	4b04      	ldr	r3, [pc, #16]	; (984 <Chip_Clock_GetSystemPLLOutClockRate+0x14>)
 974:	689c      	ldr	r4, [r3, #8]
 976:	f7ff ffdf 	bl	938 <Chip_Clock_GetSystemPLLInClockRate>
 97a:	1c01      	adds	r1, r0, #0
 97c:	1c20      	adds	r0, r4, #0
 97e:	f7ff ffab 	bl	8d8 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 982:	bd10      	pop	{r4, pc}
 984:	40048000 	.word	0x40048000

00000988 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 988:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 98a:	4b0d      	ldr	r3, [pc, #52]	; (9c0 <Chip_Clock_GetMainClockRate+0x38>)
 98c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 98e:	2303      	movs	r3, #3
 990:	4013      	ands	r3, r2
 992:	2b01      	cmp	r3, #1
 994:	d009      	beq.n	9aa <Chip_Clock_GetMainClockRate+0x22>
 996:	dc02      	bgt.n	99e <Chip_Clock_GetMainClockRate+0x16>
 998:	2b00      	cmp	r3, #0
 99a:	d00f      	beq.n	9bc <Chip_Clock_GetMainClockRate+0x34>
 99c:	e003      	b.n	9a6 <Chip_Clock_GetMainClockRate+0x1e>
 99e:	2b02      	cmp	r3, #2
 9a0:	d006      	beq.n	9b0 <Chip_Clock_GetMainClockRate+0x28>
 9a2:	2b03      	cmp	r3, #3
 9a4:	d007      	beq.n	9b6 <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 9a6:	2000      	movs	r0, #0
 9a8:	e009      	b.n	9be <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 9aa:	f7ff ffc5 	bl	938 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 9ae:	e006      	b.n	9be <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 9b0:	f7ff ffba 	bl	928 <Chip_Clock_GetWDTOSCRate>
		break;
 9b4:	e003      	b.n	9be <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 9b6:	f7ff ffdb 	bl	970 <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 9ba:	e000      	b.n	9be <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 9bc:	4801      	ldr	r0, [pc, #4]	; (9c4 <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 9be:	bd08      	pop	{r3, pc}
 9c0:	40048000 	.word	0x40048000
 9c4:	00b71b00 	.word	0x00b71b00

000009c8 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 9c8:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 9ca:	f7ff ffdd 	bl	988 <Chip_Clock_GetMainClockRate>
 9ce:	4b02      	ldr	r3, [pc, #8]	; (9d8 <Chip_Clock_GetSystemClockRate+0x10>)
 9d0:	6f99      	ldr	r1, [r3, #120]	; 0x78
 9d2:	f000 f90c 	bl	bee <__aeabi_uidiv>
}
 9d6:	bd08      	pop	{r3, pc}
 9d8:	40048000 	.word	0x40048000

000009dc <RingBuffer_Init>:
 ****************************************************************************/

/* Initialize ring buffer */
int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
{
	RingBuff->data = buffer;
 9dc:	6001      	str	r1, [r0, #0]
	RingBuff->count = count;
 9de:	6043      	str	r3, [r0, #4]
	RingBuff->itemSz = itemSize;
 9e0:	6082      	str	r2, [r0, #8]
	RingBuff->head = RingBuff->tail = 0;
 9e2:	2300      	movs	r3, #0
 9e4:	6103      	str	r3, [r0, #16]
 9e6:	60c3      	str	r3, [r0, #12]

	return 1;
}
 9e8:	2001      	movs	r0, #1
 9ea:	4770      	bx	lr

000009ec <RingBuffer_Insert>:

/* Insert a single item into Ring Buffer */
int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
{
 9ec:	b538      	push	{r3, r4, r5, lr}
 9ee:	1c04      	adds	r4, r0, #0
	uint8_t *ptr = RingBuff->data;
 9f0:	6805      	ldr	r5, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 9f2:	68c2      	ldr	r2, [r0, #12]
 9f4:	6903      	ldr	r3, [r0, #16]
 9f6:	1ad2      	subs	r2, r2, r3
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is full, otherwise 0
 */
STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
{
	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
 9f8:	6843      	ldr	r3, [r0, #4]

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
 9fa:	429a      	cmp	r2, r3
 9fc:	da0d      	bge.n	a1a <RingBuffer_Insert+0x2e>
		return 0;

	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
 9fe:	3b01      	subs	r3, #1
 a00:	68c2      	ldr	r2, [r0, #12]
 a02:	4013      	ands	r3, r2
 a04:	6882      	ldr	r2, [r0, #8]
 a06:	1c10      	adds	r0, r2, #0
 a08:	4358      	muls	r0, r3
 a0a:	1828      	adds	r0, r5, r0
	memcpy(ptr, data, RingBuff->itemSz);
 a0c:	f000 f8e4 	bl	bd8 <memcpy>
	RingBuff->head++;
 a10:	68e3      	ldr	r3, [r4, #12]
 a12:	3301      	adds	r3, #1
 a14:	60e3      	str	r3, [r4, #12]

	return 1;
 a16:	2001      	movs	r0, #1
 a18:	e000      	b.n	a1c <RingBuffer_Insert+0x30>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
		return 0;
 a1a:	2000      	movs	r0, #0
	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
	memcpy(ptr, data, RingBuff->itemSz);
	RingBuff->head++;

	return 1;
}
 a1c:	bd38      	pop	{r3, r4, r5, pc}
 a1e:	46c0      	nop			; (mov r8, r8)

00000a20 <RingBuffer_PopMult>:
	return 1;
}

/* Pop multiple items from Ring buffer */
int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
{
 a20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 a22:	1c04      	adds	r4, r0, #0
 a24:	1c0f      	adds	r7, r1, #0
	uint8_t *ptr = RingBuff->data;
 a26:	6801      	ldr	r1, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 a28:	68c3      	ldr	r3, [r0, #12]
 a2a:	6900      	ldr	r0, [r0, #16]
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
 a2c:	4283      	cmp	r3, r0
 a2e:	d032      	beq.n	a96 <RingBuffer_PopMult+0x76>
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 a30:	68e0      	ldr	r0, [r4, #12]
 a32:	6923      	ldr	r3, [r4, #16]
 a34:	1ac0      	subs	r0, r0, r3
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
 a36:	6866      	ldr	r6, [r4, #4]
 a38:	1e73      	subs	r3, r6, #1
 a3a:	6925      	ldr	r5, [r4, #16]
 a3c:	402b      	ands	r3, r5
 a3e:	181d      	adds	r5, r3, r0
 a40:	42b5      	cmp	r5, r6
 a42:	d301      	bcc.n	a48 <RingBuffer_PopMult+0x28>
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
 a44:	1af6      	subs	r6, r6, r3
 a46:	e000      	b.n	a4a <RingBuffer_PopMult+0x2a>
	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
 a48:	1c06      	adds	r6, r0, #0
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
	cnt2 -= cnt1;
 a4a:	1b80      	subs	r0, r0, r6

	cnt1 = MIN(cnt1, num);
 a4c:	1e15      	subs	r5, r2, #0
 a4e:	42b5      	cmp	r5, r6
 a50:	dd00      	ble.n	a54 <RingBuffer_PopMult+0x34>
 a52:	1c35      	adds	r5, r6, #0
	num -= cnt1;
 a54:	1b56      	subs	r6, r2, r5

	cnt2 = MIN(cnt2, num);
 a56:	4286      	cmp	r6, r0
 a58:	dd00      	ble.n	a5c <RingBuffer_PopMult+0x3c>
 a5a:	1c06      	adds	r6, r0, #0
	num -= cnt2;

	/* Write segment 1 */
	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
 a5c:	68a2      	ldr	r2, [r4, #8]
 a5e:	4353      	muls	r3, r2
 a60:	18c9      	adds	r1, r1, r3
	memcpy(data, ptr, cnt1 * RingBuff->itemSz);
 a62:	436a      	muls	r2, r5
 a64:	1c38      	adds	r0, r7, #0
 a66:	f000 f8b7 	bl	bd8 <memcpy>
	RingBuff->tail += cnt1;
 a6a:	6922      	ldr	r2, [r4, #16]
 a6c:	18ab      	adds	r3, r5, r2
 a6e:	6123      	str	r3, [r4, #16]

	/* Write segment 2 */
	ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
 a70:	6861      	ldr	r1, [r4, #4]
 a72:	3901      	subs	r1, #1
 a74:	400b      	ands	r3, r1
 a76:	68a2      	ldr	r2, [r4, #8]
 a78:	1c11      	adds	r1, r2, #0
 a7a:	4359      	muls	r1, r3
 a7c:	6823      	ldr	r3, [r4, #0]
 a7e:	1859      	adds	r1, r3, r1
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
 a80:	1c10      	adds	r0, r2, #0
 a82:	4368      	muls	r0, r5
 a84:	1838      	adds	r0, r7, r0
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
 a86:	4372      	muls	r2, r6
 a88:	f000 f8a6 	bl	bd8 <memcpy>
	RingBuff->tail += cnt2;
 a8c:	6922      	ldr	r2, [r4, #16]
 a8e:	1993      	adds	r3, r2, r6
 a90:	6123      	str	r3, [r4, #16]

	return cnt1 + cnt2;
 a92:	19a8      	adds	r0, r5, r6
 a94:	e000      	b.n	a98 <RingBuffer_PopMult+0x78>
	uint8_t *ptr = RingBuff->data;
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;
 a96:	2000      	movs	r0, #0
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
	RingBuff->tail += cnt2;

	return cnt1 + cnt2;
}
 a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 a9a:	46c0      	nop			; (mov r8, r8)

00000a9c <Chip_SPI_CalClkRateDivider>:
 * Public functions
 ****************************************************************************/

/* Calculate the Clock Rate Divider for SPI Peripheral */
uint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
{
 a9c:	b510      	push	{r4, lr}
 a9e:	1c0c      	adds	r4, r1, #0
	uint32_t SPIClk;
	uint32_t DivVal = 1;

	/* Get SPI clock rate */
	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
 aa0:	f7ff ff92 	bl	9c8 <Chip_Clock_GetSystemClockRate>

	DivVal = SPIClk / bitRate;
 aa4:	1c21      	adds	r1, r4, #0
 aa6:	f000 f8a2 	bl	bee <__aeabi_uidiv>

	return DivVal;
}
 aaa:	bd10      	pop	{r4, pc}

00000aac <Chip_SPI_Int_Cmd>:
}

/* Disable/Enable Interrupt */
void Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
{
	if (NewState ==  ENABLE) {
 aac:	2a01      	cmp	r2, #1
 aae:	d103      	bne.n	ab8 <Chip_SPI_Int_Cmd+0xc>
		pSPI->INTENSET |= IntMask;
 ab0:	68c3      	ldr	r3, [r0, #12]
 ab2:	4319      	orrs	r1, r3
 ab4:	60c1      	str	r1, [r0, #12]
 ab6:	e002      	b.n	abe <Chip_SPI_Int_Cmd+0x12>
	}
	else {
		pSPI->INTENCLR |= IntMask;
 ab8:	6903      	ldr	r3, [r0, #16]
 aba:	4319      	orrs	r1, r3
 abc:	6101      	str	r1, [r0, #16]
	}
}
 abe:	4770      	bx	lr

00000ac0 <Chip_SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 ac0:	b508      	push	{r3, lr}
#if defined (USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 ac2:	2002      	movs	r0, #2
 ac4:	f000 f874 	bl	bb0 <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 ac8:	2000      	movs	r0, #0
 aca:	f7ff ff0b 	bl	8e4 <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~(0x3));
 ace:	4b10      	ldr	r3, [pc, #64]	; (b10 <Chip_SystemInit+0x50>)
 ad0:	691a      	ldr	r2, [r3, #16]
 ad2:	2103      	movs	r1, #3
 ad4:	438a      	bics	r2, r1

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 ad6:	2101      	movs	r1, #1
 ad8:	430a      	orrs	r2, r1
 ada:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 adc:	2080      	movs	r0, #128	; 0x80
 ade:	f000 f855 	bl	b8c <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 ae2:	2241      	movs	r2, #65	; 0x41
 ae4:	4b0b      	ldr	r3, [pc, #44]	; (b14 <Chip_SystemInit+0x54>)
 ae6:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 ae8:	2080      	movs	r0, #128	; 0x80
 aea:	f000 f861 	bl	bb0 <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 aee:	4909      	ldr	r1, [pc, #36]	; (b14 <Chip_SystemInit+0x54>)
 af0:	2201      	movs	r2, #1
 af2:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 af4:	421a      	tst	r2, r3
 af6:	d0fc      	beq.n	af2 <Chip_SystemInit+0x32>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 af8:	2201      	movs	r2, #1
 afa:	4b06      	ldr	r3, [pc, #24]	; (b14 <Chip_SystemInit+0x54>)
 afc:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 afe:	2003      	movs	r0, #3
 b00:	f7ff fefa 	bl	8f8 <Chip_Clock_SetMainClockSource>
#endif

	/* Select the CLKOUT clocking source */
	Chip_Clock_SetCLKOUTSource(SYSCTL_CLKOUTSRC_MAINSYSCLK, 1);
 b04:	2003      	movs	r0, #3
 b06:	2101      	movs	r1, #1
 b08:	f7ff ff00 	bl	90c <Chip_Clock_SetCLKOUTSource>
}
 b0c:	bd08      	pop	{r3, pc}
 b0e:	46c0      	nop			; (mov r8, r8)
 b10:	40040000 	.word	0x40040000
 b14:	40048000 	.word	0x40048000

00000b18 <Chip_UART_SetBaud>:
	return readBytes;
}

/* Set baud rate for UART */
void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
 b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b1a:	1c07      	adds	r7, r0, #0
 b1c:	1c0e      	adds	r6, r1, #0
	uint32_t err, uart_fra_multiplier, baudRateGenerator;
	uint32_t systemCoreClock = Chip_Clock_GetMainClockRate();
 b1e:	f7ff ff33 	bl	988 <Chip_Clock_GetMainClockRate>
 b22:	1c05      	adds	r5, r0, #0

	/* Calculate baudrate generator value */
	baudRateGenerator = systemCoreClock / (16 * baudrate);
 b24:	0131      	lsls	r1, r6, #4
 b26:	f000 f862 	bl	bee <__aeabi_uidiv>
 b2a:	1c04      	adds	r4, r0, #0
	err = systemCoreClock - baudRateGenerator * 16 * baudrate;
 b2c:	4346      	muls	r6, r0
 b2e:	0131      	lsls	r1, r6, #4
 b30:	1a6d      	subs	r5, r5, r1
	uart_fra_multiplier = (err * 0xFF) / (baudRateGenerator * 16 * baudrate);
 b32:	0228      	lsls	r0, r5, #8
 b34:	1b40      	subs	r0, r0, r5
 b36:	f000 f85a 	bl	bee <__aeabi_uidiv>
	pUART->BRG = baudRateGenerator - 1;	/* baud rate */
 b3a:	3c01      	subs	r4, #1
 b3c:	623c      	str	r4, [r7, #32]
 * @param   div  :  Fractional Generator Divider value, should be 0xFF
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
{
	LPC_SYSCTL->UARTFRGDIV = (uint32_t) div;
 b3e:	4b04      	ldr	r3, [pc, #16]	; (b50 <Chip_UART_SetBaud+0x38>)
 b40:	22ff      	movs	r2, #255	; 0xff
 b42:	21f0      	movs	r1, #240	; 0xf0
 b44:	505a      	str	r2, [r3, r1]
 * @param   mult  :  An 8-bit value (0-255) U_PCLK = UARTCLKDIV/(1 + MULT/256)
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGMultiplier(uint8_t mult)
{
	LPC_SYSCTL->UARTFRGMULT = (uint32_t) mult;
 b46:	4002      	ands	r2, r0
 b48:	21f4      	movs	r1, #244	; 0xf4
 b4a:	505a      	str	r2, [r3, r1]
	Chip_SYSCTL_SetUSARTFRGDivider(0xFF);	/* value 0xFF is always used */
	Chip_SYSCTL_SetUSARTFRGMultiplier(uart_fra_multiplier);
}
 b4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 b4e:	46c0      	nop			; (mov r8, r8)
 b50:	40048000 	.word	0x40048000

00000b54 <Chip_UART_RXIntHandlerRB>:

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
 b54:	b5f0      	push	{r4, r5, r6, r7, lr}
 b56:	b083      	sub	sp, #12
 b58:	1c04      	adds	r4, r0, #0
 b5a:	1c0f      	adds	r7, r1, #0
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 b5c:	2601      	movs	r6, #1
		uint8_t ch = Chip_UART_ReadByte(pUART);
 b5e:	466d      	mov	r5, sp
 b60:	3507      	adds	r5, #7

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 b62:	e005      	b.n	b70 <Chip_UART_RXIntHandlerRB+0x1c>
 *			FIFO status should be read first prior to using this function
 */
STATIC INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
{
	/* Strip off undefined reserved bits, keep 9 lower bits */
	return (uint32_t) (pUART->RXDATA & 0x000001FF);
 b64:	6963      	ldr	r3, [r4, #20]
		uint8_t ch = Chip_UART_ReadByte(pUART);
 b66:	702b      	strb	r3, [r5, #0]
		RingBuffer_Insert(pRB, &ch);
 b68:	1c38      	adds	r0, r7, #0
 b6a:	1c29      	adds	r1, r5, #0
 b6c:	f7ff ff3e 	bl	9ec <RingBuffer_Insert>
 *			with one or more UART_STAT_* definitions to determine
 *			statuses.
 */
STATIC INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
{
	return pUART->STAT;
 b70:	68a3      	ldr	r3, [r4, #8]

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 b72:	421e      	tst	r6, r3
 b74:	d1f6      	bne.n	b64 <Chip_UART_RXIntHandlerRB+0x10>
		uint8_t ch = Chip_UART_ReadByte(pUART);
		RingBuffer_Insert(pRB, &ch);
	}
}
 b76:	b003      	add	sp, #12
 b78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 b7a:	46c0      	nop			; (mov r8, r8)

00000b7c <Chip_UART_ReadRB>:
	return ret;
}

/* Copy data from a receive ring buffer */
int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
{
 b7c:	b508      	push	{r3, lr}
	(void) pUART;

	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
 b7e:	1c08      	adds	r0, r1, #0
 b80:	1c11      	adds	r1, r2, #0
 b82:	1c1a      	adds	r2, r3, #0
 b84:	f7ff ff4c 	bl	a20 <RingBuffer_PopMult>
}
 b88:	bd08      	pop	{r3, pc}
 b8a:	46c0      	nop			; (mov r8, r8)

00000b8c <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 b8c:	4a05      	ldr	r2, [pc, #20]	; (ba4 <Chip_SYSCTL_PowerDown+0x18>)
 b8e:	238e      	movs	r3, #142	; 0x8e
 b90:	009b      	lsls	r3, r3, #2
 b92:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 b94:	4308      	orrs	r0, r1
 b96:	4904      	ldr	r1, [pc, #16]	; (ba8 <Chip_SYSCTL_PowerDown+0x1c>)
 b98:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 b9a:	4904      	ldr	r1, [pc, #16]	; (bac <Chip_SYSCTL_PowerDown+0x20>)
 b9c:	4308      	orrs	r0, r1
 b9e:	50d0      	str	r0, [r2, r3]
}
 ba0:	4770      	bx	lr
 ba2:	46c0      	nop			; (mov r8, r8)
 ba4:	40048000 	.word	0x40048000
 ba8:	000080ef 	.word	0x000080ef
 bac:	00006d10 	.word	0x00006d10

00000bb0 <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 bb0:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 bb2:	4a06      	ldr	r2, [pc, #24]	; (bcc <Chip_SYSCTL_PowerUp+0x1c>)
 bb4:	238e      	movs	r3, #142	; 0x8e
 bb6:	009b      	lsls	r3, r3, #2
 bb8:	58d4      	ldr	r4, [r2, r3]
 bba:	4905      	ldr	r1, [pc, #20]	; (bd0 <Chip_SYSCTL_PowerUp+0x20>)
 bbc:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 bbe:	4001      	ands	r1, r0
 bc0:	438c      	bics	r4, r1
 bc2:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 bc4:	4803      	ldr	r0, [pc, #12]	; (bd4 <Chip_SYSCTL_PowerUp+0x24>)
 bc6:	4301      	orrs	r1, r0
 bc8:	50d1      	str	r1, [r2, r3]
}
 bca:	bd10      	pop	{r4, pc}
 bcc:	40048000 	.word	0x40048000
 bd0:	000080ef 	.word	0x000080ef
 bd4:	00006d10 	.word	0x00006d10

00000bd8 <memcpy>:
 bd8:	b508      	push	{r3, lr}
 bda:	f000 f8fc 	bl	dd6 <__aeabi_memcpy>
 bde:	bd08      	pop	{r3, pc}

00000be0 <__weak_main>:
 be0:	b508      	push	{r3, lr}
 be2:	f7ff fb8d 	bl	300 <main>
 be6:	bd08      	pop	{r3, pc}

00000be8 <__aeabi_idiv>:
 be8:	0003      	movs	r3, r0
 bea:	430b      	orrs	r3, r1
 bec:	d421      	bmi.n	c32 <idiv_negative>

00000bee <__aeabi_uidiv>:
 bee:	2900      	cmp	r1, #0
 bf0:	d031      	beq.n	c56 <idiv_divzero>
 bf2:	2201      	movs	r2, #1
 bf4:	07d2      	lsls	r2, r2, #31
 bf6:	0903      	lsrs	r3, r0, #4
 bf8:	e001      	b.n	bfe <div_search4a>

00000bfa <div_search4>:
 bfa:	0109      	lsls	r1, r1, #4
 bfc:	0912      	lsrs	r2, r2, #4

00000bfe <div_search4a>:
 bfe:	4299      	cmp	r1, r3
 c00:	d9fb      	bls.n	bfa <div_search4>
 c02:	0843      	lsrs	r3, r0, #1
 c04:	e001      	b.n	c0a <div_search1a>

00000c06 <div_search1>:
 c06:	0049      	lsls	r1, r1, #1
 c08:	0852      	lsrs	r2, r2, #1

00000c0a <div_search1a>:
 c0a:	4299      	cmp	r1, r3
 c0c:	d9fb      	bls.n	c06 <div_search1>
 c0e:	e000      	b.n	c12 <div_loop1a>

00000c10 <div_loop1>:
 c10:	0849      	lsrs	r1, r1, #1

00000c12 <div_loop1a>:
 c12:	1a40      	subs	r0, r0, r1
 c14:	d307      	bcc.n	c26 <div1>

00000c16 <div2>:
 c16:	4152      	adcs	r2, r2
 c18:	d3fa      	bcc.n	c10 <div_loop1>
 c1a:	4601      	mov	r1, r0
 c1c:	4610      	mov	r0, r2
 c1e:	4770      	bx	lr

00000c20 <div_loop2>:
 c20:	0849      	lsrs	r1, r1, #1
 c22:	1840      	adds	r0, r0, r1
 c24:	d2f7      	bcs.n	c16 <div2>

00000c26 <div1>:
 c26:	1892      	adds	r2, r2, r2
 c28:	d3fa      	bcc.n	c20 <div_loop2>
 c2a:	1840      	adds	r0, r0, r1
 c2c:	4601      	mov	r1, r0
 c2e:	4610      	mov	r0, r2
 c30:	4770      	bx	lr

00000c32 <idiv_negative>:
 c32:	0fcb      	lsrs	r3, r1, #31
 c34:	d000      	beq.n	c38 <idiv_neg1>
 c36:	4249      	negs	r1, r1

00000c38 <idiv_neg1>:
 c38:	1002      	asrs	r2, r0, #32
 c3a:	d500      	bpl.n	c3e <idiv_neg2>
 c3c:	4240      	negs	r0, r0

00000c3e <idiv_neg2>:
 c3e:	4053      	eors	r3, r2
 c40:	b508      	push	{r3, lr}
 c42:	f7ff ffd4 	bl	bee <__aeabi_uidiv>
 c46:	bc0c      	pop	{r2, r3}

00000c48 <idiv_sign>:
 c48:	1052      	asrs	r2, r2, #1
 c4a:	d300      	bcc.n	c4e <idiv_sign1>
 c4c:	4240      	negs	r0, r0

00000c4e <idiv_sign1>:
 c4e:	2a00      	cmp	r2, #0
 c50:	d500      	bpl.n	c54 <idiv_ret>
 c52:	4249      	negs	r1, r1

00000c54 <idiv_ret>:
 c54:	4718      	bx	r3

00000c56 <idiv_divzero>:
 c56:	46f4      	mov	ip, lr
 c58:	2000      	movs	r0, #0
 c5a:	f000 f801 	bl	c60 <__aeabi_idiv0>
 c5e:	4760      	bx	ip

00000c60 <__aeabi_idiv0>:
 c60:	4770      	bx	lr
	...

00000c64 <__aeabi_fdiv>:
 c64:	b570      	push	{r4, r5, r6, lr}
 c66:	0dc2      	lsrs	r2, r0, #23
 c68:	24ff      	movs	r4, #255	; 0xff
 c6a:	4022      	ands	r2, r4
 c6c:	d04b      	beq.n	d06 <__aeabi_fdiv+0xa2>
 c6e:	42a2      	cmp	r2, r4
 c70:	d049      	beq.n	d06 <__aeabi_fdiv+0xa2>
 c72:	0dcb      	lsrs	r3, r1, #23
 c74:	4023      	ands	r3, r4
 c76:	d046      	beq.n	d06 <__aeabi_fdiv+0xa2>
 c78:	42a3      	cmp	r3, r4
 c7a:	d044      	beq.n	d06 <__aeabi_fdiv+0xa2>
 c7c:	1c0e      	adds	r6, r1, #0
 c7e:	2580      	movs	r5, #128	; 0x80
 c80:	1ad4      	subs	r4, r2, r3
 c82:	062d      	lsls	r5, r5, #24
 c84:	020b      	lsls	r3, r1, #8
 c86:	4046      	eors	r6, r0
 c88:	0200      	lsls	r0, r0, #8
 c8a:	4328      	orrs	r0, r5
 c8c:	431d      	orrs	r5, r3
 c8e:	086b      	lsrs	r3, r5, #1
 c90:	3b01      	subs	r3, #1
 c92:	0842      	lsrs	r2, r0, #1
 c94:	429a      	cmp	r2, r3
 c96:	da02      	bge.n	c9e <__aeabi_fdiv+0x3a>
 c98:	1c21      	adds	r1, r4, #0
 c9a:	317d      	adds	r1, #125	; 0x7d
 c9c:	e002      	b.n	ca4 <__aeabi_fdiv+0x40>
 c9e:	1c21      	adds	r1, r4, #0
 ca0:	1052      	asrs	r2, r2, #1
 ca2:	317e      	adds	r1, #126	; 0x7e
 ca4:	0ff0      	lsrs	r0, r6, #31
 ca6:	01c0      	lsls	r0, r0, #7
 ca8:	0052      	lsls	r2, r2, #1
 caa:	1ad4      	subs	r4, r2, r3
 cac:	d400      	bmi.n	cb0 <__aeabi_fdiv+0x4c>
 cae:	1c22      	adds	r2, r4, #0
 cb0:	0052      	lsls	r2, r2, #1
 cb2:	1ad4      	subs	r4, r2, r3
 cb4:	d400      	bmi.n	cb8 <__aeabi_fdiv+0x54>
 cb6:	1c22      	adds	r2, r4, #0
 cb8:	0052      	lsls	r2, r2, #1
 cba:	1ad4      	subs	r4, r2, r3
 cbc:	d400      	bmi.n	cc0 <__aeabi_fdiv+0x5c>
 cbe:	1c22      	adds	r2, r4, #0
 cc0:	0052      	lsls	r2, r2, #1
 cc2:	1ad4      	subs	r4, r2, r3
 cc4:	d400      	bmi.n	cc8 <__aeabi_fdiv+0x64>
 cc6:	1c22      	adds	r2, r4, #0
 cc8:	0052      	lsls	r2, r2, #1
 cca:	1ad4      	subs	r4, r2, r3
 ccc:	d400      	bmi.n	cd0 <__aeabi_fdiv+0x6c>
 cce:	1c22      	adds	r2, r4, #0
 cd0:	0052      	lsls	r2, r2, #1
 cd2:	1ad4      	subs	r4, r2, r3
 cd4:	d400      	bmi.n	cd8 <__aeabi_fdiv+0x74>
 cd6:	1c22      	adds	r2, r4, #0
 cd8:	0694      	lsls	r4, r2, #26
 cda:	4320      	orrs	r0, r4
 cdc:	243f      	movs	r4, #63	; 0x3f
 cde:	43a2      	bics	r2, r4
 ce0:	241a      	movs	r4, #26
 ce2:	41e0      	rors	r0, r4
 ce4:	0204      	lsls	r4, r0, #8
 ce6:	d5df      	bpl.n	ca8 <__aeabi_fdiv+0x44>
 ce8:	0052      	lsls	r2, r2, #1
 cea:	1ad3      	subs	r3, r2, r3
 cec:	43db      	mvns	r3, r3
 cee:	0fdb      	lsrs	r3, r3, #31
 cf0:	18c0      	adds	r0, r0, r3
 cf2:	29fd      	cmp	r1, #253	; 0xfd
 cf4:	d802      	bhi.n	cfc <__aeabi_fdiv+0x98>
 cf6:	05c9      	lsls	r1, r1, #23
 cf8:	1840      	adds	r0, r0, r1
 cfa:	e01f      	b.n	d3c <__aeabi_fdiv+0xd8>
 cfc:	0fc0      	lsrs	r0, r0, #31
 cfe:	07c0      	lsls	r0, r0, #31
 d00:	2900      	cmp	r1, #0
 d02:	da14      	bge.n	d2e <__aeabi_fdiv+0xca>
 d04:	e01a      	b.n	d3c <__aeabi_fdiv+0xd8>
 d06:	25ff      	movs	r5, #255	; 0xff
 d08:	0044      	lsls	r4, r0, #1
 d0a:	062d      	lsls	r5, r5, #24
 d0c:	42ac      	cmp	r4, r5
 d0e:	d814      	bhi.n	d3a <__aeabi_fdiv+0xd6>
 d10:	004a      	lsls	r2, r1, #1
 d12:	42aa      	cmp	r2, r5
 d14:	d811      	bhi.n	d3a <__aeabi_fdiv+0xd6>
 d16:	1c0b      	adds	r3, r1, #0
 d18:	4303      	orrs	r3, r0
 d1a:	005b      	lsls	r3, r3, #1
 d1c:	0e1b      	lsrs	r3, r3, #24
 d1e:	d00c      	beq.n	d3a <__aeabi_fdiv+0xd6>
 d20:	4048      	eors	r0, r1
 d22:	0fc0      	lsrs	r0, r0, #31
 d24:	07c0      	lsls	r0, r0, #31
 d26:	0e23      	lsrs	r3, r4, #24
 d28:	d008      	beq.n	d3c <__aeabi_fdiv+0xd8>
 d2a:	42aa      	cmp	r2, r5
 d2c:	d003      	beq.n	d36 <__aeabi_fdiv+0xd2>
 d2e:	23ff      	movs	r3, #255	; 0xff
 d30:	05db      	lsls	r3, r3, #23
 d32:	4318      	orrs	r0, r3
 d34:	e002      	b.n	d3c <__aeabi_fdiv+0xd8>
 d36:	4294      	cmp	r4, r2
 d38:	d100      	bne.n	d3c <__aeabi_fdiv+0xd8>
 d3a:	4801      	ldr	r0, [pc, #4]	; (d40 <__aeabi_fdiv+0xdc>)
 d3c:	bd70      	pop	{r4, r5, r6, pc}
 d3e:	46c0      	nop			; (mov r8, r8)
 d40:	7fc00000 	.word	0x7fc00000

00000d44 <__aeabi_f2uiz>:
 d44:	2280      	movs	r2, #128	; 0x80
 d46:	0dc3      	lsrs	r3, r0, #23
 d48:	0201      	lsls	r1, r0, #8
 d4a:	0612      	lsls	r2, r2, #24
 d4c:	209e      	movs	r0, #158	; 0x9e
 d4e:	4311      	orrs	r1, r2
 d50:	1ac0      	subs	r0, r0, r3
 d52:	d402      	bmi.n	d5a <__aeabi_f2uiz+0x16>
 d54:	40c1      	lsrs	r1, r0
 d56:	1c08      	adds	r0, r1, #0
 d58:	e006      	b.n	d68 <__aeabi_f2uiz+0x24>
 d5a:	2bfe      	cmp	r3, #254	; 0xfe
 d5c:	d902      	bls.n	d64 <__aeabi_f2uiz+0x20>
 d5e:	2000      	movs	r0, #0
 d60:	4291      	cmp	r1, r2
 d62:	d101      	bne.n	d68 <__aeabi_f2uiz+0x24>
 d64:	0a18      	lsrs	r0, r3, #8
 d66:	3801      	subs	r0, #1
 d68:	4770      	bx	lr

00000d6a <__bhs_ui2f>:
 d6a:	2800      	cmp	r0, #0
 d6c:	d02b      	beq.n	dc6 <__bhs_ui2f+0x5c>
 d6e:	0c03      	lsrs	r3, r0, #16
 d70:	d101      	bne.n	d76 <__bhs_ui2f+0xc>
 d72:	0400      	lsls	r0, r0, #16
 d74:	e002      	b.n	d7c <__bhs_ui2f+0x12>
 d76:	2380      	movs	r3, #128	; 0x80
 d78:	051b      	lsls	r3, r3, #20
 d7a:	18c9      	adds	r1, r1, r3
 d7c:	0e03      	lsrs	r3, r0, #24
 d7e:	d101      	bne.n	d84 <__bhs_ui2f+0x1a>
 d80:	0200      	lsls	r0, r0, #8
 d82:	e002      	b.n	d8a <__bhs_ui2f+0x20>
 d84:	2380      	movs	r3, #128	; 0x80
 d86:	04db      	lsls	r3, r3, #19
 d88:	18c9      	adds	r1, r1, r3
 d8a:	0f03      	lsrs	r3, r0, #28
 d8c:	d101      	bne.n	d92 <__bhs_ui2f+0x28>
 d8e:	0100      	lsls	r0, r0, #4
 d90:	e002      	b.n	d98 <__bhs_ui2f+0x2e>
 d92:	2380      	movs	r3, #128	; 0x80
 d94:	049b      	lsls	r3, r3, #18
 d96:	18c9      	adds	r1, r1, r3
 d98:	0f83      	lsrs	r3, r0, #30
 d9a:	d101      	bne.n	da0 <__bhs_ui2f+0x36>
 d9c:	0080      	lsls	r0, r0, #2
 d9e:	e002      	b.n	da6 <__bhs_ui2f+0x3c>
 da0:	2380      	movs	r3, #128	; 0x80
 da2:	045b      	lsls	r3, r3, #17
 da4:	18c9      	adds	r1, r1, r3
 da6:	2800      	cmp	r0, #0
 da8:	db01      	blt.n	dae <__bhs_ui2f+0x44>
 daa:	0040      	lsls	r0, r0, #1
 dac:	e002      	b.n	db4 <__bhs_ui2f+0x4a>
 dae:	2380      	movs	r3, #128	; 0x80
 db0:	041b      	lsls	r3, r3, #16
 db2:	18c9      	adds	r1, r1, r3
 db4:	3080      	adds	r0, #128	; 0x80
 db6:	1203      	asrs	r3, r0, #8
 db8:	1859      	adds	r1, r3, r1
 dba:	0600      	lsls	r0, r0, #24
 dbc:	d101      	bne.n	dc2 <__bhs_ui2f+0x58>
 dbe:	2301      	movs	r3, #1
 dc0:	4399      	bics	r1, r3
 dc2:	1c08      	adds	r0, r1, #0
 dc4:	e000      	b.n	dc8 <__bhs_ui2f+0x5e>
 dc6:	2000      	movs	r0, #0
 dc8:	4770      	bx	lr

00000dca <__aeabi_ui2f>:
 dca:	b508      	push	{r3, lr}
 dcc:	2180      	movs	r1, #128	; 0x80
 dce:	05c9      	lsls	r1, r1, #23
 dd0:	f7ff ffcb 	bl	d6a <__bhs_ui2f>
 dd4:	bd08      	pop	{r3, pc}

00000dd6 <__aeabi_memcpy>:
 dd6:	4684      	mov	ip, r0
 dd8:	0783      	lsls	r3, r0, #30
 dda:	d108      	bne.n	dee <copy1_start>
 ddc:	078b      	lsls	r3, r1, #30
 dde:	d106      	bne.n	dee <copy1_start>
 de0:	1f13      	subs	r3, r2, #4
 de2:	d304      	bcc.n	dee <copy1_start>

00000de4 <copy4>:
 de4:	c904      	ldmia	r1!, {r2}
 de6:	c004      	stmia	r0!, {r2}
 de8:	3b04      	subs	r3, #4
 dea:	d2fb      	bcs.n	de4 <copy4>
 dec:	1d1a      	adds	r2, r3, #4

00000dee <copy1_start>:
 dee:	4252      	negs	r2, r2
 df0:	d005      	beq.n	dfe <copy1_ret>
 df2:	1a89      	subs	r1, r1, r2
 df4:	1a80      	subs	r0, r0, r2

00000df6 <copy1>:
 df6:	5c8b      	ldrb	r3, [r1, r2]
 df8:	5483      	strb	r3, [r0, r2]
 dfa:	3201      	adds	r2, #1
 dfc:	d1fb      	bne.n	df6 <copy1>

00000dfe <copy1_ret>:
 dfe:	4660      	mov	r0, ip
 e00:	4770      	bx	lr
 e02:	0000      	movs	r0, r0
 e04:	00000000 	.word	0x00000000
 e08:	7fffffff 	.word	0x7fffffff
 e0c:	00000000 	.word	0x00000000
 e10:	0000012c 	.word	0x0000012c
 e14:	00002710 	.word	0x00002710
 e18:	00000001 	.word	0x00000001
 e1c:	00002710 	.word	0x00002710
 e20:	00000000 	.word	0x00000000
 e24:	00000001 	.word	0x00000001

00000e28 <OscRateIn>:
 e28:	00b71b00                                ....

00000e2c <ExtRateIn>:
 e2c:	00000000                                ....

00000e30 <MIDIto30MhzReload>:
 e30:	0d350dfe 0bc40c77 0a7c0b1b 095709e5     ..5.w.....|...W.
 e40:	085208d0 076907da 069a06ff 05e2063b     ..R...i.....;...
 e50:	053d058d 04ab04f2 04280468 03b403ed     ..=.....h.(.....
 e60:	034d037f 02f0031d 029e02c6 02550278     ..M.........x.U.
 e70:	02140233 01da01f6 01a601bf 0178018e     3.............x.
 e80:	014f0163 012a013c 01090119 00ec00fa     c.O.<.*.........
 e90:	00d200df 00bb00c7 00a700b1 0094009d     ................
 ea0:	0084008c 0076007d 0069006f 005d0063     ....}.v.o.i.c.].
 eb0:	00530058 004a004e                       X.S.N.J.

00000eb8 <wdtOSCRate>:
 eb8:	00000000 000927c0 00100590 00155cc0     .....'.......\..
 ec8:	001ab3f0 00200b20 00249f00 002932e0     .... . ...$..2).
 ed8:	002dc6c0 00319750 003567e0 00393870     ..-.P.1..g5.p89.
 ee8:	003d0900 00401640 00432380 004630c0     ..=.@.@..#C..0F.
