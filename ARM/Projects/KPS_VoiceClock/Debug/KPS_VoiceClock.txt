
KPS_VoiceClock.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 04 00 10 03 01 00 00 d5 00 00 00 d7 00 00 00     ................
	...
  2c:	d9 00 00 00 00 00 00 00 00 00 00 00 db 00 00 00     ................
  3c:	dd 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  4c:	79 07 00 00 df 00 00 00 df 00 00 00 00 00 00 00     y...............
  5c:	00 00 00 00 df 00 00 00 cd 05 00 00 df 00 00 00     ................
  6c:	df 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  7c:	df 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................
  b0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000f44 	.word	0x00000f44
  c4:	10000100 	.word	0x10000100
  c8:	00000018 	.word	0x00000018

000000cc <__bss_section_table>:
  cc:	10000118 	.word	0x10000118
  d0:	0000003c 	.word	0x0000003c

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>

000000d6 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d6:	e7fe      	b.n	d6 <HardFault_Handler>

000000d8 <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  d8:	e7fe      	b.n	d8 <SVC_Handler>

000000da <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  da:	e7fe      	b.n	da <PendSV_Handler>

000000dc <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  dc:	e7fe      	b.n	dc <SysTick_Handler>

000000de <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  de:	e7fe      	b.n	de <BOD_IRQHandler>

000000e0 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
  e0:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  e2:	2300      	movs	r3, #0
  e4:	4293      	cmp	r3, r2
  e6:	d203      	bcs.n	f0 <data_init+0x10>
        *pulDest++ = *pulSrc++;
  e8:	581c      	ldr	r4, [r3, r0]
  ea:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  ec:	3304      	adds	r3, #4
  ee:	e7f9      	b.n	e4 <data_init+0x4>
        *pulDest++ = *pulSrc++;
}
  f0:	bd10      	pop	{r4, pc}

000000f2 <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  f2:	2300      	movs	r3, #0
  f4:	428b      	cmp	r3, r1
  f6:	d203      	bcs.n	100 <bss_init+0xe>
        *pulDest++ = 0;
  f8:	2200      	movs	r2, #0
  fa:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  fc:	3304      	adds	r3, #4
  fe:	e7f9      	b.n	f4 <bss_init+0x2>
        *pulDest++ = 0;
}
 100:	4770      	bx	lr

00000102 <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
 102:	b510      	push	{r4, lr}
    //
    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;
 104:	4c0c      	ldr	r4, [pc, #48]	; (138 <ResetISR+0x36>)

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 106:	4b0d      	ldr	r3, [pc, #52]	; (13c <ResetISR+0x3a>)
 108:	429c      	cmp	r4, r3
 10a:	d207      	bcs.n	11c <ResetISR+0x1a>
        LoadAddr = *SectionTableAddr++;
 10c:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
 10e:	6861      	ldr	r1, [r4, #4]
 110:	340c      	adds	r4, #12
 112:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
 114:	681a      	ldr	r2, [r3, #0]
 116:	f7ff ffe3 	bl	e0 <data_init>
 11a:	e7f4      	b.n	106 <ResetISR+0x4>
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 11c:	4b08      	ldr	r3, [pc, #32]	; (140 <ResetISR+0x3e>)
 11e:	429c      	cmp	r4, r3
 120:	d205      	bcs.n	12e <ResetISR+0x2c>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
 122:	6820      	ldr	r0, [r4, #0]
 124:	6861      	ldr	r1, [r4, #4]
 126:	f7ff ffe4 	bl	f2 <bss_init>
 12a:	3408      	adds	r4, #8
 12c:	e7f6      	b.n	11c <ResetISR+0x1a>
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 12e:	f000 fa59 	bl	5e4 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 132:	f000 fd8d 	bl	c50 <__weak_main>
 136:	e7fe      	b.n	136 <ResetISR+0x34>
 138:	000000c0 	.word	0x000000c0
 13c:	000000cc 	.word	0x000000cc
 140:	000000d4 	.word	0x000000d4
 144:	ffffffff 	.word	0xffffffff
 148:	ffffffff 	.word	0xffffffff
 14c:	ffffffff 	.word	0xffffffff
 150:	ffffffff 	.word	0xffffffff
 154:	ffffffff 	.word	0xffffffff
 158:	ffffffff 	.word	0xffffffff
 15c:	ffffffff 	.word	0xffffffff
 160:	ffffffff 	.word	0xffffffff
 164:	ffffffff 	.word	0xffffffff
 168:	ffffffff 	.word	0xffffffff
 16c:	ffffffff 	.word	0xffffffff
 170:	ffffffff 	.word	0xffffffff
 174:	ffffffff 	.word	0xffffffff
 178:	ffffffff 	.word	0xffffffff
 17c:	ffffffff 	.word	0xffffffff
 180:	ffffffff 	.word	0xffffffff
 184:	ffffffff 	.word	0xffffffff
 188:	ffffffff 	.word	0xffffffff
 18c:	ffffffff 	.word	0xffffffff
 190:	ffffffff 	.word	0xffffffff
 194:	ffffffff 	.word	0xffffffff
 198:	ffffffff 	.word	0xffffffff
 19c:	ffffffff 	.word	0xffffffff
 1a0:	ffffffff 	.word	0xffffffff
 1a4:	ffffffff 	.word	0xffffffff
 1a8:	ffffffff 	.word	0xffffffff
 1ac:	ffffffff 	.word	0xffffffff
 1b0:	ffffffff 	.word	0xffffffff
 1b4:	ffffffff 	.word	0xffffffff
 1b8:	ffffffff 	.word	0xffffffff
 1bc:	ffffffff 	.word	0xffffffff
 1c0:	ffffffff 	.word	0xffffffff
 1c4:	ffffffff 	.word	0xffffffff
 1c8:	ffffffff 	.word	0xffffffff
 1cc:	ffffffff 	.word	0xffffffff
 1d0:	ffffffff 	.word	0xffffffff
 1d4:	ffffffff 	.word	0xffffffff
 1d8:	ffffffff 	.word	0xffffffff
 1dc:	ffffffff 	.word	0xffffffff
 1e0:	ffffffff 	.word	0xffffffff
 1e4:	ffffffff 	.word	0xffffffff
 1e8:	ffffffff 	.word	0xffffffff
 1ec:	ffffffff 	.word	0xffffffff
 1f0:	ffffffff 	.word	0xffffffff
 1f4:	ffffffff 	.word	0xffffffff
 1f8:	ffffffff 	.word	0xffffffff
 1fc:	ffffffff 	.word	0xffffffff
 200:	ffffffff 	.word	0xffffffff
 204:	ffffffff 	.word	0xffffffff
 208:	ffffffff 	.word	0xffffffff
 20c:	ffffffff 	.word	0xffffffff
 210:	ffffffff 	.word	0xffffffff
 214:	ffffffff 	.word	0xffffffff
 218:	ffffffff 	.word	0xffffffff
 21c:	ffffffff 	.word	0xffffffff
 220:	ffffffff 	.word	0xffffffff
 224:	ffffffff 	.word	0xffffffff
 228:	ffffffff 	.word	0xffffffff
 22c:	ffffffff 	.word	0xffffffff
 230:	ffffffff 	.word	0xffffffff
 234:	ffffffff 	.word	0xffffffff
 238:	ffffffff 	.word	0xffffffff
 23c:	ffffffff 	.word	0xffffffff
 240:	ffffffff 	.word	0xffffffff
 244:	ffffffff 	.word	0xffffffff
 248:	ffffffff 	.word	0xffffffff
 24c:	ffffffff 	.word	0xffffffff
 250:	ffffffff 	.word	0xffffffff
 254:	ffffffff 	.word	0xffffffff
 258:	ffffffff 	.word	0xffffffff
 25c:	ffffffff 	.word	0xffffffff
 260:	ffffffff 	.word	0xffffffff
 264:	ffffffff 	.word	0xffffffff
 268:	ffffffff 	.word	0xffffffff
 26c:	ffffffff 	.word	0xffffffff
 270:	ffffffff 	.word	0xffffffff
 274:	ffffffff 	.word	0xffffffff
 278:	ffffffff 	.word	0xffffffff
 27c:	ffffffff 	.word	0xffffffff
 280:	ffffffff 	.word	0xffffffff
 284:	ffffffff 	.word	0xffffffff
 288:	ffffffff 	.word	0xffffffff
 28c:	ffffffff 	.word	0xffffffff
 290:	ffffffff 	.word	0xffffffff
 294:	ffffffff 	.word	0xffffffff
 298:	ffffffff 	.word	0xffffffff
 29c:	ffffffff 	.word	0xffffffff
 2a0:	ffffffff 	.word	0xffffffff
 2a4:	ffffffff 	.word	0xffffffff
 2a8:	ffffffff 	.word	0xffffffff
 2ac:	ffffffff 	.word	0xffffffff
 2b0:	ffffffff 	.word	0xffffffff
 2b4:	ffffffff 	.word	0xffffffff
 2b8:	ffffffff 	.word	0xffffffff
 2bc:	ffffffff 	.word	0xffffffff
 2c0:	ffffffff 	.word	0xffffffff
 2c4:	ffffffff 	.word	0xffffffff
 2c8:	ffffffff 	.word	0xffffffff
 2cc:	ffffffff 	.word	0xffffffff
 2d0:	ffffffff 	.word	0xffffffff
 2d4:	ffffffff 	.word	0xffffffff
 2d8:	ffffffff 	.word	0xffffffff
 2dc:	ffffffff 	.word	0xffffffff
 2e0:	ffffffff 	.word	0xffffffff
 2e4:	ffffffff 	.word	0xffffffff
 2e8:	ffffffff 	.word	0xffffffff
 2ec:	ffffffff 	.word	0xffffffff
 2f0:	ffffffff 	.word	0xffffffff
 2f4:	ffffffff 	.word	0xffffffff
 2f8:	ffffffff 	.word	0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffffffff                                ....

00000300 <MIDI_NoteOff>:
	Chip_SCT_EnableEventInt(LPC_SCT, SCT_EVT_0);
	NVIC_EnableIRQ(SCT_IRQn);
}

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
 300:	b513      	push	{r0, r1, r4, lr}
	if (note == activeNote)
 302:	4c09      	ldr	r4, [pc, #36]	; (328 <MIDI_NoteOff+0x28>)
 304:	7823      	ldrb	r3, [r4, #0]
 306:	b25a      	sxtb	r2, r3
 308:	4290      	cmp	r0, r2
 30a:	d10c      	bne.n	326 <MIDI_NoteOff+0x26>
	{
		uint8_t value = 255 - activeNote;
 30c:	466a      	mov	r2, sp
 30e:	3207      	adds	r2, #7
 310:	43db      	mvns	r3, r3
		TLC_SetDACValue(FilterDAC, 1, &value);
 312:	2000      	movs	r0, #0
 314:	2101      	movs	r1, #1

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
	if (note == activeNote)
	{
		uint8_t value = 255 - activeNote;
 316:	7013      	strb	r3, [r2, #0]
		TLC_SetDACValue(FilterDAC, 1, &value);
 318:	f000 fa5a 	bl	7d0 <TLC_SetDACValue>
		// set to Idle
		activeNote = -1;
 31c:	23ff      	movs	r3, #255	; 0xff
 31e:	7023      	strb	r3, [r4, #0]
		EnvPosition = 0;
 320:	4b02      	ldr	r3, [pc, #8]	; (32c <MIDI_NoteOff+0x2c>)
 322:	2200      	movs	r2, #0
 324:	601a      	str	r2, [r3, #0]
	}
}
 326:	bd13      	pop	{r0, r1, r4, pc}
 328:	10000108 	.word	0x10000108
 32c:	10000118 	.word	0x10000118

00000330 <MIDI_NoteOn>:


void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
 330:	4b24      	ldr	r3, [pc, #144]	; (3c4 <MIDI_NoteOn+0x94>)
 * 											FUNCTIONS													*
 *******************************************************************************************************/


void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 332:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Load global variables
	activeNote = num;
 334:	7018      	strb	r0, [r3, #0]
	pluckStrength = vel;
 336:	4b24      	ldr	r3, [pc, #144]	; (3c8 <MIDI_NoteOn+0x98>)
	EnvPosition = 0;
 338:	2600      	movs	r6, #0

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
 33a:	7019      	strb	r1, [r3, #0]
	EnvPosition = 0;
 33c:	4b23      	ldr	r3, [pc, #140]	; (3cc <MIDI_NoteOn+0x9c>)
	remainingNoise = PULSE_LENGTH;
 33e:	2296      	movs	r2, #150	; 0x96
void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
	EnvPosition = 0;
 340:	601e      	str	r6, [r3, #0]
	remainingNoise = PULSE_LENGTH;
 342:	4b23      	ldr	r3, [pc, #140]	; (3d0 <MIDI_NoteOn+0xa0>)
 344:	0052      	lsls	r2, r2, #1
 * 											FUNCTIONS													*
 *******************************************************************************************************/


void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 346:	b085      	sub	sp, #20
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
	EnvPosition = 0;
	remainingNoise = PULSE_LENGTH;
 348:	601a      	str	r2, [r3, #0]

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
 34a:	237f      	movs	r3, #127	; 0x7f
 34c:	1a1b      	subs	r3, r3, r0
 34e:	466c      	mov	r4, sp
 350:	73e3      	strb	r3, [r4, #15]
 352:	340f      	adds	r4, #15
	TLC_SetDACValue(FilterDAC, 1, &value);
 354:	1c22      	adds	r2, r4, #0
 * 											FUNCTIONS													*
 *******************************************************************************************************/


void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 356:	1c05      	adds	r5, r0, #0
	EnvPosition = 0;
	remainingNoise = PULSE_LENGTH;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
 358:	2101      	movs	r1, #1
 35a:	1c30      	adds	r0, r6, #0
 35c:	f000 fa38 	bl	7d0 <TLC_SetDACValue>
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 360:	1c28      	adds	r0, r5, #0
 362:	2143      	movs	r1, #67	; 0x43
 364:	f000 fc7b 	bl	c5e <__aeabi_uidiv>
 368:	b2cf      	uxtb	r7, r1
 36a:	1c38      	adds	r0, r7, #0
 36c:	210c      	movs	r1, #12
 36e:	f000 fc76 	bl	c5e <__aeabi_uidiv>
 372:	2106      	movs	r1, #6
 374:	b2c0      	uxtb	r0, r0
 376:	f000 fc72 	bl	c5e <__aeabi_uidiv>
 37a:	b2c9      	uxtb	r1, r1
 37c:	9101      	str	r1, [sp, #4]
 37e:	1c28      	adds	r0, r5, #0
 380:	210c      	movs	r1, #12
 382:	f000 fc6c 	bl	c5e <__aeabi_uidiv>
 386:	9a01      	ldr	r2, [sp, #4]
 388:	4b12      	ldr	r3, [pc, #72]	; (3d4 <MIDI_NoteOn+0xa4>)
	TLC_SetDACValue(AmpDAC, 0, &value);
 38a:	2001      	movs	r0, #1
	remainingNoise = PULSE_LENGTH;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 38c:	5c9b      	ldrb	r3, [r3, r2]
	TLC_SetDACValue(AmpDAC, 0, &value);
 38e:	1c22      	adds	r2, r4, #0
	remainingNoise = PULSE_LENGTH;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 390:	1859      	adds	r1, r3, r1
 392:	7021      	strb	r1, [r4, #0]
	TLC_SetDACValue(AmpDAC, 0, &value);
 394:	1c31      	adds	r1, r6, #0
 396:	f000 fa1b 	bl	7d0 <TLC_SetDACValue>
	// Knee for PWM adjustment in higher registers
	//value = (num >= 84) ? 15 : 50;
	//setWidth(&Generator1, value);

	// Set frequency generator's frequency.
	setReload(&Generator1, MIDIto30MhzReload[num % 67]);
 39a:	4c0f      	ldr	r4, [pc, #60]	; (3d8 <MIDI_NoteOn+0xa8>)
 39c:	4b0f      	ldr	r3, [pc, #60]	; (3dc <MIDI_NoteOn+0xac>)
 39e:	007f      	lsls	r7, r7, #1
 3a0:	5ef9      	ldrsh	r1, [r7, r3]
 3a2:	1c20      	adds	r0, r4, #0
 3a4:	f000 fa8a 	bl	8bc <setReload>
	updateFreq(&Generator1);
 3a8:	1c20      	adds	r0, r4, #0
 3aa:	f000 fa8f 	bl	8cc <updateFreq>
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVEN |= evt;
 3ae:	4b0c      	ldr	r3, [pc, #48]	; (3e0 <MIDI_NoteOn+0xb0>)
 3b0:	2101      	movs	r1, #1
 3b2:	681a      	ldr	r2, [r3, #0]
 3b4:	430a      	orrs	r2, r1
 3b6:	601a      	str	r2, [r3, #0]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 3b8:	4b0a      	ldr	r3, [pc, #40]	; (3e4 <MIDI_NoteOn+0xb4>)
 3ba:	2280      	movs	r2, #128	; 0x80
 3bc:	0092      	lsls	r2, r2, #2
 3be:	601a      	str	r2, [r3, #0]

	// start the exciter
	Chip_SCT_EnableEventInt(LPC_SCT, SCT_EVT_0);
	NVIC_EnableIRQ(SCT_IRQn);
}
 3c0:	b005      	add	sp, #20
 3c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 3c4:	10000108 	.word	0x10000108
 3c8:	10000121 	.word	0x10000121
 3cc:	10000118 	.word	0x10000118
 3d0:	1000011c 	.word	0x1000011c
 3d4:	10000102 	.word	0x10000102
 3d8:	1000010c 	.word	0x1000010c
 3dc:	00000e72 	.word	0x00000e72
 3e0:	500040f0 	.word	0x500040f0
 3e4:	e000e100 	.word	0xe000e100

000003e8 <LFSR>:
}

uint16_t LFSR()
{
	static uint16_t lfsr = 0xACE1u;
	uint8_t lsb = lfsr & 1;
 3e8:	4b04      	ldr	r3, [pc, #16]	; (3fc <LFSR+0x14>)
 3ea:	8819      	ldrh	r1, [r3, #0]
	lfsr >>= 1;
 3ec:	084a      	lsrs	r2, r1, #1

	if (lsb == 1)
 3ee:	07c8      	lsls	r0, r1, #31
 3f0:	d501      	bpl.n	3f6 <LFSR+0xe>
	{
		/* Only apply toggle mask if output bit is 1. */
		lfsr ^= 0xB400u;
 3f2:	4903      	ldr	r1, [pc, #12]	; (400 <LFSR+0x18>)
 3f4:	404a      	eors	r2, r1
 3f6:	801a      	strh	r2, [r3, #0]
	}
	return lfsr;
 3f8:	8818      	ldrh	r0, [r3, #0]
}
 3fa:	4770      	bx	lr
 3fc:	10000100 	.word	0x10000100
 400:	ffffb400 	.word	0xffffb400

00000404 <GenPluckBow>:

/////// EXCITER TYPES


void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
 404:	b530      	push	{r4, r5, lr}
	if (Position < Envelope->dk || Envelope->sus != 0)
 406:	6843      	ldr	r3, [r0, #4]

/////// EXCITER TYPES


void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
 408:	b085      	sub	sp, #20
	if (Position < Envelope->dk || Envelope->sus != 0)
 40a:	4299      	cmp	r1, r3
 40c:	d302      	bcc.n	414 <GenPluckBow+0x10>
 40e:	6883      	ldr	r3, [r0, #8]
 410:	2b00      	cmp	r3, #0
 412:	d01d      	beq.n	450 <GenPluckBow+0x4c>
	{
		int32_t envVal = GenLinADS(Envelope, Position);
 414:	f000 f8ea 	bl	5ec <GenLinADS>
 418:	1c05      	adds	r5, r0, #0
		int32_t noise = LFSR() & 0x7F;
 41a:	f7ff ffe5 	bl	3e8 <LFSR>
 41e:	247f      	movs	r4, #127	; 0x7f
		//{
		//	noise = (uint8_t) envVal;
		//}

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 420:	4b0c      	ldr	r3, [pc, #48]	; (454 <GenPluckBow+0x50>)
void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
	if (Position < Envelope->dk || Envelope->sus != 0)
	{
		int32_t envVal = GenLinADS(Envelope, Position);
		int32_t noise = LFSR() & 0x7F;
 422:	4020      	ands	r0, r4
		//{
		//	noise = (uint8_t) envVal;
		//}

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 424:	781b      	ldrb	r3, [r3, #0]
 426:	9000      	str	r0, [sp, #0]
 428:	2000      	movs	r0, #0
 42a:	1c21      	adds	r1, r4, #0
 42c:	1c02      	adds	r2, r0, #0
 42e:	f000 fa63 	bl	8f8 <i_lscale>
		noise = i_lscale(0,127, 0, envVal, noise);
 432:	9000      	str	r0, [sp, #0]
 434:	2000      	movs	r0, #0
 436:	1c21      	adds	r1, r4, #0
 438:	1c02      	adds	r2, r0, #0
 43a:	1c2b      	adds	r3, r5, #0
 43c:	f000 fa5c 	bl	8f8 <i_lscale>

		// Set bias to be 1/2 available range
		noise = 127 + noise;
		uint8_t output = noise;
 440:	466a      	mov	r2, sp
		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
		noise = i_lscale(0,127, 0, envVal, noise);

		// Set bias to be 1/2 available range
		noise = 127 + noise;
 442:	1900      	adds	r0, r0, r4
		uint8_t output = noise;
 444:	320f      	adds	r2, #15
 446:	7010      	strb	r0, [r2, #0]
		TLC_SetDACValue(PulseDAC, 1, &output);
 448:	2101      	movs	r1, #1
 44a:	2003      	movs	r0, #3
 44c:	f000 f9c0 	bl	7d0 <TLC_SetDACValue>
	}
}
 450:	b005      	add	sp, #20
 452:	bd30      	pop	{r4, r5, pc}
 454:	10000121 	.word	0x10000121

00000458 <GenPluckBow_NoteOff>:

void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
 458:	b530      	push	{r4, r5, lr}
	if (Position <= RELEASE && Envelope->sus != 0)
 45a:	4b14      	ldr	r3, [pc, #80]	; (4ac <GenPluckBow_NoteOff+0x54>)
		TLC_SetDACValue(PulseDAC, 1, &output);
	}
}

void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
 45c:	b085      	sub	sp, #20
	if (Position <= RELEASE && Envelope->sus != 0)
 45e:	4299      	cmp	r1, r3
 460:	dc22      	bgt.n	4a8 <GenPluckBow_NoteOff+0x50>
 462:	6883      	ldr	r3, [r0, #8]
 464:	2b00      	cmp	r3, #0
 466:	d01f      	beq.n	4a8 <GenPluckBow_NoteOff+0x50>
	{
		int32_t envVal = GenLinRelease(Envelope, Position + Envelope->dk);
 468:	6843      	ldr	r3, [r0, #4]
		int32_t noise = LFSR() & 0x7F;
 46a:	247f      	movs	r4, #127	; 0x7f

void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
	if (Position <= RELEASE && Envelope->sus != 0)
	{
		int32_t envVal = GenLinRelease(Envelope, Position + Envelope->dk);
 46c:	18c9      	adds	r1, r1, r3
 46e:	f000 f8d4 	bl	61a <GenLinRelease>
 472:	1c05      	adds	r5, r0, #0
		int32_t noise = LFSR() & 0x7F;
 474:	f7ff ffb8 	bl	3e8 <LFSR>

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 478:	4b0d      	ldr	r3, [pc, #52]	; (4b0 <GenPluckBow_NoteOff+0x58>)
void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
	if (Position <= RELEASE && Envelope->sus != 0)
	{
		int32_t envVal = GenLinRelease(Envelope, Position + Envelope->dk);
		int32_t noise = LFSR() & 0x7F;
 47a:	4020      	ands	r0, r4

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 47c:	781b      	ldrb	r3, [r3, #0]
 47e:	9000      	str	r0, [sp, #0]
 480:	2000      	movs	r0, #0
 482:	1c21      	adds	r1, r4, #0
 484:	1c02      	adds	r2, r0, #0
 486:	f000 fa37 	bl	8f8 <i_lscale>
		noise = i_lscale(0,127, 0, envVal, noise);
 48a:	9000      	str	r0, [sp, #0]
 48c:	2000      	movs	r0, #0
 48e:	1c21      	adds	r1, r4, #0
 490:	1c02      	adds	r2, r0, #0
 492:	1c2b      	adds	r3, r5, #0
 494:	f000 fa30 	bl	8f8 <i_lscale>

		// Set bias to be 1/2 available range
		noise = 127 + noise;
		uint8_t output = noise;
 498:	466a      	mov	r2, sp
		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
		noise = i_lscale(0,127, 0, envVal, noise);

		// Set bias to be 1/2 available range
		noise = 127 + noise;
 49a:	1900      	adds	r0, r0, r4
		uint8_t output = noise;
 49c:	320f      	adds	r2, #15
 49e:	7010      	strb	r0, [r2, #0]
		TLC_SetDACValue(PulseDAC, 1, &output);
 4a0:	2101      	movs	r1, #1
 4a2:	2003      	movs	r0, #3
 4a4:	f000 f994 	bl	7d0 <TLC_SetDACValue>
	}
}
 4a8:	b005      	add	sp, #20
 4aa:	bd30      	pop	{r4, r5, pc}
 4ac:	00002710 	.word	0x00002710
 4b0:	10000121 	.word	0x10000121

000004b4 <main>:

/********************************************************************************************************
 * 											MAIN														*
 *******************************************************************************************************/
int main(void)
{
 4b4:	b530      	push	{r4, r5, lr}
 4b6:	b087      	sub	sp, #28
	// Standard boot procedure
	CoreClockInit_30Hz();
 4b8:	f000 f8c2 	bl	640 <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 4bc:	4b32      	ldr	r3, [pc, #200]	; (588 <main+0xd4>)
 4be:	2280      	movs	r2, #128	; 0x80
 4c0:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 4c2:	0052      	lsls	r2, r2, #1
 4c4:	430a      	orrs	r2, r1
 4c6:	67da      	str	r2, [r3, #124]	; 0x7c
 4c8:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 4ca:	2280      	movs	r2, #128	; 0x80
 4cc:	01d2      	lsls	r2, r2, #7
 4ce:	430a      	orrs	r2, r1
 4d0:	67da      	str	r2, [r3, #124]	; 0x7c
 4d2:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 4d4:	2280      	movs	r2, #128	; 0x80
 4d6:	0112      	lsls	r2, r2, #4
 4d8:	430a      	orrs	r2, r1
 4da:	67da      	str	r2, [r3, #124]	; 0x7c
 4dc:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 4de:	2180      	movs	r1, #128	; 0x80
 4e0:	430a      	orrs	r2, r1
 4e2:	67da      	str	r2, [r3, #124]	; 0x7c
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 4e4:	4829      	ldr	r0, [pc, #164]	; (58c <main+0xd8>)
 4e6:	4a2a      	ldr	r2, [pc, #168]	; (590 <main+0xdc>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 4e8:	2401      	movs	r4, #1
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 4ea:	6010      	str	r0, [r2, #0]
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 4ec:	4829      	ldr	r0, [pc, #164]	; (594 <main+0xe0>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 4ee:	4264      	negs	r4, r4

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 4f0:	60d0      	str	r0, [r2, #12]
    /* SPI0_MOSI */
    /* SPI0_SSEL */
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
 4f2:	4829      	ldr	r0, [pc, #164]	; (598 <main+0xe4>)
 4f4:	6110      	str	r0, [r2, #16]
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;
 4f6:	4829      	ldr	r0, [pc, #164]	; (59c <main+0xe8>)
 4f8:	6190      	str	r0, [r2, #24]

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 4fa:	20e0      	movs	r0, #224	; 0xe0
 4fc:	0040      	lsls	r0, r0, #1
 4fe:	5014      	str	r4, [r2, r0]
 * @param	clk	: Clock to disable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL &= ~(1 << clk);
 500:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 502:	438a      	bics	r2, r1
 504:	67da      	str	r2, [r3, #124]	; 0x7c

	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);
	/*END OF PIN ASSIGNMENTS*/

	// Configure the SPI to use TLC DAC settings
	TLC_Init();
 506:	f000 f941 	bl	78c <TLC_Init>
//	Chip_ACMP_EnableVoltLadder(LPC_CMP);
//	Chip_ACMP_SetupVoltLadder(LPC_CMP, 0, FALSE);
//	ACMP_Status = Chip_ACMP_GetCompStatus(LPC_CMP);

	// Initialize the frequency generation timer
	WaveGenInit(&Generator1, MIDIto30MhzReload[25]);
 50a:	4c25      	ldr	r4, [pc, #148]	; (5a0 <main+0xec>)
 50c:	4925      	ldr	r1, [pc, #148]	; (5a4 <main+0xf0>)
 50e:	1c20      	adds	r0, r4, #0
 510:	f000 f9a2 	bl	858 <WaveGenInit>
	WaveGenStart(&Generator1);
 514:	1c20      	adds	r0, r4, #0
 516:	f000 f96d 	bl	7f4 <WaveGenStart>

	// Initialize the envelope
	envLinADSR_t envelope;
	SetEnvelopeTimes(&envelope, TRANSIENT_LENGTH, PULSE_LENGTH, SUSTAIN,0x0);
 51a:	2400      	movs	r4, #0
 51c:	2296      	movs	r2, #150	; 0x96
 51e:	0052      	lsls	r2, r2, #1
 520:	2332      	movs	r3, #50	; 0x32
 522:	a802      	add	r0, sp, #8
 524:	1c21      	adds	r1, r4, #0
 526:	9400      	str	r4, [sp, #0]
 528:	f000 f882 	bl	630 <SetEnvelopeTimes>

    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
 52c:	481e      	ldr	r0, [pc, #120]	; (5a8 <main+0xf4>)
 52e:	2102      	movs	r1, #2
 530:	f000 f8a4 	bl	67c <MIDI_USARTInit>
	MIDI_SetAddress(LOCAL_ADDRESS);
 534:	1c20      	adds	r0, r4, #0
 536:	f000 f8cd 	bl	6d4 <MIDI_SetAddress>

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 53a:	4a1c      	ldr	r2, [pc, #112]	; (5ac <main+0xf8>)
 53c:	4b1c      	ldr	r3, [pc, #112]	; (5b0 <main+0xfc>)
	MIDI_NoteOffFunc = &MIDI_NoteOff;

	MIDI_Enable(LPC_USART0);
 53e:	481a      	ldr	r0, [pc, #104]	; (5a8 <main+0xf4>)
    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
	MIDI_SetAddress(LOCAL_ADDRESS);

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 540:	601a      	str	r2, [r3, #0]
	MIDI_NoteOffFunc = &MIDI_NoteOff;
 542:	4a1c      	ldr	r2, [pc, #112]	; (5b4 <main+0x100>)
 544:	4b1c      	ldr	r3, [pc, #112]	; (5b8 <main+0x104>)
 546:	601a      	str	r2, [r3, #0]

	MIDI_Enable(LPC_USART0);
 548:	f000 f8ca 	bl	6e0 <MIDI_Enable>

/////////////////////////////////////////////MAINLOOP.////////////////////////////////////////////////////
	while (1) {
		// Check if we've received any data
		MIDI_ProcessRXBuffer();
 54c:	f000 f8ce 	bl	6ec <MIDI_ProcessRXBuffer>

		// If the timer has requested a sample, we need to generate any data from a pulse, do so.
		if (triggered != 0)
 550:	4d1a      	ldr	r5, [pc, #104]	; (5bc <main+0x108>)
 552:	782b      	ldrb	r3, [r5, #0]
 554:	2b00      	cmp	r3, #0
 556:	d0f9      	beq.n	54c <main+0x98>
		{
			//Hard Stop at Max.
			if (EnvPosition < 0)
 558:	4c19      	ldr	r4, [pc, #100]	; (5c0 <main+0x10c>)
 55a:	6823      	ldr	r3, [r4, #0]
 55c:	2b00      	cmp	r3, #0
 55e:	da01      	bge.n	564 <main+0xb0>
			{
				EnvPosition = INT32_MAX;
 560:	4b18      	ldr	r3, [pc, #96]	; (5c4 <main+0x110>)
 562:	6023      	str	r3, [r4, #0]
			}

			// Generate the sound
			if (activeNote == -1)
 564:	4b18      	ldr	r3, [pc, #96]	; (5c8 <main+0x114>)
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 566:	a802      	add	r0, sp, #8
			{
				EnvPosition = INT32_MAX;
			}

			// Generate the sound
			if (activeNote == -1)
 568:	781b      	ldrb	r3, [r3, #0]
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 56a:	6821      	ldr	r1, [r4, #0]
			{
				EnvPosition = INT32_MAX;
			}

			// Generate the sound
			if (activeNote == -1)
 56c:	b25b      	sxtb	r3, r3
 56e:	3301      	adds	r3, #1
 570:	d102      	bne.n	578 <main+0xc4>
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 572:	f7ff ff71 	bl	458 <GenPluckBow_NoteOff>
 576:	e001      	b.n	57c <main+0xc8>
			}
			else
			{
				GenPluckBow(&envelope, EnvPosition);
 578:	f7ff ff44 	bl	404 <GenPluckBow>
			}

			// Clear the triggered variable
			triggered = 0;
 57c:	2300      	movs	r3, #0
 57e:	702b      	strb	r3, [r5, #0]

			// Advance the Envelope Position
			EnvPosition++;
 580:	6823      	ldr	r3, [r4, #0]
 582:	3301      	adds	r3, #1
 584:	6023      	str	r3, [r4, #0]
 586:	e7e1      	b.n	54c <main+0x98>
 588:	40048004 	.word	0x40048004
 58c:	ffff00ff 	.word	0xffff00ff
 590:	4000c000 	.word	0x4000c000
 594:	05ffffff 	.word	0x05ffffff
 598:	ff03ff04 	.word	0xff03ff04
 59c:	02ffffff 	.word	0x02ffffff
 5a0:	1000010c 	.word	0x1000010c
 5a4:	44534000 	.word	0x44534000
 5a8:	40064000 	.word	0x40064000
 5ac:	00000331 	.word	0x00000331
 5b0:	1000012c 	.word	0x1000012c
 5b4:	00000301 	.word	0x00000301
 5b8:	10000128 	.word	0x10000128
 5bc:	10000120 	.word	0x10000120
 5c0:	10000118 	.word	0x10000118
 5c4:	7fffffff 	.word	0x7fffffff
 5c8:	10000108 	.word	0x10000108

000005cc <SCT_IRQHandler>:
	}
}

void SCT_IRQHandler(void)
{
	triggered = 1;
 5cc:	4b03      	ldr	r3, [pc, #12]	; (5dc <SCT_IRQHandler+0x10>)
 5ce:	2201      	movs	r2, #1
 5d0:	701a      	strb	r2, [r3, #0]
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVFLAG |= evt;
 5d2:	4b03      	ldr	r3, [pc, #12]	; (5e0 <SCT_IRQHandler+0x14>)
 5d4:	6819      	ldr	r1, [r3, #0]
 5d6:	430a      	orrs	r2, r1
 5d8:	601a      	str	r2, [r3, #0]
	// reset the interrupt flag
	Chip_SCT_ClearEventFlag(LPC_SCT, SCT_EVT_0);
}
 5da:	4770      	bx	lr
 5dc:	10000120 	.word	0x10000120
 5e0:	500040f4 	.word	0x500040f4

000005e4 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 5e4:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 5e6:	f000 faa3 	bl	b30 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 5ea:	bd08      	pop	{r3, pc}

000005ec <GenLinADS>:

#include "BAP_Envelope.h"
#include "BAP_math.h"

uint32_t GenLinADS(envLinADSR_t* env, uint32_t pos)
{
 5ec:	b513      	push	{r0, r1, r4, lr}
 5ee:	1c0a      	adds	r2, r1, #0

	// Attack
	if (pos < env->atk){
 5f0:	6801      	ldr	r1, [r0, #0]
 5f2:	428a      	cmp	r2, r1
 5f4:	d204      	bcs.n	600 <GenLinADS+0x14>
		return i_lscale(0, env->atk, 0, ENVAMP_MAX, pos);
 5f6:	2000      	movs	r0, #0
 5f8:	9200      	str	r2, [sp, #0]
 5fa:	237f      	movs	r3, #127	; 0x7f
 5fc:	1c02      	adds	r2, r0, #0
 5fe:	e007      	b.n	610 <GenLinADS+0x24>
	}

	// Decay
	else if ((pos <= env->dk) && (pos >= env->atk)){
 600:	6844      	ldr	r4, [r0, #4]
 602:	6883      	ldr	r3, [r0, #8]
 604:	42a2      	cmp	r2, r4
 606:	d806      	bhi.n	616 <GenLinADS+0x2a>
		return i_lscale(env->atk, env->dk, ENVAMP_MAX, env->sus, pos);
 608:	9200      	str	r2, [sp, #0]
 60a:	1c08      	adds	r0, r1, #0
 60c:	227f      	movs	r2, #127	; 0x7f
 60e:	1c21      	adds	r1, r4, #0
 610:	f000 f972 	bl	8f8 <i_lscale>
 614:	1c03      	adds	r3, r0, #0
	}

	// Sustain
	return env->sus;
}
 616:	1c18      	adds	r0, r3, #0
 618:	bd16      	pop	{r1, r2, r4, pc}

0000061a <GenLinRelease>:

uint32_t GenLinRelease (envLinADSR_t* env, uint32_t pos)
{
 61a:	b513      	push	{r0, r1, r4, lr}
 61c:	1c03      	adds	r3, r0, #0
 61e:	1c0c      	adds	r4, r1, #0
	return i_lscale(env->dk, env->rls, env->sus, ENVAMP_MIN, pos);
 620:	689a      	ldr	r2, [r3, #8]
 622:	68d9      	ldr	r1, [r3, #12]
 624:	6840      	ldr	r0, [r0, #4]
 626:	2300      	movs	r3, #0
 628:	9400      	str	r4, [sp, #0]
 62a:	f000 f965 	bl	8f8 <i_lscale>
}
 62e:	bd16      	pop	{r1, r2, r4, pc}

00000630 <SetEnvelopeTimes>:
void SetEnvelopeTimes(envLinADSR_t* env, uint32_t atk, uint32_t dk, uint32_t sus, uint32_t rls)
{
	env->atk = atk;
	//shift all times to associate with a global time.
	env->dk = dk += atk;
	env->sus = sus;
 630:	6083      	str	r3, [r0, #8]
	env->rls = rls += dk;
 632:	9b00      	ldr	r3, [sp, #0]
	return i_lscale(env->dk, env->rls, env->sus, ENVAMP_MIN, pos);
}

void SetEnvelopeTimes(envLinADSR_t* env, uint32_t atk, uint32_t dk, uint32_t sus, uint32_t rls)
{
	env->atk = atk;
 634:	6001      	str	r1, [r0, #0]
	//shift all times to associate with a global time.
	env->dk = dk += atk;
 636:	1889      	adds	r1, r1, r2
 638:	6041      	str	r1, [r0, #4]
	env->sus = sus;
	env->rls = rls += dk;
 63a:	18c9      	adds	r1, r1, r3
 63c:	60c1      	str	r1, [r0, #12]
}
 63e:	4770      	bx	lr

00000640 <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 640:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 642:	4b0d      	ldr	r3, [pc, #52]	; (678 <CoreClockInit_30Hz+0x38>)
 644:	2224      	movs	r2, #36	; 0x24
 646:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 648:	228e      	movs	r2, #142	; 0x8e
 64a:	0092      	lsls	r2, r2, #2
 64c:	5899      	ldr	r1, [r3, r2]
 64e:	2080      	movs	r0, #128	; 0x80
 650:	4381      	bics	r1, r0
 652:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 654:	68d8      	ldr	r0, [r3, #12]
 656:	2101      	movs	r1, #1
 658:	4a07      	ldr	r2, [pc, #28]	; (678 <CoreClockInit_30Hz+0x38>)
 65a:	4208      	tst	r0, r1
 65c:	d0fa      	beq.n	654 <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 65e:	2003      	movs	r0, #3
 660:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 662:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 664:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 666:	07d1      	lsls	r1, r2, #31
 668:	d5fc      	bpl.n	664 <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 66a:	4b03      	ldr	r3, [pc, #12]	; (678 <CoreClockInit_30Hz+0x38>)
 66c:	2202      	movs	r2, #2
 66e:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 670:	f000 f952 	bl	918 <SystemCoreClockUpdate>
}
 674:	bd08      	pop	{r3, pc}
 676:	46c0      	nop			; (mov r8, r8)
 678:	40048000 	.word	0x40048000

0000067c <MIDI_USARTInit>:

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 67c:	b538      	push	{r3, r4, r5, lr}
 * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetUARTClockDiv(uint32_t div)
{
	LPC_SYSCTL->UARTCLKDIV = div;
 67e:	4b0f      	ldr	r3, [pc, #60]	; (6bc <MIDI_USARTInit+0x40>)
 680:	2501      	movs	r5, #1
 682:	601d      	str	r5, [r3, #0]
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	uint32_t reg;

	reg = pUART->CFG & ~((0x3 << 2) | (0x3 << 4) | (0x1 << 6));
 684:	6803      	ldr	r3, [r0, #0]
 686:	227c      	movs	r2, #124	; 0x7c
 688:	4393      	bics	r3, r2
	pUART->CFG = reg | config;
 68a:	2204      	movs	r2, #4
 68c:	4313      	orrs	r3, r2
 68e:	6003      	str	r3, [r0, #0]

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 690:	490b      	ldr	r1, [pc, #44]	; (6c0 <MIDI_USARTInit+0x44>)

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 692:	1c04      	adds	r4, r0, #0

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 694:	f000 fa78 	bl	b88 <Chip_UART_SetBaud>
	/***
	 *  Initialize the RX and TX specific functions
	 **/
#ifdef MIDI_RX_ENABLE
		// Initialize the Receive buffer
		RingBuffer_Init(&MIDI_RxBuffer, &MIDI_RxData, sizeof(uint8_t), MIDI_RXBUFFERSIZE);
 698:	1c2a      	adds	r2, r5, #0
 69a:	490a      	ldr	r1, [pc, #40]	; (6c4 <MIDI_USARTInit+0x48>)
 69c:	230a      	movs	r3, #10
 69e:	480a      	ldr	r0, [pc, #40]	; (6c8 <MIDI_USARTInit+0x4c>)
 6a0:	f000 f9d4 	bl	a4c <RingBuffer_Init>

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 6a4:	4b09      	ldr	r3, [pc, #36]	; (6cc <MIDI_USARTInit+0x50>)
 6a6:	2200      	movs	r2, #0
 6a8:	701a      	strb	r2, [r3, #0]
 6aa:	705a      	strb	r2, [r3, #1]
 6ac:	709a      	strb	r2, [r3, #2]
 6ae:	70da      	strb	r2, [r3, #3]
 6b0:	4b07      	ldr	r3, [pc, #28]	; (6d0 <MIDI_USARTInit+0x54>)
 6b2:	2208      	movs	r2, #8
 * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
 *			to enable specific UART interrupts.
 */
STATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
{
	pUART->INTENSET = intMask;
 6b4:	60e5      	str	r5, [r4, #12]
 6b6:	601a      	str	r2, [r3, #0]
		Chip_UART_IntEnable(USARTNumber, UART_INTEN_TXRDY);
#endif

	MIDI_ClearStatus0();
	NVIC_EnableIRQ(UART0_IRQn);
}
 6b8:	bd38      	pop	{r3, r4, r5, pc}
 6ba:	46c0      	nop			; (mov r8, r8)
 6bc:	40048094 	.word	0x40048094
 6c0:	00007a12 	.word	0x00007a12
 6c4:	10000130 	.word	0x10000130
 6c8:	1000013c 	.word	0x1000013c
 6cc:	10000123 	.word	0x10000123
 6d0:	e000e100 	.word	0xe000e100

000006d4 <MIDI_SetAddress>:
/***
 * Sets the address of the current receiver
 **/
void inline MIDI_SetAddress(uint8_t addr)
{
	MIDI_Address = addr;
 6d4:	4b01      	ldr	r3, [pc, #4]	; (6dc <MIDI_SetAddress+0x8>)
 6d6:	7018      	strb	r0, [r3, #0]
}
 6d8:	4770      	bx	lr
 6da:	46c0      	nop			; (mov r8, r8)
 6dc:	10000122 	.word	0x10000122

000006e0 <MIDI_Enable>:
 */

void inline MIDI_Enable(LPC_USART_T* USARTNumber)
{
	// Enable the UART to start receiving messages
	USARTNumber->CFG |= UART_CFG_ENABLE;
 6e0:	6803      	ldr	r3, [r0, #0]
 6e2:	2201      	movs	r2, #1
 6e4:	4313      	orrs	r3, r2
 6e6:	6003      	str	r3, [r0, #0]
}
 6e8:	4770      	bx	lr
	...

000006ec <MIDI_ProcessRXBuffer>:
		}
	}
}

void MIDI_ProcessRXBuffer()
{
 6ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t byte = 0;
 6ee:	2400      	movs	r4, #0
 6f0:	466d      	mov	r5, sp
 6f2:	71ec      	strb	r4, [r5, #7]
 6f4:	3507      	adds	r5, #7
	// Pop a value off the buffer

	if(Chip_UART_ReadRB(LPC_USART0, &MIDI_RxBuffer, &byte, 1) != 0)
 6f6:	481a      	ldr	r0, [pc, #104]	; (760 <MIDI_ProcessRXBuffer+0x74>)
 6f8:	491a      	ldr	r1, [pc, #104]	; (764 <MIDI_ProcessRXBuffer+0x78>)
 6fa:	1c2a      	adds	r2, r5, #0
 6fc:	2301      	movs	r3, #1
 6fe:	f000 fa75 	bl	bec <Chip_UART_ReadRB>
 702:	42a0      	cmp	r0, r4
 704:	d02b      	beq.n	75e <MIDI_ProcessRXBuffer+0x72>
	{
		// Is it a status bit
		if((byte & MIDI_STATBIT))
 706:	7829      	ldrb	r1, [r5, #0]
 708:	4b17      	ldr	r3, [pc, #92]	; (768 <MIDI_ProcessRXBuffer+0x7c>)
 70a:	b24a      	sxtb	r2, r1
 70c:	42a2      	cmp	r2, r4
 70e:	da0c      	bge.n	72a <MIDI_ProcessRXBuffer+0x3e>
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 710:	4a16      	ldr	r2, [pc, #88]	; (76c <MIDI_ProcessRXBuffer+0x80>)
 712:	200f      	movs	r0, #15
 714:	7812      	ldrb	r2, [r2, #0]
		// Is it a status bit
		if((byte & MIDI_STATBIT))
		{
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;
 716:	7019      	strb	r1, [r3, #0]

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 718:	705c      	strb	r4, [r3, #1]
 71a:	709c      	strb	r4, [r3, #2]
 71c:	70dc      	strb	r4, [r3, #3]
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 71e:	4001      	ands	r1, r0
 720:	428a      	cmp	r2, r1
 722:	d11a      	bne.n	75a <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_Status0.Addressed = 1;
 724:	2201      	movs	r2, #1
 726:	705a      	strb	r2, [r3, #1]
 728:	e017      	b.n	75a <MIDI_ProcessRXBuffer+0x6e>
			}
		}
		else if (MIDI_Status0.Addressed)
 72a:	785a      	ldrb	r2, [r3, #1]
 72c:	2a00      	cmp	r2, #0
 72e:	d014      	beq.n	75a <MIDI_ProcessRXBuffer+0x6e>
		{
			MIDI_Status0.DataCount++;
 730:	789a      	ldrb	r2, [r3, #2]
 732:	3201      	adds	r2, #1
 734:	b2d2      	uxtb	r2, r2
 736:	709a      	strb	r2, [r3, #2]
}

static void MIDI_ByteProcessor(uint8_t byte)
{

	if ((MIDI_Status0.DataCount % 2))
 738:	07d0      	lsls	r0, r2, #31
 73a:	d501      	bpl.n	740 <MIDI_ProcessRXBuffer+0x54>
		MIDI_Status0.DB1 = byte;
 73c:	70d9      	strb	r1, [r3, #3]
 73e:	e00c      	b.n	75a <MIDI_ProcessRXBuffer+0x6e>

	else
	{
		switch(MIDI_Status0.Status)
 740:	781a      	ldrb	r2, [r3, #0]
 742:	2a80      	cmp	r2, #128	; 0x80
 744:	d003      	beq.n	74e <MIDI_ProcessRXBuffer+0x62>
 746:	2a90      	cmp	r2, #144	; 0x90
 748:	d107      	bne.n	75a <MIDI_ProcessRXBuffer+0x6e>
		{
		case MIDI_NOTEON:
			if ( MIDI_NoteOnFunc != 0)
 74a:	4a09      	ldr	r2, [pc, #36]	; (770 <MIDI_ProcessRXBuffer+0x84>)
 74c:	e000      	b.n	750 <MIDI_ProcessRXBuffer+0x64>
			{
				MIDI_NoteOnFunc(MIDI_Status0.DB1, byte);
			}
			break;
		case MIDI_NOTEOFF:
			if ( MIDI_NoteOffFunc != 0)
 74e:	4a09      	ldr	r2, [pc, #36]	; (774 <MIDI_ProcessRXBuffer+0x88>)
 750:	6812      	ldr	r2, [r2, #0]
 752:	2a00      	cmp	r2, #0
 754:	d001      	beq.n	75a <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_NoteOffFunc(MIDI_Status0.DB1, byte);
 756:	78d8      	ldrb	r0, [r3, #3]
 758:	4790      	blx	r2
			MIDI_Status0.DataCount++;
			MIDI_ByteProcessor(byte);
		}

		// Process the next byte
		MIDI_ProcessRXBuffer();
 75a:	f7ff ffc7 	bl	6ec <MIDI_ProcessRXBuffer>
	}
}
 75e:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 760:	40064000 	.word	0x40064000
 764:	1000013c 	.word	0x1000013c
 768:	10000123 	.word	0x10000123
 76c:	10000122 	.word	0x10000122
 770:	1000012c 	.word	0x1000012c
 774:	10000128 	.word	0x10000128

00000778 <UART0_IRQHandler>:

void UART0_IRQHandler(void)
{
 778:	b508      	push	{r3, lr}
	// Insert value into RB
	Chip_UART_RXIntHandlerRB(LPC_USART0, &MIDI_RxBuffer);
 77a:	4802      	ldr	r0, [pc, #8]	; (784 <UART0_IRQHandler+0xc>)
 77c:	4902      	ldr	r1, [pc, #8]	; (788 <UART0_IRQHandler+0x10>)
 77e:	f000 fa21 	bl	bc4 <Chip_UART_RXIntHandlerRB>
}
 782:	bd08      	pop	{r3, pc}
 784:	40064000 	.word	0x40064000
 788:	1000013c 	.word	0x1000013c

0000078c <TLC_Init>:
#include "BAP_TLC_DAC.h"

uint8_t TLC_LDAC_pin;

void TLC_Init()
{
 78c:	b510      	push	{r4, lr}
	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_HI)) & ~((uint32_t) SPI_CFG_SPI_EN);
 78e:	2392      	movs	r3, #146	; 0x92
 790:	4c0c      	ldr	r4, [pc, #48]	; (7c4 <TLC_Init+0x38>)
 792:	005b      	lsls	r3, r3, #1
 794:	6023      	str	r3, [r4, #0]

	// Set the rate to 1MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 1000000));
 796:	1c20      	adds	r0, r4, #0
 798:	490b      	ldr	r1, [pc, #44]	; (7c8 <TLC_Init+0x3c>)
 79a:	f000 f9b7 	bl	b0c <Chip_SPI_CalClkRateDivider>
 79e:	b280      	uxth	r0, r0
 7a0:	6260      	str	r0, [r4, #36]	; 0x24
 * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_CLR_*)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
{
	pSPI->STAT |= Flag;
 7a2:	68a3      	ldr	r3, [r4, #8]
 7a4:	223c      	movs	r2, #60	; 0x3c
 7a6:	4313      	orrs	r3, r2
 7a8:	60a3      	str	r3, [r4, #8]

	// Clear status flags
	Chip_SPI_ClearStatus(LPC_SPI0, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);

	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN | SPI_INTENCLR_RXDYEN | SPI_INTENCLR_RXOVEN | SPI_INTENCLR_TXUREN, DISABLE);
 7aa:	1c20      	adds	r0, r4, #0
 7ac:	210f      	movs	r1, #15
 7ae:	2200      	movs	r2, #0
 7b0:	f000 f9b4 	bl	b1c <Chip_SPI_Int_Cmd>
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
{
	pSPI->CFG |= SPI_CFG_SPI_EN;
 7b4:	6822      	ldr	r2, [r4, #0]
 7b6:	2301      	movs	r3, #1
 7b8:	431a      	orrs	r2, r3
 7ba:	6022      	str	r2, [r4, #0]
 7bc:	4a03      	ldr	r2, [pc, #12]	; (7cc <TLC_Init+0x40>)
 7be:	6013      	str	r3, [r2, #0]

	// Enable the SPI
	Chip_SPI_Enable(LPC_SPI0);
 	NVIC_EnableIRQ(SPI0_IRQn);
}
 7c0:	bd10      	pop	{r4, pc}
 7c2:	46c0      	nop			; (mov r8, r8)
 7c4:	40058000 	.word	0x40058000
 7c8:	000f4240 	.word	0x000f4240
 7cc:	e000e100 	.word	0xe000e100

000007d0 <TLC_SetDACValue>:


void TLC_SetDACValue(TLC_DACNumber DAC, TLC_Range range, uint8_t* value)
{
	// A frame is 11 bits: 2 bit address, 1 bit range, 8 bits data.
	uint16_t frame = (uint16_t)(TLC_DAC(DAC) | TLC_RNG(range) | TLC_Datamask(*value));
 7d0:	7813      	ldrb	r3, [r2, #0]
 7d2:	0209      	lsls	r1, r1, #8
 7d4:	4319      	orrs	r1, r3
 7d6:	0240      	lsls	r0, r0, #9
 7d8:	4301      	orrs	r1, r0
 7da:	b289      	uxth	r1, r1
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
 */
STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
{
	return pSPI->STAT;
 7dc:	4b04      	ldr	r3, [pc, #16]	; (7f0 <TLC_SetDACValue+0x20>)
 7de:	689a      	ldr	r2, [r3, #8]

	// Wait for the SPI to be ready
	// This is a blocking method
	while (!(Chip_SPI_GetStatus(LPC_SPI0) & SPI_STAT_TXRDY)){/*do nothing*/}
 7e0:	0790      	lsls	r0, r2, #30
 7e2:	d5fb      	bpl.n	7dc <TLC_SetDACValue+0xc>
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 7e4:	20a7      	movs	r0, #167	; 0xa7
 7e6:	0500      	lsls	r0, r0, #20
 7e8:	4308      	orrs	r0, r1
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 7ea:	6198      	str	r0, [r3, #24]
	// Send a frame.
	// Since there is no need to read a response,
	// and the full message fits with a frame,
	// we assume this will be the final frame.
	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 11);
}
 7ec:	4770      	bx	lr
 7ee:	46c0      	nop			; (mov r8, r8)
 7f0:	40058000 	.word	0x40058000

000007f4 <WaveGenStart>:
}


void WaveGenStart(WaveGen* Generator)
{
	switch(Generator->ID)
 7f4:	7803      	ldrb	r3, [r0, #0]
 7f6:	2b00      	cmp	r3, #0
 7f8:	d104      	bne.n	804 <WaveGenStart+0x10>
	{
	case 0:
		LPC_SCT->CTRL_U &= ~(1 << 2);
 7fa:	4b03      	ldr	r3, [pc, #12]	; (808 <WaveGenStart+0x14>)
 7fc:	2104      	movs	r1, #4
 7fe:	685a      	ldr	r2, [r3, #4]
 800:	438a      	bics	r2, r1
 802:	605a      	str	r2, [r3, #4]
		break;
	case 1:
		break;
	}
}
 804:	4770      	bx	lr
 806:	46c0      	nop			; (mov r8, r8)
 808:	50004000 	.word	0x50004000

0000080c <setWidth>:


void setWidth(WaveGen* Generator, uint8_t percentage)
{
 80c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80e:	1c05      	adds	r5, r0, #0
 810:	1c0c      	adds	r4, r1, #0
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 812:	f000 f911 	bl	a38 <Chip_Clock_GetSystemClockRate>
	int genID = Generator->ID;
 816:	782f      	ldrb	r7, [r5, #0]


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 818:	686e      	ldr	r6, [r5, #4]
	int genID = Generator->ID;

	// TODO: actually write some good code here instead of dumb code.
	if ((genID < 0) || (genID > 3)) {
 81a:	2f03      	cmp	r7, #3
 81c:	d818      	bhi.n	850 <setWidth+0x44>
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
 81e:	2301      	movs	r3, #1
	if ((genID < 0) || (genID > 3)) {
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
 820:	2c63      	cmp	r4, #99	; 0x63
 822:	d810      	bhi.n	846 <setWidth+0x3a>


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 824:	f000 fb09 	bl	e3a <__aeabi_ui2f>
 828:	1c31      	adds	r1, r6, #0
 82a:	f000 fa53 	bl	cd4 <__aeabi_fdiv>
 82e:	f000 fac1 	bl	db4 <__aeabi_f2uiz>
 832:	1c06      	adds	r6, r0, #0
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
		value = reload + 1;
 834:	1c43      	adds	r3, r0, #1
	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
 836:	2c00      	cmp	r4, #0
 838:	d005      	beq.n	846 <setWidth+0x3a>
		value = reload + 1;
	}
	else {
		uint32_t newTicks;

		newTicks = (reload * percentage)/100;
 83a:	1c20      	adds	r0, r4, #0
 83c:	4370      	muls	r0, r6
 83e:	2164      	movs	r1, #100	; 0x64
 840:	f000 fa0d 	bl	c5e <__aeabi_uidiv>

		/* Approximate duty cycle rate */
		value = reload - newTicks;
 844:	1a33      	subs	r3, r6, r0
	}

	LPC_SCT->MATCHREL[genID + 1].U = value;
 846:	3781      	adds	r7, #129	; 0x81
 848:	4a02      	ldr	r2, [pc, #8]	; (854 <setWidth+0x48>)
 84a:	00bf      	lsls	r7, r7, #2
 84c:	50bb      	str	r3, [r7, r2]
	Generator->width = percentage;
 84e:	722c      	strb	r4, [r5, #8]
}
 850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 852:	46c0      	nop			; (mov r8, r8)
 854:	50004000 	.word	0x50004000

00000858 <WaveGenInit>:

/********************************************************************************************************
 * 											FUNCTIONS													*
 *******************************************************************************************************/
void WaveGenInit(WaveGen* Generator, float freq)
{
 858:	b538      	push	{r3, r4, r5, lr}
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 85a:	4c14      	ldr	r4, [pc, #80]	; (8ac <WaveGenInit+0x54>)
 85c:	2301      	movs	r3, #1

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 85e:	2207      	movs	r2, #7
void WaveGenInit(WaveGen* Generator, float freq)
{
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 860:	6023      	str	r3, [r4, #0]

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 862:	6522      	str	r2, [r4, #80]	; 0x50
	{
		freq = 1;
	}

	/* Setup for match mode */
	LPC_SCT->REGMODE_L = 0;
 864:	1c22      	adds	r2, r4, #0
 866:	2500      	movs	r5, #0
 868:	324c      	adds	r2, #76	; 0x4c
 86a:	8015      	strh	r5, [r2, #0]

	// what does this do?
	LPC_SCT->EVENT[0].CTRL = 0x00001000;
 86c:	2180      	movs	r1, #128	; 0x80
 86e:	22c1      	movs	r2, #193	; 0xc1
 870:	0149      	lsls	r1, r1, #5
 872:	0092      	lsls	r2, r2, #2
 874:	50a1      	str	r1, [r4, r2]

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;
 876:	22c0      	movs	r2, #192	; 0xc0
 878:	4259      	negs	r1, r3
 87a:	0092      	lsls	r2, r2, #2
 87c:	50a1      	str	r1, [r4, r2]
	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 87e:	4a0c      	ldr	r2, [pc, #48]	; (8b0 <WaveGenInit+0x58>)

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;

	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);
 880:	8123      	strh	r3, [r4, #8]

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 882:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[1].CLR = (1 << 0);
 884:	4a0b      	ldr	r2, [pc, #44]	; (8b4 <WaveGenInit+0x5c>)

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 886:	490c      	ldr	r1, [pc, #48]	; (8b8 <WaveGenInit+0x60>)
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
	LPC_SCT->OUT[1].CLR = (1 << 0);
 888:	50a3      	str	r3, [r4, r2]

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 88a:	22c3      	movs	r2, #195	; 0xc3
 88c:	0092      	lsls	r2, r2, #2
 88e:	50a1      	str	r1, [r4, r2]
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
 890:	22c2      	movs	r2, #194	; 0xc2
 892:	0092      	lsls	r2, r2, #2
 894:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[0].SET = (1 << 1);
 896:	23a0      	movs	r3, #160	; 0xa0
 898:	2202      	movs	r2, #2
 89a:	00db      	lsls	r3, r3, #3
 89c:	50e2      	str	r2, [r4, r3]

	setWidth(Generator, 50);
 89e:	2132      	movs	r1, #50	; 0x32

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 8a0:	3406      	adds	r4, #6
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
	LPC_SCT->OUT[0].SET = (1 << 1);

	setWidth(Generator, 50);
 8a2:	f7ff ffb3 	bl	80c <setWidth>

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 8a6:	87e5      	strh	r5, [r4, #62]	; 0x3e
}
 8a8:	bd38      	pop	{r3, r4, r5, pc}
 8aa:	46c0      	nop			; (mov r8, r8)
 8ac:	50004000 	.word	0x50004000
 8b0:	00000504 	.word	0x00000504
 8b4:	0000050c 	.word	0x0000050c
 8b8:	00001001 	.word	0x00001001

000008bc <setReload>:
}


void setReload(WaveGen* Generator, int reload)
{
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
 8bc:	7802      	ldrb	r2, [r0, #0]
 8be:	4b02      	ldr	r3, [pc, #8]	; (8c8 <setReload+0xc>)
 8c0:	3280      	adds	r2, #128	; 0x80
 8c2:	0092      	lsls	r2, r2, #2
 8c4:	50d1      	str	r1, [r2, r3]
}
 8c6:	4770      	bx	lr
 8c8:	50004000 	.word	0x50004000

000008cc <updateFreq>:

void updateFreq(WaveGen* Generator)
{
 8cc:	b510      	push	{r4, lr}
 8ce:	1c04      	adds	r4, r0, #0
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 8d0:	f000 f8b2 	bl	a38 <Chip_Clock_GetSystemClockRate>
 8d4:	7822      	ldrb	r2, [r4, #0]
 8d6:	4b07      	ldr	r3, [pc, #28]	; (8f4 <updateFreq+0x28>)
 8d8:	3280      	adds	r2, #128	; 0x80
 8da:	0092      	lsls	r2, r2, #2
 8dc:	58d1      	ldr	r1, [r2, r3]
 8de:	f000 f9be 	bl	c5e <__aeabi_uidiv>
 8e2:	f000 faaa 	bl	e3a <__aeabi_ui2f>
	setWidth(Generator, Generator->width);
 8e6:	7a21      	ldrb	r1, [r4, #8]
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
}

void updateFreq(WaveGen* Generator)
{
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 8e8:	6060      	str	r0, [r4, #4]
	setWidth(Generator, Generator->width);
 8ea:	1c20      	adds	r0, r4, #0
 8ec:	f7ff ff8e 	bl	80c <setWidth>
}
 8f0:	bd10      	pop	{r4, pc}
 8f2:	46c0      	nop			; (mov r8, r8)
 8f4:	50004000 	.word	0x50004000

000008f8 <i_lscale>:
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 8f8:	b538      	push	{r3, r4, r5, lr}
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
 8fa:	1a09      	subs	r1, r1, r0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 8fc:	1c05      	adds	r5, r0, #0
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
	{
		return y;
 8fe:	2000      	movs	r0, #0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 900:	1c14      	adds	r4, r2, #0
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
 902:	4281      	cmp	r1, r0
 904:	d007      	beq.n	916 <i_lscale+0x1e>
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
 906:	1a9b      	subs	r3, r3, r2
	int32_t X = x - minX;
 908:	9a04      	ldr	r2, [sp, #16]
 90a:	1b55      	subs	r5, r2, r5
	{
		return y;
	}

	// calculate scaled position
	y = minY + ((DeltaY *X) /DeltaX);
 90c:	1c28      	adds	r0, r5, #0
 90e:	4358      	muls	r0, r3
 910:	f000 f9a2 	bl	c58 <__aeabi_idiv>
 914:	1820      	adds	r0, r4, r0
	//{
	//	y += (maxY > minY ? maxY : minY);
	//}

	return y;
}
 916:	bd38      	pop	{r3, r4, r5, pc}

00000918 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 918:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 91a:	f000 f88d 	bl	a38 <Chip_Clock_GetSystemClockRate>
 91e:	4b01      	ldr	r3, [pc, #4]	; (924 <SystemCoreClockUpdate+0xc>)
 920:	6018      	str	r0, [r3, #0]
}
 922:	bd08      	pop	{r3, pc}
 924:	10000150 	.word	0x10000150

00000928 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 928:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 92a:	05c2      	lsls	r2, r0, #23
 92c:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 92e:	211f      	movs	r1, #31
 930:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 932:	0092      	lsls	r2, r2, #2
 934:	4b03      	ldr	r3, [pc, #12]	; (944 <Chip_Clock_GetWDTLFORate+0x1c>)
 936:	58d0      	ldr	r0, [r2, r3]
 938:	3101      	adds	r1, #1
 93a:	0049      	lsls	r1, r1, #1
 93c:	f000 f98f 	bl	c5e <__aeabi_uidiv>
}
 940:	bd08      	pop	{r3, pc}
 942:	46c0      	nop			; (mov r8, r8)
 944:	00000f04 	.word	0x00000f04

00000948 <Chip_Clock_GetPLLFreq>:

/* Compute a PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t msel = ((PLLReg & 0x1F) + 1);
 948:	231f      	movs	r3, #31
 94a:	4018      	ands	r0, r3
 94c:	3001      	adds	r0, #1

	return inputRate * msel;
 94e:	4348      	muls	r0, r1
}
 950:	4770      	bx	lr
 952:	46c0      	nop			; (mov r8, r8)

00000954 <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 954:	4b03      	ldr	r3, [pc, #12]	; (964 <Chip_Clock_SetSystemPLLSource+0x10>)
 956:	6418      	str	r0, [r3, #64]	; 0x40
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;
 958:	2200      	movs	r2, #0
 95a:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;
 95c:	2201      	movs	r2, #1
 95e:	645a      	str	r2, [r3, #68]	; 0x44
}
 960:	4770      	bx	lr
 962:	46c0      	nop			; (mov r8, r8)
 964:	40048000 	.word	0x40048000

00000968 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 968:	4b03      	ldr	r3, [pc, #12]	; (978 <Chip_Clock_SetMainClockSource+0x10>)
 96a:	6718      	str	r0, [r3, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN  = 0;
 96c:	2200      	movs	r2, #0
 96e:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 970:	2201      	movs	r2, #1
 972:	675a      	str	r2, [r3, #116]	; 0x74
}
 974:	4770      	bx	lr
 976:	46c0      	nop			; (mov r8, r8)
 978:	40048000 	.word	0x40048000

0000097c <Chip_Clock_SetCLKOUTSource>:

/* Set CLKOUT clock source and divider */
void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
{
	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
 97c:	4b05      	ldr	r3, [pc, #20]	; (994 <Chip_Clock_SetCLKOUTSource+0x18>)
 97e:	22e0      	movs	r2, #224	; 0xe0
 980:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 0;
 982:	22e4      	movs	r2, #228	; 0xe4
 984:	2000      	movs	r0, #0
 986:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 1;
 988:	2001      	movs	r0, #1
 98a:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTDIV = div;
 98c:	22e8      	movs	r2, #232	; 0xe8
 98e:	5099      	str	r1, [r3, r2]
}
 990:	4770      	bx	lr
 992:	46c0      	nop			; (mov r8, r8)
 994:	40048000 	.word	0x40048000

00000998 <Chip_Clock_GetWDTOSCRate>:

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 998:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 99a:	4b02      	ldr	r3, [pc, #8]	; (9a4 <Chip_Clock_GetWDTOSCRate+0xc>)
 99c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 99e:	f7ff ffc3 	bl	928 <Chip_Clock_GetWDTLFORate>
}
 9a2:	bd08      	pop	{r3, pc}
 9a4:	40048000 	.word	0x40048000

000009a8 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 9a8:	4b09      	ldr	r3, [pc, #36]	; (9d0 <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 9aa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 9ac:	2303      	movs	r3, #3
 9ae:	4013      	ands	r3, r2
 9b0:	2b01      	cmp	r3, #1
 9b2:	d005      	beq.n	9c0 <Chip_Clock_GetSystemPLLInClockRate+0x18>
 9b4:	2b03      	cmp	r3, #3
 9b6:	d006      	beq.n	9c6 <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 9b8:	2b00      	cmp	r3, #0
 9ba:	d107      	bne.n	9cc <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 9bc:	4805      	ldr	r0, [pc, #20]	; (9d4 <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 9be:	e006      	b.n	9ce <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 9c0:	4b05      	ldr	r3, [pc, #20]	; (9d8 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 9c2:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 9c4:	e003      	b.n	9ce <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 9c6:	4b05      	ldr	r3, [pc, #20]	; (9dc <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 9c8:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 9ca:	e000      	b.n	9ce <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 9cc:	2000      	movs	r0, #0
		break;
	}

	return clkRate;
}
 9ce:	4770      	bx	lr
 9d0:	40048000 	.word	0x40048000
 9d4:	00b71b00 	.word	0x00b71b00
 9d8:	00000efc 	.word	0x00000efc
 9dc:	00000f00 	.word	0x00000f00

000009e0 <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 9e0:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 9e2:	4b04      	ldr	r3, [pc, #16]	; (9f4 <Chip_Clock_GetSystemPLLOutClockRate+0x14>)
 9e4:	689c      	ldr	r4, [r3, #8]
 9e6:	f7ff ffdf 	bl	9a8 <Chip_Clock_GetSystemPLLInClockRate>
 9ea:	1c01      	adds	r1, r0, #0
 9ec:	1c20      	adds	r0, r4, #0
 9ee:	f7ff ffab 	bl	948 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 9f2:	bd10      	pop	{r4, pc}
 9f4:	40048000 	.word	0x40048000

000009f8 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 9f8:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 9fa:	4b0d      	ldr	r3, [pc, #52]	; (a30 <Chip_Clock_GetMainClockRate+0x38>)
 9fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 9fe:	2303      	movs	r3, #3
 a00:	4013      	ands	r3, r2
 a02:	2b01      	cmp	r3, #1
 a04:	d009      	beq.n	a1a <Chip_Clock_GetMainClockRate+0x22>
 a06:	dc02      	bgt.n	a0e <Chip_Clock_GetMainClockRate+0x16>
 a08:	2b00      	cmp	r3, #0
 a0a:	d00f      	beq.n	a2c <Chip_Clock_GetMainClockRate+0x34>
 a0c:	e003      	b.n	a16 <Chip_Clock_GetMainClockRate+0x1e>
 a0e:	2b02      	cmp	r3, #2
 a10:	d006      	beq.n	a20 <Chip_Clock_GetMainClockRate+0x28>
 a12:	2b03      	cmp	r3, #3
 a14:	d007      	beq.n	a26 <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 a16:	2000      	movs	r0, #0
 a18:	e009      	b.n	a2e <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 a1a:	f7ff ffc5 	bl	9a8 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 a1e:	e006      	b.n	a2e <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 a20:	f7ff ffba 	bl	998 <Chip_Clock_GetWDTOSCRate>
		break;
 a24:	e003      	b.n	a2e <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 a26:	f7ff ffdb 	bl	9e0 <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 a2a:	e000      	b.n	a2e <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 a2c:	4801      	ldr	r0, [pc, #4]	; (a34 <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 a2e:	bd08      	pop	{r3, pc}
 a30:	40048000 	.word	0x40048000
 a34:	00b71b00 	.word	0x00b71b00

00000a38 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 a38:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 a3a:	f7ff ffdd 	bl	9f8 <Chip_Clock_GetMainClockRate>
 a3e:	4b02      	ldr	r3, [pc, #8]	; (a48 <Chip_Clock_GetSystemClockRate+0x10>)
 a40:	6f99      	ldr	r1, [r3, #120]	; 0x78
 a42:	f000 f90c 	bl	c5e <__aeabi_uidiv>
}
 a46:	bd08      	pop	{r3, pc}
 a48:	40048000 	.word	0x40048000

00000a4c <RingBuffer_Init>:
 ****************************************************************************/

/* Initialize ring buffer */
int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
{
	RingBuff->data = buffer;
 a4c:	6001      	str	r1, [r0, #0]
	RingBuff->count = count;
 a4e:	6043      	str	r3, [r0, #4]
	RingBuff->itemSz = itemSize;
 a50:	6082      	str	r2, [r0, #8]
	RingBuff->head = RingBuff->tail = 0;
 a52:	2300      	movs	r3, #0
 a54:	6103      	str	r3, [r0, #16]
 a56:	60c3      	str	r3, [r0, #12]

	return 1;
}
 a58:	2001      	movs	r0, #1
 a5a:	4770      	bx	lr

00000a5c <RingBuffer_Insert>:

/* Insert a single item into Ring Buffer */
int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
{
 a5c:	b538      	push	{r3, r4, r5, lr}
 a5e:	1c04      	adds	r4, r0, #0
	uint8_t *ptr = RingBuff->data;
 a60:	6805      	ldr	r5, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 a62:	68c2      	ldr	r2, [r0, #12]
 a64:	6903      	ldr	r3, [r0, #16]
 a66:	1ad2      	subs	r2, r2, r3
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is full, otherwise 0
 */
STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
{
	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
 a68:	6843      	ldr	r3, [r0, #4]

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
 a6a:	429a      	cmp	r2, r3
 a6c:	da0d      	bge.n	a8a <RingBuffer_Insert+0x2e>
		return 0;

	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
 a6e:	3b01      	subs	r3, #1
 a70:	68c2      	ldr	r2, [r0, #12]
 a72:	4013      	ands	r3, r2
 a74:	6882      	ldr	r2, [r0, #8]
 a76:	1c10      	adds	r0, r2, #0
 a78:	4358      	muls	r0, r3
 a7a:	1828      	adds	r0, r5, r0
	memcpy(ptr, data, RingBuff->itemSz);
 a7c:	f000 f8e4 	bl	c48 <memcpy>
	RingBuff->head++;
 a80:	68e3      	ldr	r3, [r4, #12]
 a82:	3301      	adds	r3, #1
 a84:	60e3      	str	r3, [r4, #12]

	return 1;
 a86:	2001      	movs	r0, #1
 a88:	e000      	b.n	a8c <RingBuffer_Insert+0x30>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
		return 0;
 a8a:	2000      	movs	r0, #0
	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
	memcpy(ptr, data, RingBuff->itemSz);
	RingBuff->head++;

	return 1;
}
 a8c:	bd38      	pop	{r3, r4, r5, pc}
 a8e:	46c0      	nop			; (mov r8, r8)

00000a90 <RingBuffer_PopMult>:
	return 1;
}

/* Pop multiple items from Ring buffer */
int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
{
 a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 a92:	1c04      	adds	r4, r0, #0
 a94:	1c0f      	adds	r7, r1, #0
	uint8_t *ptr = RingBuff->data;
 a96:	6801      	ldr	r1, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 a98:	68c3      	ldr	r3, [r0, #12]
 a9a:	6900      	ldr	r0, [r0, #16]
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
 a9c:	4283      	cmp	r3, r0
 a9e:	d032      	beq.n	b06 <RingBuffer_PopMult+0x76>
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 aa0:	68e0      	ldr	r0, [r4, #12]
 aa2:	6923      	ldr	r3, [r4, #16]
 aa4:	1ac0      	subs	r0, r0, r3
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
 aa6:	6866      	ldr	r6, [r4, #4]
 aa8:	1e73      	subs	r3, r6, #1
 aaa:	6925      	ldr	r5, [r4, #16]
 aac:	402b      	ands	r3, r5
 aae:	181d      	adds	r5, r3, r0
 ab0:	42b5      	cmp	r5, r6
 ab2:	d301      	bcc.n	ab8 <RingBuffer_PopMult+0x28>
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
 ab4:	1af6      	subs	r6, r6, r3
 ab6:	e000      	b.n	aba <RingBuffer_PopMult+0x2a>
	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
 ab8:	1c06      	adds	r6, r0, #0
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
	cnt2 -= cnt1;
 aba:	1b80      	subs	r0, r0, r6

	cnt1 = MIN(cnt1, num);
 abc:	1e15      	subs	r5, r2, #0
 abe:	42b5      	cmp	r5, r6
 ac0:	dd00      	ble.n	ac4 <RingBuffer_PopMult+0x34>
 ac2:	1c35      	adds	r5, r6, #0
	num -= cnt1;
 ac4:	1b56      	subs	r6, r2, r5

	cnt2 = MIN(cnt2, num);
 ac6:	4286      	cmp	r6, r0
 ac8:	dd00      	ble.n	acc <RingBuffer_PopMult+0x3c>
 aca:	1c06      	adds	r6, r0, #0
	num -= cnt2;

	/* Write segment 1 */
	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
 acc:	68a2      	ldr	r2, [r4, #8]
 ace:	4353      	muls	r3, r2
 ad0:	18c9      	adds	r1, r1, r3
	memcpy(data, ptr, cnt1 * RingBuff->itemSz);
 ad2:	436a      	muls	r2, r5
 ad4:	1c38      	adds	r0, r7, #0
 ad6:	f000 f8b7 	bl	c48 <memcpy>
	RingBuff->tail += cnt1;
 ada:	6922      	ldr	r2, [r4, #16]
 adc:	18ab      	adds	r3, r5, r2
 ade:	6123      	str	r3, [r4, #16]

	/* Write segment 2 */
	ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
 ae0:	6861      	ldr	r1, [r4, #4]
 ae2:	3901      	subs	r1, #1
 ae4:	400b      	ands	r3, r1
 ae6:	68a2      	ldr	r2, [r4, #8]
 ae8:	1c11      	adds	r1, r2, #0
 aea:	4359      	muls	r1, r3
 aec:	6823      	ldr	r3, [r4, #0]
 aee:	1859      	adds	r1, r3, r1
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
 af0:	1c10      	adds	r0, r2, #0
 af2:	4368      	muls	r0, r5
 af4:	1838      	adds	r0, r7, r0
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
 af6:	4372      	muls	r2, r6
 af8:	f000 f8a6 	bl	c48 <memcpy>
	RingBuff->tail += cnt2;
 afc:	6922      	ldr	r2, [r4, #16]
 afe:	1993      	adds	r3, r2, r6
 b00:	6123      	str	r3, [r4, #16]

	return cnt1 + cnt2;
 b02:	19a8      	adds	r0, r5, r6
 b04:	e000      	b.n	b08 <RingBuffer_PopMult+0x78>
	uint8_t *ptr = RingBuff->data;
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;
 b06:	2000      	movs	r0, #0
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
	RingBuff->tail += cnt2;

	return cnt1 + cnt2;
}
 b08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 b0a:	46c0      	nop			; (mov r8, r8)

00000b0c <Chip_SPI_CalClkRateDivider>:
 * Public functions
 ****************************************************************************/

/* Calculate the Clock Rate Divider for SPI Peripheral */
uint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
{
 b0c:	b510      	push	{r4, lr}
 b0e:	1c0c      	adds	r4, r1, #0
	uint32_t SPIClk;
	uint32_t DivVal = 1;

	/* Get SPI clock rate */
	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
 b10:	f7ff ff92 	bl	a38 <Chip_Clock_GetSystemClockRate>

	DivVal = SPIClk / bitRate;
 b14:	1c21      	adds	r1, r4, #0
 b16:	f000 f8a2 	bl	c5e <__aeabi_uidiv>

	return DivVal;
}
 b1a:	bd10      	pop	{r4, pc}

00000b1c <Chip_SPI_Int_Cmd>:
}

/* Disable/Enable Interrupt */
void Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
{
	if (NewState ==  ENABLE) {
 b1c:	2a01      	cmp	r2, #1
 b1e:	d103      	bne.n	b28 <Chip_SPI_Int_Cmd+0xc>
		pSPI->INTENSET |= IntMask;
 b20:	68c3      	ldr	r3, [r0, #12]
 b22:	4319      	orrs	r1, r3
 b24:	60c1      	str	r1, [r0, #12]
 b26:	e002      	b.n	b2e <Chip_SPI_Int_Cmd+0x12>
	}
	else {
		pSPI->INTENCLR |= IntMask;
 b28:	6903      	ldr	r3, [r0, #16]
 b2a:	4319      	orrs	r1, r3
 b2c:	6101      	str	r1, [r0, #16]
	}
}
 b2e:	4770      	bx	lr

00000b30 <Chip_SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 b30:	b508      	push	{r3, lr}
#if defined (USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 b32:	2002      	movs	r0, #2
 b34:	f000 f874 	bl	c20 <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 b38:	2000      	movs	r0, #0
 b3a:	f7ff ff0b 	bl	954 <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~(0x3));
 b3e:	4b10      	ldr	r3, [pc, #64]	; (b80 <Chip_SystemInit+0x50>)
 b40:	691a      	ldr	r2, [r3, #16]
 b42:	2103      	movs	r1, #3
 b44:	438a      	bics	r2, r1

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 b46:	2101      	movs	r1, #1
 b48:	430a      	orrs	r2, r1
 b4a:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 b4c:	2080      	movs	r0, #128	; 0x80
 b4e:	f000 f855 	bl	bfc <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 b52:	2241      	movs	r2, #65	; 0x41
 b54:	4b0b      	ldr	r3, [pc, #44]	; (b84 <Chip_SystemInit+0x54>)
 b56:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 b58:	2080      	movs	r0, #128	; 0x80
 b5a:	f000 f861 	bl	c20 <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 b5e:	4909      	ldr	r1, [pc, #36]	; (b84 <Chip_SystemInit+0x54>)
 b60:	2201      	movs	r2, #1
 b62:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 b64:	421a      	tst	r2, r3
 b66:	d0fc      	beq.n	b62 <Chip_SystemInit+0x32>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 b68:	2201      	movs	r2, #1
 b6a:	4b06      	ldr	r3, [pc, #24]	; (b84 <Chip_SystemInit+0x54>)
 b6c:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 b6e:	2003      	movs	r0, #3
 b70:	f7ff fefa 	bl	968 <Chip_Clock_SetMainClockSource>
#endif

	/* Select the CLKOUT clocking source */
	Chip_Clock_SetCLKOUTSource(SYSCTL_CLKOUTSRC_MAINSYSCLK, 1);
 b74:	2003      	movs	r0, #3
 b76:	2101      	movs	r1, #1
 b78:	f7ff ff00 	bl	97c <Chip_Clock_SetCLKOUTSource>
}
 b7c:	bd08      	pop	{r3, pc}
 b7e:	46c0      	nop			; (mov r8, r8)
 b80:	40040000 	.word	0x40040000
 b84:	40048000 	.word	0x40048000

00000b88 <Chip_UART_SetBaud>:
	return readBytes;
}

/* Set baud rate for UART */
void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
 b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b8a:	1c07      	adds	r7, r0, #0
 b8c:	1c0e      	adds	r6, r1, #0
	uint32_t err, uart_fra_multiplier, baudRateGenerator;
	uint32_t systemCoreClock = Chip_Clock_GetMainClockRate();
 b8e:	f7ff ff33 	bl	9f8 <Chip_Clock_GetMainClockRate>
 b92:	1c05      	adds	r5, r0, #0

	/* Calculate baudrate generator value */
	baudRateGenerator = systemCoreClock / (16 * baudrate);
 b94:	0131      	lsls	r1, r6, #4
 b96:	f000 f862 	bl	c5e <__aeabi_uidiv>
 b9a:	1c04      	adds	r4, r0, #0
	err = systemCoreClock - baudRateGenerator * 16 * baudrate;
 b9c:	4346      	muls	r6, r0
 b9e:	0131      	lsls	r1, r6, #4
 ba0:	1a6d      	subs	r5, r5, r1
	uart_fra_multiplier = (err * 0xFF) / (baudRateGenerator * 16 * baudrate);
 ba2:	0228      	lsls	r0, r5, #8
 ba4:	1b40      	subs	r0, r0, r5
 ba6:	f000 f85a 	bl	c5e <__aeabi_uidiv>
	pUART->BRG = baudRateGenerator - 1;	/* baud rate */
 baa:	3c01      	subs	r4, #1
 bac:	623c      	str	r4, [r7, #32]
 * @param   div  :  Fractional Generator Divider value, should be 0xFF
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
{
	LPC_SYSCTL->UARTFRGDIV = (uint32_t) div;
 bae:	4b04      	ldr	r3, [pc, #16]	; (bc0 <Chip_UART_SetBaud+0x38>)
 bb0:	22ff      	movs	r2, #255	; 0xff
 bb2:	21f0      	movs	r1, #240	; 0xf0
 bb4:	505a      	str	r2, [r3, r1]
 * @param   mult  :  An 8-bit value (0-255) U_PCLK = UARTCLKDIV/(1 + MULT/256)
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGMultiplier(uint8_t mult)
{
	LPC_SYSCTL->UARTFRGMULT = (uint32_t) mult;
 bb6:	4002      	ands	r2, r0
 bb8:	21f4      	movs	r1, #244	; 0xf4
 bba:	505a      	str	r2, [r3, r1]
	Chip_SYSCTL_SetUSARTFRGDivider(0xFF);	/* value 0xFF is always used */
	Chip_SYSCTL_SetUSARTFRGMultiplier(uart_fra_multiplier);
}
 bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 bbe:	46c0      	nop			; (mov r8, r8)
 bc0:	40048000 	.word	0x40048000

00000bc4 <Chip_UART_RXIntHandlerRB>:

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
 bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 bc6:	b083      	sub	sp, #12
 bc8:	1c04      	adds	r4, r0, #0
 bca:	1c0f      	adds	r7, r1, #0
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 bcc:	2601      	movs	r6, #1
		uint8_t ch = Chip_UART_ReadByte(pUART);
 bce:	466d      	mov	r5, sp
 bd0:	3507      	adds	r5, #7

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 bd2:	e005      	b.n	be0 <Chip_UART_RXIntHandlerRB+0x1c>
 *			FIFO status should be read first prior to using this function
 */
STATIC INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
{
	/* Strip off undefined reserved bits, keep 9 lower bits */
	return (uint32_t) (pUART->RXDATA & 0x000001FF);
 bd4:	6963      	ldr	r3, [r4, #20]
		uint8_t ch = Chip_UART_ReadByte(pUART);
 bd6:	702b      	strb	r3, [r5, #0]
		RingBuffer_Insert(pRB, &ch);
 bd8:	1c38      	adds	r0, r7, #0
 bda:	1c29      	adds	r1, r5, #0
 bdc:	f7ff ff3e 	bl	a5c <RingBuffer_Insert>
 *			with one or more UART_STAT_* definitions to determine
 *			statuses.
 */
STATIC INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
{
	return pUART->STAT;
 be0:	68a3      	ldr	r3, [r4, #8]

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 be2:	421e      	tst	r6, r3
 be4:	d1f6      	bne.n	bd4 <Chip_UART_RXIntHandlerRB+0x10>
		uint8_t ch = Chip_UART_ReadByte(pUART);
		RingBuffer_Insert(pRB, &ch);
	}
}
 be6:	b003      	add	sp, #12
 be8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 bea:	46c0      	nop			; (mov r8, r8)

00000bec <Chip_UART_ReadRB>:
	return ret;
}

/* Copy data from a receive ring buffer */
int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
{
 bec:	b508      	push	{r3, lr}
	(void) pUART;

	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
 bee:	1c08      	adds	r0, r1, #0
 bf0:	1c11      	adds	r1, r2, #0
 bf2:	1c1a      	adds	r2, r3, #0
 bf4:	f7ff ff4c 	bl	a90 <RingBuffer_PopMult>
}
 bf8:	bd08      	pop	{r3, pc}
 bfa:	46c0      	nop			; (mov r8, r8)

00000bfc <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 bfc:	4a05      	ldr	r2, [pc, #20]	; (c14 <Chip_SYSCTL_PowerDown+0x18>)
 bfe:	238e      	movs	r3, #142	; 0x8e
 c00:	009b      	lsls	r3, r3, #2
 c02:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 c04:	4308      	orrs	r0, r1
 c06:	4904      	ldr	r1, [pc, #16]	; (c18 <Chip_SYSCTL_PowerDown+0x1c>)
 c08:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 c0a:	4904      	ldr	r1, [pc, #16]	; (c1c <Chip_SYSCTL_PowerDown+0x20>)
 c0c:	4308      	orrs	r0, r1
 c0e:	50d0      	str	r0, [r2, r3]
}
 c10:	4770      	bx	lr
 c12:	46c0      	nop			; (mov r8, r8)
 c14:	40048000 	.word	0x40048000
 c18:	000080ef 	.word	0x000080ef
 c1c:	00006d10 	.word	0x00006d10

00000c20 <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 c20:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 c22:	4a06      	ldr	r2, [pc, #24]	; (c3c <Chip_SYSCTL_PowerUp+0x1c>)
 c24:	238e      	movs	r3, #142	; 0x8e
 c26:	009b      	lsls	r3, r3, #2
 c28:	58d4      	ldr	r4, [r2, r3]
 c2a:	4905      	ldr	r1, [pc, #20]	; (c40 <Chip_SYSCTL_PowerUp+0x20>)
 c2c:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 c2e:	4001      	ands	r1, r0
 c30:	438c      	bics	r4, r1
 c32:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 c34:	4803      	ldr	r0, [pc, #12]	; (c44 <Chip_SYSCTL_PowerUp+0x24>)
 c36:	4301      	orrs	r1, r0
 c38:	50d1      	str	r1, [r2, r3]
}
 c3a:	bd10      	pop	{r4, pc}
 c3c:	40048000 	.word	0x40048000
 c40:	000080ef 	.word	0x000080ef
 c44:	00006d10 	.word	0x00006d10

00000c48 <memcpy>:
 c48:	b508      	push	{r3, lr}
 c4a:	f000 f8fc 	bl	e46 <__aeabi_memcpy>
 c4e:	bd08      	pop	{r3, pc}

00000c50 <__weak_main>:
 c50:	b508      	push	{r3, lr}
 c52:	f7ff fc2f 	bl	4b4 <main>
 c56:	bd08      	pop	{r3, pc}

00000c58 <__aeabi_idiv>:
 c58:	0003      	movs	r3, r0
 c5a:	430b      	orrs	r3, r1
 c5c:	d421      	bmi.n	ca2 <idiv_negative>

00000c5e <__aeabi_uidiv>:
 c5e:	2900      	cmp	r1, #0
 c60:	d031      	beq.n	cc6 <idiv_divzero>
 c62:	2201      	movs	r2, #1
 c64:	07d2      	lsls	r2, r2, #31
 c66:	0903      	lsrs	r3, r0, #4
 c68:	e001      	b.n	c6e <div_search4a>

00000c6a <div_search4>:
 c6a:	0109      	lsls	r1, r1, #4
 c6c:	0912      	lsrs	r2, r2, #4

00000c6e <div_search4a>:
 c6e:	4299      	cmp	r1, r3
 c70:	d9fb      	bls.n	c6a <div_search4>
 c72:	0843      	lsrs	r3, r0, #1
 c74:	e001      	b.n	c7a <div_search1a>

00000c76 <div_search1>:
 c76:	0049      	lsls	r1, r1, #1
 c78:	0852      	lsrs	r2, r2, #1

00000c7a <div_search1a>:
 c7a:	4299      	cmp	r1, r3
 c7c:	d9fb      	bls.n	c76 <div_search1>
 c7e:	e000      	b.n	c82 <div_loop1a>

00000c80 <div_loop1>:
 c80:	0849      	lsrs	r1, r1, #1

00000c82 <div_loop1a>:
 c82:	1a40      	subs	r0, r0, r1
 c84:	d307      	bcc.n	c96 <div1>

00000c86 <div2>:
 c86:	4152      	adcs	r2, r2
 c88:	d3fa      	bcc.n	c80 <div_loop1>
 c8a:	4601      	mov	r1, r0
 c8c:	4610      	mov	r0, r2
 c8e:	4770      	bx	lr

00000c90 <div_loop2>:
 c90:	0849      	lsrs	r1, r1, #1
 c92:	1840      	adds	r0, r0, r1
 c94:	d2f7      	bcs.n	c86 <div2>

00000c96 <div1>:
 c96:	1892      	adds	r2, r2, r2
 c98:	d3fa      	bcc.n	c90 <div_loop2>
 c9a:	1840      	adds	r0, r0, r1
 c9c:	4601      	mov	r1, r0
 c9e:	4610      	mov	r0, r2
 ca0:	4770      	bx	lr

00000ca2 <idiv_negative>:
 ca2:	0fcb      	lsrs	r3, r1, #31
 ca4:	d000      	beq.n	ca8 <idiv_neg1>
 ca6:	4249      	negs	r1, r1

00000ca8 <idiv_neg1>:
 ca8:	1002      	asrs	r2, r0, #32
 caa:	d500      	bpl.n	cae <idiv_neg2>
 cac:	4240      	negs	r0, r0

00000cae <idiv_neg2>:
 cae:	4053      	eors	r3, r2
 cb0:	b508      	push	{r3, lr}
 cb2:	f7ff ffd4 	bl	c5e <__aeabi_uidiv>
 cb6:	bc0c      	pop	{r2, r3}

00000cb8 <idiv_sign>:
 cb8:	1052      	asrs	r2, r2, #1
 cba:	d300      	bcc.n	cbe <idiv_sign1>
 cbc:	4240      	negs	r0, r0

00000cbe <idiv_sign1>:
 cbe:	2a00      	cmp	r2, #0
 cc0:	d500      	bpl.n	cc4 <idiv_ret>
 cc2:	4249      	negs	r1, r1

00000cc4 <idiv_ret>:
 cc4:	4718      	bx	r3

00000cc6 <idiv_divzero>:
 cc6:	46f4      	mov	ip, lr
 cc8:	2000      	movs	r0, #0
 cca:	f000 f801 	bl	cd0 <__aeabi_idiv0>
 cce:	4760      	bx	ip

00000cd0 <__aeabi_idiv0>:
 cd0:	4770      	bx	lr
	...

00000cd4 <__aeabi_fdiv>:
 cd4:	b570      	push	{r4, r5, r6, lr}
 cd6:	0dc2      	lsrs	r2, r0, #23
 cd8:	24ff      	movs	r4, #255	; 0xff
 cda:	4022      	ands	r2, r4
 cdc:	d04b      	beq.n	d76 <__aeabi_fdiv+0xa2>
 cde:	42a2      	cmp	r2, r4
 ce0:	d049      	beq.n	d76 <__aeabi_fdiv+0xa2>
 ce2:	0dcb      	lsrs	r3, r1, #23
 ce4:	4023      	ands	r3, r4
 ce6:	d046      	beq.n	d76 <__aeabi_fdiv+0xa2>
 ce8:	42a3      	cmp	r3, r4
 cea:	d044      	beq.n	d76 <__aeabi_fdiv+0xa2>
 cec:	1c0e      	adds	r6, r1, #0
 cee:	2580      	movs	r5, #128	; 0x80
 cf0:	1ad4      	subs	r4, r2, r3
 cf2:	062d      	lsls	r5, r5, #24
 cf4:	020b      	lsls	r3, r1, #8
 cf6:	4046      	eors	r6, r0
 cf8:	0200      	lsls	r0, r0, #8
 cfa:	4328      	orrs	r0, r5
 cfc:	431d      	orrs	r5, r3
 cfe:	086b      	lsrs	r3, r5, #1
 d00:	3b01      	subs	r3, #1
 d02:	0842      	lsrs	r2, r0, #1
 d04:	429a      	cmp	r2, r3
 d06:	da02      	bge.n	d0e <__aeabi_fdiv+0x3a>
 d08:	1c21      	adds	r1, r4, #0
 d0a:	317d      	adds	r1, #125	; 0x7d
 d0c:	e002      	b.n	d14 <__aeabi_fdiv+0x40>
 d0e:	1c21      	adds	r1, r4, #0
 d10:	1052      	asrs	r2, r2, #1
 d12:	317e      	adds	r1, #126	; 0x7e
 d14:	0ff0      	lsrs	r0, r6, #31
 d16:	01c0      	lsls	r0, r0, #7
 d18:	0052      	lsls	r2, r2, #1
 d1a:	1ad4      	subs	r4, r2, r3
 d1c:	d400      	bmi.n	d20 <__aeabi_fdiv+0x4c>
 d1e:	1c22      	adds	r2, r4, #0
 d20:	0052      	lsls	r2, r2, #1
 d22:	1ad4      	subs	r4, r2, r3
 d24:	d400      	bmi.n	d28 <__aeabi_fdiv+0x54>
 d26:	1c22      	adds	r2, r4, #0
 d28:	0052      	lsls	r2, r2, #1
 d2a:	1ad4      	subs	r4, r2, r3
 d2c:	d400      	bmi.n	d30 <__aeabi_fdiv+0x5c>
 d2e:	1c22      	adds	r2, r4, #0
 d30:	0052      	lsls	r2, r2, #1
 d32:	1ad4      	subs	r4, r2, r3
 d34:	d400      	bmi.n	d38 <__aeabi_fdiv+0x64>
 d36:	1c22      	adds	r2, r4, #0
 d38:	0052      	lsls	r2, r2, #1
 d3a:	1ad4      	subs	r4, r2, r3
 d3c:	d400      	bmi.n	d40 <__aeabi_fdiv+0x6c>
 d3e:	1c22      	adds	r2, r4, #0
 d40:	0052      	lsls	r2, r2, #1
 d42:	1ad4      	subs	r4, r2, r3
 d44:	d400      	bmi.n	d48 <__aeabi_fdiv+0x74>
 d46:	1c22      	adds	r2, r4, #0
 d48:	0694      	lsls	r4, r2, #26
 d4a:	4320      	orrs	r0, r4
 d4c:	243f      	movs	r4, #63	; 0x3f
 d4e:	43a2      	bics	r2, r4
 d50:	241a      	movs	r4, #26
 d52:	41e0      	rors	r0, r4
 d54:	0204      	lsls	r4, r0, #8
 d56:	d5df      	bpl.n	d18 <__aeabi_fdiv+0x44>
 d58:	0052      	lsls	r2, r2, #1
 d5a:	1ad3      	subs	r3, r2, r3
 d5c:	43db      	mvns	r3, r3
 d5e:	0fdb      	lsrs	r3, r3, #31
 d60:	18c0      	adds	r0, r0, r3
 d62:	29fd      	cmp	r1, #253	; 0xfd
 d64:	d802      	bhi.n	d6c <__aeabi_fdiv+0x98>
 d66:	05c9      	lsls	r1, r1, #23
 d68:	1840      	adds	r0, r0, r1
 d6a:	e01f      	b.n	dac <__aeabi_fdiv+0xd8>
 d6c:	0fc0      	lsrs	r0, r0, #31
 d6e:	07c0      	lsls	r0, r0, #31
 d70:	2900      	cmp	r1, #0
 d72:	da14      	bge.n	d9e <__aeabi_fdiv+0xca>
 d74:	e01a      	b.n	dac <__aeabi_fdiv+0xd8>
 d76:	25ff      	movs	r5, #255	; 0xff
 d78:	0044      	lsls	r4, r0, #1
 d7a:	062d      	lsls	r5, r5, #24
 d7c:	42ac      	cmp	r4, r5
 d7e:	d814      	bhi.n	daa <__aeabi_fdiv+0xd6>
 d80:	004a      	lsls	r2, r1, #1
 d82:	42aa      	cmp	r2, r5
 d84:	d811      	bhi.n	daa <__aeabi_fdiv+0xd6>
 d86:	1c0b      	adds	r3, r1, #0
 d88:	4303      	orrs	r3, r0
 d8a:	005b      	lsls	r3, r3, #1
 d8c:	0e1b      	lsrs	r3, r3, #24
 d8e:	d00c      	beq.n	daa <__aeabi_fdiv+0xd6>
 d90:	4048      	eors	r0, r1
 d92:	0fc0      	lsrs	r0, r0, #31
 d94:	07c0      	lsls	r0, r0, #31
 d96:	0e23      	lsrs	r3, r4, #24
 d98:	d008      	beq.n	dac <__aeabi_fdiv+0xd8>
 d9a:	42aa      	cmp	r2, r5
 d9c:	d003      	beq.n	da6 <__aeabi_fdiv+0xd2>
 d9e:	23ff      	movs	r3, #255	; 0xff
 da0:	05db      	lsls	r3, r3, #23
 da2:	4318      	orrs	r0, r3
 da4:	e002      	b.n	dac <__aeabi_fdiv+0xd8>
 da6:	4294      	cmp	r4, r2
 da8:	d100      	bne.n	dac <__aeabi_fdiv+0xd8>
 daa:	4801      	ldr	r0, [pc, #4]	; (db0 <__aeabi_fdiv+0xdc>)
 dac:	bd70      	pop	{r4, r5, r6, pc}
 dae:	46c0      	nop			; (mov r8, r8)
 db0:	7fc00000 	.word	0x7fc00000

00000db4 <__aeabi_f2uiz>:
 db4:	2280      	movs	r2, #128	; 0x80
 db6:	0dc3      	lsrs	r3, r0, #23
 db8:	0201      	lsls	r1, r0, #8
 dba:	0612      	lsls	r2, r2, #24
 dbc:	209e      	movs	r0, #158	; 0x9e
 dbe:	4311      	orrs	r1, r2
 dc0:	1ac0      	subs	r0, r0, r3
 dc2:	d402      	bmi.n	dca <__aeabi_f2uiz+0x16>
 dc4:	40c1      	lsrs	r1, r0
 dc6:	1c08      	adds	r0, r1, #0
 dc8:	e006      	b.n	dd8 <__aeabi_f2uiz+0x24>
 dca:	2bfe      	cmp	r3, #254	; 0xfe
 dcc:	d902      	bls.n	dd4 <__aeabi_f2uiz+0x20>
 dce:	2000      	movs	r0, #0
 dd0:	4291      	cmp	r1, r2
 dd2:	d101      	bne.n	dd8 <__aeabi_f2uiz+0x24>
 dd4:	0a18      	lsrs	r0, r3, #8
 dd6:	3801      	subs	r0, #1
 dd8:	4770      	bx	lr

00000dda <__bhs_ui2f>:
 dda:	2800      	cmp	r0, #0
 ddc:	d02b      	beq.n	e36 <__bhs_ui2f+0x5c>
 dde:	0c03      	lsrs	r3, r0, #16
 de0:	d101      	bne.n	de6 <__bhs_ui2f+0xc>
 de2:	0400      	lsls	r0, r0, #16
 de4:	e002      	b.n	dec <__bhs_ui2f+0x12>
 de6:	2380      	movs	r3, #128	; 0x80
 de8:	051b      	lsls	r3, r3, #20
 dea:	18c9      	adds	r1, r1, r3
 dec:	0e03      	lsrs	r3, r0, #24
 dee:	d101      	bne.n	df4 <__bhs_ui2f+0x1a>
 df0:	0200      	lsls	r0, r0, #8
 df2:	e002      	b.n	dfa <__bhs_ui2f+0x20>
 df4:	2380      	movs	r3, #128	; 0x80
 df6:	04db      	lsls	r3, r3, #19
 df8:	18c9      	adds	r1, r1, r3
 dfa:	0f03      	lsrs	r3, r0, #28
 dfc:	d101      	bne.n	e02 <__bhs_ui2f+0x28>
 dfe:	0100      	lsls	r0, r0, #4
 e00:	e002      	b.n	e08 <__bhs_ui2f+0x2e>
 e02:	2380      	movs	r3, #128	; 0x80
 e04:	049b      	lsls	r3, r3, #18
 e06:	18c9      	adds	r1, r1, r3
 e08:	0f83      	lsrs	r3, r0, #30
 e0a:	d101      	bne.n	e10 <__bhs_ui2f+0x36>
 e0c:	0080      	lsls	r0, r0, #2
 e0e:	e002      	b.n	e16 <__bhs_ui2f+0x3c>
 e10:	2380      	movs	r3, #128	; 0x80
 e12:	045b      	lsls	r3, r3, #17
 e14:	18c9      	adds	r1, r1, r3
 e16:	2800      	cmp	r0, #0
 e18:	db01      	blt.n	e1e <__bhs_ui2f+0x44>
 e1a:	0040      	lsls	r0, r0, #1
 e1c:	e002      	b.n	e24 <__bhs_ui2f+0x4a>
 e1e:	2380      	movs	r3, #128	; 0x80
 e20:	041b      	lsls	r3, r3, #16
 e22:	18c9      	adds	r1, r1, r3
 e24:	3080      	adds	r0, #128	; 0x80
 e26:	1203      	asrs	r3, r0, #8
 e28:	1859      	adds	r1, r3, r1
 e2a:	0600      	lsls	r0, r0, #24
 e2c:	d101      	bne.n	e32 <__bhs_ui2f+0x58>
 e2e:	2301      	movs	r3, #1
 e30:	4399      	bics	r1, r3
 e32:	1c08      	adds	r0, r1, #0
 e34:	e000      	b.n	e38 <__bhs_ui2f+0x5e>
 e36:	2000      	movs	r0, #0
 e38:	4770      	bx	lr

00000e3a <__aeabi_ui2f>:
 e3a:	b508      	push	{r3, lr}
 e3c:	2180      	movs	r1, #128	; 0x80
 e3e:	05c9      	lsls	r1, r1, #23
 e40:	f7ff ffcb 	bl	dda <__bhs_ui2f>
 e44:	bd08      	pop	{r3, pc}

00000e46 <__aeabi_memcpy>:
 e46:	4684      	mov	ip, r0
 e48:	0783      	lsls	r3, r0, #30
 e4a:	d108      	bne.n	e5e <copy1_start>
 e4c:	078b      	lsls	r3, r1, #30
 e4e:	d106      	bne.n	e5e <copy1_start>
 e50:	1f13      	subs	r3, r2, #4
 e52:	d304      	bcc.n	e5e <copy1_start>

00000e54 <copy4>:
 e54:	c904      	ldmia	r1!, {r2}
 e56:	c004      	stmia	r0!, {r2}
 e58:	3b04      	subs	r3, #4
 e5a:	d2fb      	bcs.n	e54 <copy4>
 e5c:	1d1a      	adds	r2, r3, #4

00000e5e <copy1_start>:
 e5e:	4252      	negs	r2, r2
 e60:	d005      	beq.n	e6e <copy1_ret>
 e62:	1a89      	subs	r1, r1, r2
 e64:	1a80      	subs	r0, r0, r2

00000e66 <copy1>:
 e66:	5c8b      	ldrb	r3, [r1, r2]
 e68:	5483      	strb	r3, [r0, r2]
 e6a:	3201      	adds	r2, #1
 e6c:	d1fb      	bne.n	e66 <copy1>

00000e6e <copy1_ret>:
 e6e:	4660      	mov	r0, ip
 e70:	4770      	bx	lr

00000e72 <MIDIto30MhzReload>:
 e72:	0dfe 0d35 0c77 0bc4 0b1b 0a7c 09e5 0957     ..5.w.....|...W.
 e82:	08d0 0852 07da 0769 06ff 069a 063b 05e2     ..R...i.....;...
 e92:	058d 053d 04f2 04ab 0468 0428 03ed 03b4     ..=.....h.(.....
 ea2:	037f 034d 031d 02f0 02c6 029e 0278 0255     ..M.........x.U.
 eb2:	0233 0214 01f6 01da 01bf 01a6 018e 0178     3.............x.
 ec2:	0163 014f 013c 012a 0119 0109 00fa 00ec     c.O.<.*.........
 ed2:	00df 00d2 00c7 00bb 00b1 00a7 009d 0094     ................
 ee2:	008c 0084 007d 0076 006f 0069 0063 005d     ....}.v.o.i.c.].
 ef2:	0058 0053 004e 004a 0000                    X.S.N.J...

00000efc <OscRateIn>:
 efc:	1b00 00b7                                   ....

00000f00 <ExtRateIn>:
 f00:	0000 0000                                   ....

00000f04 <wdtOSCRate>:
 f04:	0000 0000 27c0 0009 0590 0010 5cc0 0015     .....'.......\..
 f14:	b3f0 001a 0b20 0020 9f00 0024 32e0 0029     .... . ...$..2).
 f24:	c6c0 002d 9750 0031 67e0 0035 3870 0039     ..-.P.1..g5.p89.
 f34:	0900 003d 1640 0040 2380 0043 30c0 0046     ..=.@.@..#C..0F.
