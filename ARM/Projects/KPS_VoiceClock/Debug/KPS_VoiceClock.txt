
KPS_VoiceClock.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 04 00 10 03 01 00 00 d5 00 00 00 d7 00 00 00     ................
	...
  2c:	d9 00 00 00 00 00 00 00 00 00 00 00 db 00 00 00     ................
  3c:	dd 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  4c:	55 07 00 00 df 00 00 00 df 00 00 00 00 00 00 00     U...............
  5c:	00 00 00 00 df 00 00 00 1d 04 00 00 df 00 00 00     ................
  6c:	df 00 00 00 df 00 00 00 df 00 00 00 00 00 00 00     ................
  7c:	df 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................
  b0:	df 00 00 00 df 00 00 00 df 00 00 00 df 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000f3c 	.word	0x00000f3c
  c4:	10000100 	.word	0x10000100
  c8:	00000018 	.word	0x00000018

000000cc <__bss_section_table>:
  cc:	10000118 	.word	0x10000118
  d0:	0000003c 	.word	0x0000003c

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>

000000d6 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d6:	e7fe      	b.n	d6 <HardFault_Handler>

000000d8 <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  d8:	e7fe      	b.n	d8 <SVC_Handler>

000000da <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  da:	e7fe      	b.n	da <PendSV_Handler>

000000dc <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  dc:	e7fe      	b.n	dc <SysTick_Handler>

000000de <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  de:	e7fe      	b.n	de <BOD_IRQHandler>

000000e0 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
  e0:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  e2:	2300      	movs	r3, #0
  e4:	4293      	cmp	r3, r2
  e6:	d203      	bcs.n	f0 <data_init+0x10>
        *pulDest++ = *pulSrc++;
  e8:	581c      	ldr	r4, [r3, r0]
  ea:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  ec:	3304      	adds	r3, #4
  ee:	e7f9      	b.n	e4 <data_init+0x4>
        *pulDest++ = *pulSrc++;
}
  f0:	bd10      	pop	{r4, pc}

000000f2 <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  f2:	2300      	movs	r3, #0
  f4:	428b      	cmp	r3, r1
  f6:	d203      	bcs.n	100 <bss_init+0xe>
        *pulDest++ = 0;
  f8:	2200      	movs	r2, #0
  fa:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
  fc:	3304      	adds	r3, #4
  fe:	e7f9      	b.n	f4 <bss_init+0x2>
        *pulDest++ = 0;
}
 100:	4770      	bx	lr

00000102 <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
 102:	b510      	push	{r4, lr}
    //
    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;
 104:	4c0c      	ldr	r4, [pc, #48]	; (138 <ResetISR+0x36>)

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 106:	4b0d      	ldr	r3, [pc, #52]	; (13c <ResetISR+0x3a>)
 108:	429c      	cmp	r4, r3
 10a:	d207      	bcs.n	11c <ResetISR+0x1a>
        LoadAddr = *SectionTableAddr++;
 10c:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
 10e:	6861      	ldr	r1, [r4, #4]
 110:	340c      	adds	r4, #12
 112:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
 114:	681a      	ldr	r2, [r3, #0]
 116:	f7ff ffe3 	bl	e0 <data_init>
 11a:	e7f4      	b.n	106 <ResetISR+0x4>
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 11c:	4b08      	ldr	r3, [pc, #32]	; (140 <ResetISR+0x3e>)
 11e:	429c      	cmp	r4, r3
 120:	d205      	bcs.n	12e <ResetISR+0x2c>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
 122:	6820      	ldr	r0, [r4, #0]
 124:	6861      	ldr	r1, [r4, #4]
 126:	f7ff ffe4 	bl	f2 <bss_init>
 12a:	3408      	adds	r4, #8
 12c:	e7f6      	b.n	11c <ResetISR+0x1a>
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 12e:	f000 f981 	bl	434 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 132:	f000 fd89 	bl	c48 <__weak_main>
 136:	e7fe      	b.n	136 <ResetISR+0x34>
 138:	000000c0 	.word	0x000000c0
 13c:	000000cc 	.word	0x000000cc
 140:	000000d4 	.word	0x000000d4
 144:	ffffffff 	.word	0xffffffff
 148:	ffffffff 	.word	0xffffffff
 14c:	ffffffff 	.word	0xffffffff
 150:	ffffffff 	.word	0xffffffff
 154:	ffffffff 	.word	0xffffffff
 158:	ffffffff 	.word	0xffffffff
 15c:	ffffffff 	.word	0xffffffff
 160:	ffffffff 	.word	0xffffffff
 164:	ffffffff 	.word	0xffffffff
 168:	ffffffff 	.word	0xffffffff
 16c:	ffffffff 	.word	0xffffffff
 170:	ffffffff 	.word	0xffffffff
 174:	ffffffff 	.word	0xffffffff
 178:	ffffffff 	.word	0xffffffff
 17c:	ffffffff 	.word	0xffffffff
 180:	ffffffff 	.word	0xffffffff
 184:	ffffffff 	.word	0xffffffff
 188:	ffffffff 	.word	0xffffffff
 18c:	ffffffff 	.word	0xffffffff
 190:	ffffffff 	.word	0xffffffff
 194:	ffffffff 	.word	0xffffffff
 198:	ffffffff 	.word	0xffffffff
 19c:	ffffffff 	.word	0xffffffff
 1a0:	ffffffff 	.word	0xffffffff
 1a4:	ffffffff 	.word	0xffffffff
 1a8:	ffffffff 	.word	0xffffffff
 1ac:	ffffffff 	.word	0xffffffff
 1b0:	ffffffff 	.word	0xffffffff
 1b4:	ffffffff 	.word	0xffffffff
 1b8:	ffffffff 	.word	0xffffffff
 1bc:	ffffffff 	.word	0xffffffff
 1c0:	ffffffff 	.word	0xffffffff
 1c4:	ffffffff 	.word	0xffffffff
 1c8:	ffffffff 	.word	0xffffffff
 1cc:	ffffffff 	.word	0xffffffff
 1d0:	ffffffff 	.word	0xffffffff
 1d4:	ffffffff 	.word	0xffffffff
 1d8:	ffffffff 	.word	0xffffffff
 1dc:	ffffffff 	.word	0xffffffff
 1e0:	ffffffff 	.word	0xffffffff
 1e4:	ffffffff 	.word	0xffffffff
 1e8:	ffffffff 	.word	0xffffffff
 1ec:	ffffffff 	.word	0xffffffff
 1f0:	ffffffff 	.word	0xffffffff
 1f4:	ffffffff 	.word	0xffffffff
 1f8:	ffffffff 	.word	0xffffffff
 1fc:	ffffffff 	.word	0xffffffff
 200:	ffffffff 	.word	0xffffffff
 204:	ffffffff 	.word	0xffffffff
 208:	ffffffff 	.word	0xffffffff
 20c:	ffffffff 	.word	0xffffffff
 210:	ffffffff 	.word	0xffffffff
 214:	ffffffff 	.word	0xffffffff
 218:	ffffffff 	.word	0xffffffff
 21c:	ffffffff 	.word	0xffffffff
 220:	ffffffff 	.word	0xffffffff
 224:	ffffffff 	.word	0xffffffff
 228:	ffffffff 	.word	0xffffffff
 22c:	ffffffff 	.word	0xffffffff
 230:	ffffffff 	.word	0xffffffff
 234:	ffffffff 	.word	0xffffffff
 238:	ffffffff 	.word	0xffffffff
 23c:	ffffffff 	.word	0xffffffff
 240:	ffffffff 	.word	0xffffffff
 244:	ffffffff 	.word	0xffffffff
 248:	ffffffff 	.word	0xffffffff
 24c:	ffffffff 	.word	0xffffffff
 250:	ffffffff 	.word	0xffffffff
 254:	ffffffff 	.word	0xffffffff
 258:	ffffffff 	.word	0xffffffff
 25c:	ffffffff 	.word	0xffffffff
 260:	ffffffff 	.word	0xffffffff
 264:	ffffffff 	.word	0xffffffff
 268:	ffffffff 	.word	0xffffffff
 26c:	ffffffff 	.word	0xffffffff
 270:	ffffffff 	.word	0xffffffff
 274:	ffffffff 	.word	0xffffffff
 278:	ffffffff 	.word	0xffffffff
 27c:	ffffffff 	.word	0xffffffff
 280:	ffffffff 	.word	0xffffffff
 284:	ffffffff 	.word	0xffffffff
 288:	ffffffff 	.word	0xffffffff
 28c:	ffffffff 	.word	0xffffffff
 290:	ffffffff 	.word	0xffffffff
 294:	ffffffff 	.word	0xffffffff
 298:	ffffffff 	.word	0xffffffff
 29c:	ffffffff 	.word	0xffffffff
 2a0:	ffffffff 	.word	0xffffffff
 2a4:	ffffffff 	.word	0xffffffff
 2a8:	ffffffff 	.word	0xffffffff
 2ac:	ffffffff 	.word	0xffffffff
 2b0:	ffffffff 	.word	0xffffffff
 2b4:	ffffffff 	.word	0xffffffff
 2b8:	ffffffff 	.word	0xffffffff
 2bc:	ffffffff 	.word	0xffffffff
 2c0:	ffffffff 	.word	0xffffffff
 2c4:	ffffffff 	.word	0xffffffff
 2c8:	ffffffff 	.word	0xffffffff
 2cc:	ffffffff 	.word	0xffffffff
 2d0:	ffffffff 	.word	0xffffffff
 2d4:	ffffffff 	.word	0xffffffff
 2d8:	ffffffff 	.word	0xffffffff
 2dc:	ffffffff 	.word	0xffffffff
 2e0:	ffffffff 	.word	0xffffffff
 2e4:	ffffffff 	.word	0xffffffff
 2e8:	ffffffff 	.word	0xffffffff
 2ec:	ffffffff 	.word	0xffffffff
 2f0:	ffffffff 	.word	0xffffffff
 2f4:	ffffffff 	.word	0xffffffff
 2f8:	ffffffff 	.word	0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffffffff                                ....

00000300 <main>:

/********************************************************************************************************
 * 											MAIN														*
 *******************************************************************************************************/
int main(void)
{
 300:	b530      	push	{r4, r5, lr}
 302:	b087      	sub	sp, #28
	// Standard boot procedure
	CoreClockInit_30Hz();
 304:	f000 f98a 	bl	61c <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 308:	4b32      	ldr	r3, [pc, #200]	; (3d4 <main+0xd4>)
 30a:	2280      	movs	r2, #128	; 0x80
 30c:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 30e:	0052      	lsls	r2, r2, #1
 310:	430a      	orrs	r2, r1
 312:	67da      	str	r2, [r3, #124]	; 0x7c
 314:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 316:	2280      	movs	r2, #128	; 0x80
 318:	01d2      	lsls	r2, r2, #7
 31a:	430a      	orrs	r2, r1
 31c:	67da      	str	r2, [r3, #124]	; 0x7c
 31e:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 320:	2280      	movs	r2, #128	; 0x80
 322:	0112      	lsls	r2, r2, #4
 324:	430a      	orrs	r2, r1
 326:	67da      	str	r2, [r3, #124]	; 0x7c
 328:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 32a:	2180      	movs	r1, #128	; 0x80
 32c:	430a      	orrs	r2, r1
 32e:	67da      	str	r2, [r3, #124]	; 0x7c
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 330:	4829      	ldr	r0, [pc, #164]	; (3d8 <main+0xd8>)
 332:	4a2a      	ldr	r2, [pc, #168]	; (3dc <main+0xdc>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 334:	2401      	movs	r4, #1
	// Ready To assign Pinouts
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
 336:	6010      	str	r0, [r2, #0]
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 338:	4829      	ldr	r0, [pc, #164]	; (3e0 <main+0xe0>)
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 33a:	4264      	negs	r4, r4

    /* Pin Assign 8 bit Configuration */
    /* U0_RXD */
    LPC_SWM->PINASSIGN[0] = 0xffff00ffUL;
    /* SPI0_SCK */
    LPC_SWM->PINASSIGN[3] = 0x05ffffffUL;
 33c:	60d0      	str	r0, [r2, #12]
    /* SPI0_MOSI */
    /* SPI0_SSEL */
    LPC_SWM->PINASSIGN[4] = 0xff03ff04UL;
 33e:	4829      	ldr	r0, [pc, #164]	; (3e4 <main+0xe4>)
 340:	6110      	str	r0, [r2, #16]
    /* CTOUT_0 */
    LPC_SWM->PINASSIGN[6] = 0x02ffffffUL;
 342:	4829      	ldr	r0, [pc, #164]	; (3e8 <main+0xe8>)
 344:	6190      	str	r0, [r2, #24]

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 346:	20e0      	movs	r0, #224	; 0xe0
 348:	0040      	lsls	r0, r0, #1
 34a:	5014      	str	r4, [r2, r0]
 * @param	clk	: Clock to disable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL &= ~(1 << clk);
 34c:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 34e:	438a      	bics	r2, r1
 350:	67da      	str	r2, [r3, #124]	; 0x7c

	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);
	/*END OF PIN ASSIGNMENTS*/

	// Configure the SPI to use TLC DAC settings
	TLC_Init();
 352:	f000 fa09 	bl	768 <TLC_Init>
//	Chip_ACMP_EnableVoltLadder(LPC_CMP);
//	Chip_ACMP_SetupVoltLadder(LPC_CMP, 0, FALSE);
//	ACMP_Status = Chip_ACMP_GetCompStatus(LPC_CMP);

	// Initialize the frequency generation timer
	WaveGenInit(&Generator1, 200);
 356:	4c25      	ldr	r4, [pc, #148]	; (3ec <main+0xec>)
 358:	4925      	ldr	r1, [pc, #148]	; (3f0 <main+0xf0>)
 35a:	1c20      	adds	r0, r4, #0
 35c:	f000 fa6a 	bl	834 <WaveGenInit>
	WaveGenStart(&Generator1);
 360:	1c20      	adds	r0, r4, #0
 362:	f000 fa35 	bl	7d0 <WaveGenStart>

	// Initialize the envelope
	envLinADSR_t envelope;
	SetEnvelopeTimes(&envelope, TRANSIENT_LENGTH, PULSE_LENGTH, SUSTAIN, RELEASE);
 366:	4b23      	ldr	r3, [pc, #140]	; (3f4 <main+0xf4>)
 368:	2296      	movs	r2, #150	; 0x96
 36a:	0052      	lsls	r2, r2, #1
 36c:	9300      	str	r3, [sp, #0]
 36e:	a802      	add	r0, sp, #8
 370:	2332      	movs	r3, #50	; 0x32
 372:	2100      	movs	r1, #0
 374:	f000 f884 	bl	480 <SetEnvelopeTimes>

    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
 378:	481f      	ldr	r0, [pc, #124]	; (3f8 <main+0xf8>)
 37a:	2102      	movs	r1, #2
 37c:	f000 f96c 	bl	658 <MIDI_USARTInit>
	MIDI_SetAddress(LOCAL_ADDRESS);
 380:	2000      	movs	r0, #0
 382:	f000 f995 	bl	6b0 <MIDI_SetAddress>

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 386:	4a1d      	ldr	r2, [pc, #116]	; (3fc <main+0xfc>)
 388:	4b1d      	ldr	r3, [pc, #116]	; (400 <main+0x100>)
	MIDI_NoteOffFunc = &MIDI_NoteOff;

	MIDI_Enable(LPC_USART0);
 38a:	481b      	ldr	r0, [pc, #108]	; (3f8 <main+0xf8>)
    // Configure the USART to Use MIDI protocol
	MIDI_USARTInit(LPC_USART0, MIDI_ENABLERX);
	MIDI_SetAddress(LOCAL_ADDRESS);

	// Assign note on and off functions
	MIDI_NoteOnFunc = &MIDI_NoteOn;
 38c:	601a      	str	r2, [r3, #0]
	MIDI_NoteOffFunc = &MIDI_NoteOff;
 38e:	4a1d      	ldr	r2, [pc, #116]	; (404 <main+0x104>)
 390:	4b1d      	ldr	r3, [pc, #116]	; (408 <main+0x108>)
 392:	601a      	str	r2, [r3, #0]

	MIDI_Enable(LPC_USART0);
 394:	f000 f992 	bl	6bc <MIDI_Enable>

/////////////////////////////////////////////MAINLOOP.////////////////////////////////////////////////////
	while (1) {
		// Check if we've received any data
		MIDI_ProcessRXBuffer();
 398:	f000 f996 	bl	6c8 <MIDI_ProcessRXBuffer>

		// If the timer has requested a sample, we need to generate any data from a pulse, do so.
		if (triggered != 0)
 39c:	4d1b      	ldr	r5, [pc, #108]	; (40c <main+0x10c>)
 39e:	782b      	ldrb	r3, [r5, #0]
 3a0:	2b00      	cmp	r3, #0
 3a2:	d0f9      	beq.n	398 <main+0x98>
		{
			//Hard Stop at Max.
			if (EnvPosition < 0)
 3a4:	4c1a      	ldr	r4, [pc, #104]	; (410 <main+0x110>)
 3a6:	6823      	ldr	r3, [r4, #0]
 3a8:	2b00      	cmp	r3, #0
 3aa:	da01      	bge.n	3b0 <main+0xb0>
			{
				EnvPosition = INT32_MAX;
 3ac:	4b19      	ldr	r3, [pc, #100]	; (414 <main+0x114>)
 3ae:	6023      	str	r3, [r4, #0]
			}

			// Generate the sound
			if (activeNote == -1)
 3b0:	4b19      	ldr	r3, [pc, #100]	; (418 <main+0x118>)
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 3b2:	a802      	add	r0, sp, #8
			{
				EnvPosition = INT32_MAX;
			}

			// Generate the sound
			if (activeNote == -1)
 3b4:	781b      	ldrb	r3, [r3, #0]
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 3b6:	6821      	ldr	r1, [r4, #0]
			{
				EnvPosition = INT32_MAX;
			}

			// Generate the sound
			if (activeNote == -1)
 3b8:	b25b      	sxtb	r3, r3
 3ba:	3301      	adds	r3, #1
 3bc:	d102      	bne.n	3c4 <main+0xc4>
			{
				GenPluckBow_NoteOff(&envelope, EnvPosition);
 3be:	f000 f891 	bl	4e4 <GenPluckBow_NoteOff>
 3c2:	e001      	b.n	3c8 <main+0xc8>
			}
			else
			{
				GenPluckBow(&envelope, EnvPosition);
 3c4:	f000 f864 	bl	490 <GenPluckBow>
			}

			// Clear the triggered variable
			triggered = 0;
 3c8:	2300      	movs	r3, #0
 3ca:	702b      	strb	r3, [r5, #0]

			// Advance the Envelope Position
			EnvPosition++;
 3cc:	6823      	ldr	r3, [r4, #0]
 3ce:	3301      	adds	r3, #1
 3d0:	6023      	str	r3, [r4, #0]
 3d2:	e7e1      	b.n	398 <main+0x98>
 3d4:	40048004 	.word	0x40048004
 3d8:	ffff00ff 	.word	0xffff00ff
 3dc:	4000c000 	.word	0x4000c000
 3e0:	05ffffff 	.word	0x05ffffff
 3e4:	ff03ff04 	.word	0xff03ff04
 3e8:	02ffffff 	.word	0x02ffffff
 3ec:	10000108 	.word	0x10000108
 3f0:	43480000 	.word	0x43480000
 3f4:	00002710 	.word	0x00002710
 3f8:	40064000 	.word	0x40064000
 3fc:	00000541 	.word	0x00000541
 400:	1000012c 	.word	0x1000012c
 404:	000005ed 	.word	0x000005ed
 408:	10000128 	.word	0x10000128
 40c:	10000118 	.word	0x10000118
 410:	1000011c 	.word	0x1000011c
 414:	7fffffff 	.word	0x7fffffff
 418:	10000106 	.word	0x10000106

0000041c <SCT_IRQHandler>:
/********************************************************************************************************
 * 										Functions														*
 *******************************************************************************************************/
void SCT_IRQHandler(void)
{
	triggered = 1;
 41c:	4b03      	ldr	r3, [pc, #12]	; (42c <SCT_IRQHandler+0x10>)
 41e:	2201      	movs	r2, #1
 420:	701a      	strb	r2, [r3, #0]
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVFLAG |= evt;
 422:	4b03      	ldr	r3, [pc, #12]	; (430 <SCT_IRQHandler+0x14>)
 424:	6819      	ldr	r1, [r3, #0]
 426:	430a      	orrs	r2, r1
 428:	601a      	str	r2, [r3, #0]
	// reset the interrupt flag
	Chip_SCT_ClearEventFlag(LPC_SCT, SCT_EVT_0);
}
 42a:	4770      	bx	lr
 42c:	10000118 	.word	0x10000118
 430:	500040f4 	.word	0x500040f4

00000434 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 434:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 436:	f000 fb77 	bl	b28 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 43a:	bd08      	pop	{r3, pc}

0000043c <GenLinADS>:

#include "BAP_Envelope.h"
#include "BAP_math.h"

uint32_t GenLinADS(envLinADSR_t* env, uint32_t pos)
{
 43c:	b513      	push	{r0, r1, r4, lr}
 43e:	1c0a      	adds	r2, r1, #0

	// Attack
	if (pos < env->atk){
 440:	6801      	ldr	r1, [r0, #0]
 442:	428a      	cmp	r2, r1
 444:	d204      	bcs.n	450 <GenLinADS+0x14>
		return i_lscale(0, env->atk, 0, ENVAMP_MAX, pos);
 446:	2000      	movs	r0, #0
 448:	9200      	str	r2, [sp, #0]
 44a:	237f      	movs	r3, #127	; 0x7f
 44c:	1c02      	adds	r2, r0, #0
 44e:	e007      	b.n	460 <GenLinADS+0x24>
	}

	// Decay
	else if ((pos <= env->dk) && (pos >= env->atk)){
 450:	6844      	ldr	r4, [r0, #4]
 452:	6883      	ldr	r3, [r0, #8]
 454:	42a2      	cmp	r2, r4
 456:	d806      	bhi.n	466 <GenLinADS+0x2a>
		return i_lscale(env->atk, env->dk, ENVAMP_MAX, env->sus, pos);
 458:	9200      	str	r2, [sp, #0]
 45a:	1c08      	adds	r0, r1, #0
 45c:	227f      	movs	r2, #127	; 0x7f
 45e:	1c21      	adds	r1, r4, #0
 460:	f000 fa38 	bl	8d4 <i_lscale>
 464:	1c03      	adds	r3, r0, #0
	}

	// Sustain
	return env->sus;
}
 466:	1c18      	adds	r0, r3, #0
 468:	bd16      	pop	{r1, r2, r4, pc}

0000046a <GenLinRelease>:

uint32_t GenLinRelease (envLinADSR_t* env, uint32_t pos)
{
 46a:	b513      	push	{r0, r1, r4, lr}
 46c:	1c03      	adds	r3, r0, #0
 46e:	1c0c      	adds	r4, r1, #0
	return i_lscale(env->dk, env->rls, env->sus, ENVAMP_MIN, pos);
 470:	689a      	ldr	r2, [r3, #8]
 472:	68d9      	ldr	r1, [r3, #12]
 474:	6840      	ldr	r0, [r0, #4]
 476:	2300      	movs	r3, #0
 478:	9400      	str	r4, [sp, #0]
 47a:	f000 fa2b 	bl	8d4 <i_lscale>
}
 47e:	bd16      	pop	{r1, r2, r4, pc}

00000480 <SetEnvelopeTimes>:
void SetEnvelopeTimes(envLinADSR_t* env, uint32_t atk, uint32_t dk, uint32_t sus, uint32_t rls)
{
	env->atk = atk;
	//shift all times to associate with a global time.
	env->dk = dk += atk;
	env->sus = sus;
 480:	6083      	str	r3, [r0, #8]
	env->rls = rls += dk;
 482:	9b00      	ldr	r3, [sp, #0]
	return i_lscale(env->dk, env->rls, env->sus, ENVAMP_MIN, pos);
}

void SetEnvelopeTimes(envLinADSR_t* env, uint32_t atk, uint32_t dk, uint32_t sus, uint32_t rls)
{
	env->atk = atk;
 484:	6001      	str	r1, [r0, #0]
	//shift all times to associate with a global time.
	env->dk = dk += atk;
 486:	1889      	adds	r1, r1, r2
 488:	6041      	str	r1, [r0, #4]
	env->sus = sus;
	env->rls = rls += dk;
 48a:	18c9      	adds	r1, r1, r3
 48c:	60c1      	str	r1, [r0, #12]
}
 48e:	4770      	bx	lr

00000490 <GenPluckBow>:

#include "KPS_Exciter.h"
#include "BAP_math.h"

void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
 490:	b530      	push	{r4, r5, lr}
	if (Position < Envelope->dk || Envelope->sus != 0)
 492:	6843      	ldr	r3, [r0, #4]

#include "KPS_Exciter.h"
#include "BAP_math.h"

void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
 494:	b085      	sub	sp, #20
	if (Position < Envelope->dk || Envelope->sus != 0)
 496:	4299      	cmp	r1, r3
 498:	d302      	bcc.n	4a0 <GenPluckBow+0x10>
 49a:	6883      	ldr	r3, [r0, #8]
 49c:	2b00      	cmp	r3, #0
 49e:	d01d      	beq.n	4dc <GenPluckBow+0x4c>
	{
		int32_t envVal = GenLinADS(Envelope, Position);
 4a0:	f7ff ffcc 	bl	43c <GenLinADS>
 4a4:	1c05      	adds	r5, r0, #0
		int32_t noise = LFSR() & 0x7F;
 4a6:	f000 fa25 	bl	8f4 <LFSR>
 4aa:	247f      	movs	r4, #127	; 0x7f
		//{
		//	noise = (uint8_t) envVal;
		//}

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 4ac:	4b0c      	ldr	r3, [pc, #48]	; (4e0 <GenPluckBow+0x50>)
void GenPluckBow(envLinADSR_t* Envelope, uint32_t Position)
{
	if (Position < Envelope->dk || Envelope->sus != 0)
	{
		int32_t envVal = GenLinADS(Envelope, Position);
		int32_t noise = LFSR() & 0x7F;
 4ae:	4020      	ands	r0, r4
		//{
		//	noise = (uint8_t) envVal;
		//}

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 4b0:	781b      	ldrb	r3, [r3, #0]
 4b2:	9000      	str	r0, [sp, #0]
 4b4:	2000      	movs	r0, #0
 4b6:	1c21      	adds	r1, r4, #0
 4b8:	1c02      	adds	r2, r0, #0
 4ba:	f000 fa0b 	bl	8d4 <i_lscale>
		noise = i_lscale(0,127, 0, envVal, noise);
 4be:	9000      	str	r0, [sp, #0]
 4c0:	2000      	movs	r0, #0
 4c2:	1c21      	adds	r1, r4, #0
 4c4:	1c02      	adds	r2, r0, #0
 4c6:	1c2b      	adds	r3, r5, #0
 4c8:	f000 fa04 	bl	8d4 <i_lscale>

		// Set bias to be 1/2 available range
		noise = 127 + noise;
		uint8_t output = noise;
 4cc:	466a      	mov	r2, sp
		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
		noise = i_lscale(0,127, 0, envVal, noise);

		// Set bias to be 1/2 available range
		noise = 127 + noise;
 4ce:	1900      	adds	r0, r0, r4
		uint8_t output = noise;
 4d0:	320f      	adds	r2, #15
 4d2:	7010      	strb	r0, [r2, #0]
		TLC_SetDACValue(PulseDAC, 1, &output);
 4d4:	2101      	movs	r1, #1
 4d6:	2003      	movs	r0, #3
 4d8:	f000 f968 	bl	7ac <TLC_SetDACValue>
	}
}
 4dc:	b005      	add	sp, #20
 4de:	bd30      	pop	{r4, r5, pc}
 4e0:	10000120 	.word	0x10000120

000004e4 <GenPluckBow_NoteOff>:

void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
 4e4:	b530      	push	{r4, r5, lr}
	if (Position <= (Envelope->rls - Envelope->dk) && Envelope->sus != 0)
 4e6:	6843      	ldr	r3, [r0, #4]
 4e8:	68c4      	ldr	r4, [r0, #12]
		TLC_SetDACValue(PulseDAC, 1, &output);
	}
}

void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
 4ea:	b085      	sub	sp, #20
	if (Position <= (Envelope->rls - Envelope->dk) && Envelope->sus != 0)
 4ec:	1ae2      	subs	r2, r4, r3
 4ee:	4291      	cmp	r1, r2
 4f0:	d821      	bhi.n	536 <GenPluckBow_NoteOff+0x52>
 4f2:	6882      	ldr	r2, [r0, #8]
 4f4:	2a00      	cmp	r2, #0
 4f6:	d01e      	beq.n	536 <GenPluckBow_NoteOff+0x52>
	{
		int32_t envVal = GenLinRelease(Envelope, Position + Envelope->dk);
 4f8:	18c9      	adds	r1, r1, r3
 4fa:	f7ff ffb6 	bl	46a <GenLinRelease>
 4fe:	1c05      	adds	r5, r0, #0
		int32_t noise = LFSR() & 0x7F;
 500:	f000 f9f8 	bl	8f4 <LFSR>
 504:	247f      	movs	r4, #127	; 0x7f

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 506:	4b0d      	ldr	r3, [pc, #52]	; (53c <GenPluckBow_NoteOff+0x58>)
void GenPluckBow_NoteOff(envLinADSR_t* Envelope, int32_t Position)
{
	if (Position <= (Envelope->rls - Envelope->dk) && Envelope->sus != 0)
	{
		int32_t envVal = GenLinRelease(Envelope, Position + Envelope->dk);
		int32_t noise = LFSR() & 0x7F;
 508:	4020      	ands	r0, r4

		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
 50a:	781b      	ldrb	r3, [r3, #0]
 50c:	9000      	str	r0, [sp, #0]
 50e:	2000      	movs	r0, #0
 510:	1c21      	adds	r1, r4, #0
 512:	1c02      	adds	r2, r0, #0
 514:	f000 f9de 	bl	8d4 <i_lscale>
		noise = i_lscale(0,127, 0, envVal, noise);
 518:	9000      	str	r0, [sp, #0]
 51a:	2000      	movs	r0, #0
 51c:	1c21      	adds	r1, r4, #0
 51e:	1c02      	adds	r2, r0, #0
 520:	1c2b      	adds	r3, r5, #0
 522:	f000 f9d7 	bl	8d4 <i_lscale>

		// Set bias to be 1/2 available range
		noise = 127 + noise;
		uint8_t output = noise;
 526:	466a      	mov	r2, sp
		// scale the amplitude
		noise = i_lscale(0, 127, 0, pluckStrength, noise);
		noise = i_lscale(0,127, 0, envVal, noise);

		// Set bias to be 1/2 available range
		noise = 127 + noise;
 528:	1900      	adds	r0, r0, r4
		uint8_t output = noise;
 52a:	320f      	adds	r2, #15
 52c:	7010      	strb	r0, [r2, #0]
		TLC_SetDACValue(PulseDAC, 1, &output);
 52e:	2101      	movs	r1, #1
 530:	2003      	movs	r0, #3
 532:	f000 f93b 	bl	7ac <TLC_SetDACValue>
	}
}
 536:	b005      	add	sp, #20
 538:	bd30      	pop	{r4, r5, pc}
 53a:	46c0      	nop			; (mov r8, r8)
 53c:	10000120 	.word	0x10000120

00000540 <MIDI_NoteOn>:
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
 540:	4b22      	ldr	r3, [pc, #136]	; (5cc <MIDI_NoteOn+0x8c>)
#include "BAP_TLC_DAC.h"
#include "BAP_WaveGen.h"
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 542:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Load global variables
	activeNote = num;
 544:	7018      	strb	r0, [r3, #0]
	pluckStrength = vel;
 546:	4b22      	ldr	r3, [pc, #136]	; (5d0 <MIDI_NoteOn+0x90>)
	EnvPosition = 0;
 548:	2600      	movs	r6, #0

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
 54a:	7019      	strb	r1, [r3, #0]
	EnvPosition = 0;
 54c:	4b21      	ldr	r3, [pc, #132]	; (5d4 <MIDI_NoteOn+0x94>)
#include "BAP_TLC_DAC.h"
#include "BAP_WaveGen.h"
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 54e:	b085      	sub	sp, #20
	// Load global variables
	activeNote = num;
	pluckStrength = vel;
	EnvPosition = 0;
 550:	601e      	str	r6, [r3, #0]

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
 552:	237f      	movs	r3, #127	; 0x7f
 554:	1a1b      	subs	r3, r3, r0
 556:	466c      	mov	r4, sp
 558:	73e3      	strb	r3, [r4, #15]
 55a:	340f      	adds	r4, #15
	TLC_SetDACValue(FilterDAC, 1, &value);
 55c:	1c22      	adds	r2, r4, #0
#include "BAP_TLC_DAC.h"
#include "BAP_WaveGen.h"
#include "FrequencyMaps.h"

void MIDI_NoteOn(uint8_t num, uint8_t vel)
{
 55e:	1c05      	adds	r5, r0, #0
	pluckStrength = vel;
	EnvPosition = 0;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
 560:	2101      	movs	r1, #1
 562:	1c30      	adds	r0, r6, #0
 564:	f000 f922 	bl	7ac <TLC_SetDACValue>
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 568:	1c28      	adds	r0, r5, #0
 56a:	2143      	movs	r1, #67	; 0x43
 56c:	f000 fb73 	bl	c56 <__aeabi_uidiv>
 570:	b2cf      	uxtb	r7, r1
 572:	1c38      	adds	r0, r7, #0
 574:	210c      	movs	r1, #12
 576:	f000 fb6e 	bl	c56 <__aeabi_uidiv>
 57a:	2106      	movs	r1, #6
 57c:	b2c0      	uxtb	r0, r0
 57e:	f000 fb6a 	bl	c56 <__aeabi_uidiv>
 582:	b2c9      	uxtb	r1, r1
 584:	9101      	str	r1, [sp, #4]
 586:	1c28      	adds	r0, r5, #0
 588:	210c      	movs	r1, #12
 58a:	f000 fb64 	bl	c56 <__aeabi_uidiv>
 58e:	9a01      	ldr	r2, [sp, #4]
 590:	4b11      	ldr	r3, [pc, #68]	; (5d8 <MIDI_NoteOn+0x98>)
	TLC_SetDACValue(AmpDAC, 0, &value);
 592:	2001      	movs	r0, #1
	EnvPosition = 0;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 594:	5c9b      	ldrb	r3, [r3, r2]
	TLC_SetDACValue(AmpDAC, 0, &value);
 596:	1c22      	adds	r2, r4, #0
	EnvPosition = 0;

	// Set up the scaling for the DACs and PWM.
	uint8_t value = 127 - num;
	TLC_SetDACValue(FilterDAC, 1, &value);
	value = ampTable[((num % 67) / 12) % 6] + (num % 12);
 598:	1859      	adds	r1, r3, r1
 59a:	7021      	strb	r1, [r4, #0]
	TLC_SetDACValue(AmpDAC, 0, &value);
 59c:	1c31      	adds	r1, r6, #0
 59e:	f000 f905 	bl	7ac <TLC_SetDACValue>
	// Knee for PWM adjustment in higher registers
	//value = (num >= 84) ? 15 : 50;
	//setWidth(&Generator1, value);

	// Set frequency generator's frequency.
	setReload(&Generator1, MIDIto30MhzReload[num % 67]);
 5a2:	4c0e      	ldr	r4, [pc, #56]	; (5dc <MIDI_NoteOn+0x9c>)
 5a4:	4b0e      	ldr	r3, [pc, #56]	; (5e0 <MIDI_NoteOn+0xa0>)
 5a6:	007f      	lsls	r7, r7, #1
 5a8:	5af9      	ldrh	r1, [r7, r3]
 5aa:	1c20      	adds	r0, r4, #0
 5ac:	f000 f974 	bl	898 <setReload>
	updateFreq(&Generator1);
 5b0:	1c20      	adds	r0, r4, #0
 5b2:	f000 f979 	bl	8a8 <updateFreq>
 * @param	evt		: Event value
 * @return	Nothing
 */
STATIC INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt)
{
	pSCT->EVEN |= evt;
 5b6:	4b0b      	ldr	r3, [pc, #44]	; (5e4 <MIDI_NoteOn+0xa4>)
 5b8:	2101      	movs	r1, #1
 5ba:	681a      	ldr	r2, [r3, #0]
 5bc:	430a      	orrs	r2, r1
 5be:	601a      	str	r2, [r3, #0]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 5c0:	4b09      	ldr	r3, [pc, #36]	; (5e8 <MIDI_NoteOn+0xa8>)
 5c2:	2280      	movs	r2, #128	; 0x80
 5c4:	0092      	lsls	r2, r2, #2
 5c6:	601a      	str	r2, [r3, #0]

	// start the exciter
	Chip_SCT_EnableEventInt(LPC_SCT, SCT_EVT_0);
	NVIC_EnableIRQ(SCT_IRQn);
}
 5c8:	b005      	add	sp, #20
 5ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 5cc:	10000106 	.word	0x10000106
 5d0:	10000120 	.word	0x10000120
 5d4:	1000011c 	.word	0x1000011c
 5d8:	10000100 	.word	0x10000100
 5dc:	10000108 	.word	0x10000108
 5e0:	00000e74 	.word	0x00000e74
 5e4:	500040f0 	.word	0x500040f0
 5e8:	e000e100 	.word	0xe000e100

000005ec <MIDI_NoteOff>:

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
 5ec:	b513      	push	{r0, r1, r4, lr}
	if (note == activeNote)
 5ee:	4c09      	ldr	r4, [pc, #36]	; (614 <MIDI_NoteOff+0x28>)
 5f0:	7823      	ldrb	r3, [r4, #0]
 5f2:	b25a      	sxtb	r2, r3
 5f4:	4290      	cmp	r0, r2
 5f6:	d10c      	bne.n	612 <MIDI_NoteOff+0x26>
	{
		uint8_t value = 255 - activeNote;
 5f8:	466a      	mov	r2, sp
 5fa:	3207      	adds	r2, #7
 5fc:	43db      	mvns	r3, r3
		TLC_SetDACValue(FilterDAC, 1, &value);
 5fe:	2000      	movs	r0, #0
 600:	2101      	movs	r1, #1

void MIDI_NoteOff(uint8_t note, uint8_t ignore)
{
	if (note == activeNote)
	{
		uint8_t value = 255 - activeNote;
 602:	7013      	strb	r3, [r2, #0]
		TLC_SetDACValue(FilterDAC, 1, &value);
 604:	f000 f8d2 	bl	7ac <TLC_SetDACValue>
		// set to Idle
		activeNote = -1;
 608:	23ff      	movs	r3, #255	; 0xff
 60a:	7023      	strb	r3, [r4, #0]
		EnvPosition = 0;
 60c:	4b02      	ldr	r3, [pc, #8]	; (618 <MIDI_NoteOff+0x2c>)
 60e:	2200      	movs	r2, #0
 610:	601a      	str	r2, [r3, #0]
	}
}
 612:	bd13      	pop	{r0, r1, r4, pc}
 614:	10000106 	.word	0x10000106
 618:	1000011c 	.word	0x1000011c

0000061c <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 61c:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 61e:	4b0d      	ldr	r3, [pc, #52]	; (654 <CoreClockInit_30Hz+0x38>)
 620:	2224      	movs	r2, #36	; 0x24
 622:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 624:	228e      	movs	r2, #142	; 0x8e
 626:	0092      	lsls	r2, r2, #2
 628:	5899      	ldr	r1, [r3, r2]
 62a:	2080      	movs	r0, #128	; 0x80
 62c:	4381      	bics	r1, r0
 62e:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 630:	68d8      	ldr	r0, [r3, #12]
 632:	2101      	movs	r1, #1
 634:	4a07      	ldr	r2, [pc, #28]	; (654 <CoreClockInit_30Hz+0x38>)
 636:	4208      	tst	r0, r1
 638:	d0fa      	beq.n	630 <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 63a:	2003      	movs	r0, #3
 63c:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 63e:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 640:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 642:	07d1      	lsls	r1, r2, #31
 644:	d5fc      	bpl.n	640 <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 646:	4b03      	ldr	r3, [pc, #12]	; (654 <CoreClockInit_30Hz+0x38>)
 648:	2202      	movs	r2, #2
 64a:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 64c:	f000 f960 	bl	910 <SystemCoreClockUpdate>
}
 650:	bd08      	pop	{r3, pc}
 652:	46c0      	nop			; (mov r8, r8)
 654:	40048000 	.word	0x40048000

00000658 <MIDI_USARTInit>:

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 658:	b538      	push	{r3, r4, r5, lr}
 * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetUARTClockDiv(uint32_t div)
{
	LPC_SYSCTL->UARTCLKDIV = div;
 65a:	4b0f      	ldr	r3, [pc, #60]	; (698 <MIDI_USARTInit+0x40>)
 65c:	2501      	movs	r5, #1
 65e:	601d      	str	r5, [r3, #0]
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	uint32_t reg;

	reg = pUART->CFG & ~((0x3 << 2) | (0x3 << 4) | (0x1 << 6));
 660:	6803      	ldr	r3, [r0, #0]
 662:	227c      	movs	r2, #124	; 0x7c
 664:	4393      	bics	r3, r2
	pUART->CFG = reg | config;
 666:	2204      	movs	r2, #4
 668:	4313      	orrs	r3, r2
 66a:	6003      	str	r3, [r0, #0]

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 66c:	490b      	ldr	r1, [pc, #44]	; (69c <MIDI_USARTInit+0x44>)

/***
 * Midi initialize for USART (1 or 2)
 */
void MIDI_USARTInit(LPC_USART_T* USARTNumber, int RXTX_Enable)
{
 66e:	1c04      	adds	r4, r0, #0

	// configure the frame format
	Chip_UART_ConfigData(USARTNumber, UART_CFG_DATALEN_8 | UART_CFG_PARITY_NONE | UART_CFG_STOPLEN_1);

	// Set the baud rate to 31250
	Chip_UART_SetBaud(USARTNumber, 31250);
 670:	f000 fa86 	bl	b80 <Chip_UART_SetBaud>
	/***
	 *  Initialize the RX and TX specific functions
	 **/
#ifdef MIDI_RX_ENABLE
		// Initialize the Receive buffer
		RingBuffer_Init(&MIDI_RxBuffer, &MIDI_RxData, sizeof(uint8_t), MIDI_RXBUFFERSIZE);
 674:	1c2a      	adds	r2, r5, #0
 676:	490a      	ldr	r1, [pc, #40]	; (6a0 <MIDI_USARTInit+0x48>)
 678:	230a      	movs	r3, #10
 67a:	480a      	ldr	r0, [pc, #40]	; (6a4 <MIDI_USARTInit+0x4c>)
 67c:	f000 f9e2 	bl	a44 <RingBuffer_Init>

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 680:	4b09      	ldr	r3, [pc, #36]	; (6a8 <MIDI_USARTInit+0x50>)
 682:	2200      	movs	r2, #0
 684:	701a      	strb	r2, [r3, #0]
 686:	705a      	strb	r2, [r3, #1]
 688:	709a      	strb	r2, [r3, #2]
 68a:	70da      	strb	r2, [r3, #3]
 68c:	4b07      	ldr	r3, [pc, #28]	; (6ac <MIDI_USARTInit+0x54>)
 68e:	2208      	movs	r2, #8
 * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
 *			to enable specific UART interrupts.
 */
STATIC INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
{
	pUART->INTENSET = intMask;
 690:	60e5      	str	r5, [r4, #12]
 692:	601a      	str	r2, [r3, #0]
		Chip_UART_IntEnable(USARTNumber, UART_INTEN_TXRDY);
#endif

	MIDI_ClearStatus0();
	NVIC_EnableIRQ(UART0_IRQn);
}
 694:	bd38      	pop	{r3, r4, r5, pc}
 696:	46c0      	nop			; (mov r8, r8)
 698:	40048094 	.word	0x40048094
 69c:	00007a12 	.word	0x00007a12
 6a0:	10000130 	.word	0x10000130
 6a4:	1000013c 	.word	0x1000013c
 6a8:	10000122 	.word	0x10000122
 6ac:	e000e100 	.word	0xe000e100

000006b0 <MIDI_SetAddress>:
/***
 * Sets the address of the current receiver
 **/
void inline MIDI_SetAddress(uint8_t addr)
{
	MIDI_Address = addr;
 6b0:	4b01      	ldr	r3, [pc, #4]	; (6b8 <MIDI_SetAddress+0x8>)
 6b2:	7018      	strb	r0, [r3, #0]
}
 6b4:	4770      	bx	lr
 6b6:	46c0      	nop			; (mov r8, r8)
 6b8:	10000121 	.word	0x10000121

000006bc <MIDI_Enable>:
 */

void inline MIDI_Enable(LPC_USART_T* USARTNumber)
{
	// Enable the UART to start receiving messages
	USARTNumber->CFG |= UART_CFG_ENABLE;
 6bc:	6803      	ldr	r3, [r0, #0]
 6be:	2201      	movs	r2, #1
 6c0:	4313      	orrs	r3, r2
 6c2:	6003      	str	r3, [r0, #0]
}
 6c4:	4770      	bx	lr
	...

000006c8 <MIDI_ProcessRXBuffer>:
		}
	}
}

void MIDI_ProcessRXBuffer()
{
 6c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t byte = 0;
 6ca:	2400      	movs	r4, #0
 6cc:	466d      	mov	r5, sp
 6ce:	71ec      	strb	r4, [r5, #7]
 6d0:	3507      	adds	r5, #7
	// Pop a value off the buffer

	if(Chip_UART_ReadRB(LPC_USART0, &MIDI_RxBuffer, &byte, 1) != 0)
 6d2:	481a      	ldr	r0, [pc, #104]	; (73c <MIDI_ProcessRXBuffer+0x74>)
 6d4:	491a      	ldr	r1, [pc, #104]	; (740 <MIDI_ProcessRXBuffer+0x78>)
 6d6:	1c2a      	adds	r2, r5, #0
 6d8:	2301      	movs	r3, #1
 6da:	f000 fa83 	bl	be4 <Chip_UART_ReadRB>
 6de:	42a0      	cmp	r0, r4
 6e0:	d02b      	beq.n	73a <MIDI_ProcessRXBuffer+0x72>
	{
		// Is it a status bit
		if((byte & MIDI_STATBIT))
 6e2:	7829      	ldrb	r1, [r5, #0]
 6e4:	4b17      	ldr	r3, [pc, #92]	; (744 <MIDI_ProcessRXBuffer+0x7c>)
 6e6:	b24a      	sxtb	r2, r1
 6e8:	42a2      	cmp	r2, r4
 6ea:	da0c      	bge.n	706 <MIDI_ProcessRXBuffer+0x3e>
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 6ec:	4a16      	ldr	r2, [pc, #88]	; (748 <MIDI_ProcessRXBuffer+0x80>)
 6ee:	200f      	movs	r0, #15
 6f0:	7812      	ldrb	r2, [r2, #0]
		// Is it a status bit
		if((byte & MIDI_STATBIT))
		{
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;
 6f2:	7019      	strb	r1, [r3, #0]

static void MIDI_ClearStatus0()
{
	// Doing it this way, we'll get a build warning if we ever need to expand MIDI_Status_t
	MIDI_Status_t temp = {MIDI_IDLE, 0, 0, 0};
	MIDI_Status0 = temp;
 6f4:	705c      	strb	r4, [r3, #1]
 6f6:	709c      	strb	r4, [r3, #2]
 6f8:	70dc      	strb	r4, [r3, #3]
			// Start of new message, clear the status
			MIDI_ClearStatus0();
			MIDI_Status0.Status = (uint8_t) byte;

			// Are we being addressed?
			if(((byte & MIDI_CHMSK) == MIDI_Address))
 6fa:	4001      	ands	r1, r0
 6fc:	428a      	cmp	r2, r1
 6fe:	d11a      	bne.n	736 <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_Status0.Addressed = 1;
 700:	2201      	movs	r2, #1
 702:	705a      	strb	r2, [r3, #1]
 704:	e017      	b.n	736 <MIDI_ProcessRXBuffer+0x6e>
			}
		}
		else if (MIDI_Status0.Addressed)
 706:	785a      	ldrb	r2, [r3, #1]
 708:	2a00      	cmp	r2, #0
 70a:	d014      	beq.n	736 <MIDI_ProcessRXBuffer+0x6e>
		{
			MIDI_Status0.DataCount++;
 70c:	789a      	ldrb	r2, [r3, #2]
 70e:	3201      	adds	r2, #1
 710:	b2d2      	uxtb	r2, r2
 712:	709a      	strb	r2, [r3, #2]
}

static void MIDI_ByteProcessor(uint8_t byte)
{

	if ((MIDI_Status0.DataCount % 2))
 714:	07d0      	lsls	r0, r2, #31
 716:	d501      	bpl.n	71c <MIDI_ProcessRXBuffer+0x54>
		MIDI_Status0.DB1 = byte;
 718:	70d9      	strb	r1, [r3, #3]
 71a:	e00c      	b.n	736 <MIDI_ProcessRXBuffer+0x6e>

	else
	{
		switch(MIDI_Status0.Status)
 71c:	781a      	ldrb	r2, [r3, #0]
 71e:	2a80      	cmp	r2, #128	; 0x80
 720:	d003      	beq.n	72a <MIDI_ProcessRXBuffer+0x62>
 722:	2a90      	cmp	r2, #144	; 0x90
 724:	d107      	bne.n	736 <MIDI_ProcessRXBuffer+0x6e>
		{
		case MIDI_NOTEON:
			if ( MIDI_NoteOnFunc != 0)
 726:	4a09      	ldr	r2, [pc, #36]	; (74c <MIDI_ProcessRXBuffer+0x84>)
 728:	e000      	b.n	72c <MIDI_ProcessRXBuffer+0x64>
			{
				MIDI_NoteOnFunc(MIDI_Status0.DB1, byte);
			}
			break;
		case MIDI_NOTEOFF:
			if ( MIDI_NoteOffFunc != 0)
 72a:	4a09      	ldr	r2, [pc, #36]	; (750 <MIDI_ProcessRXBuffer+0x88>)
 72c:	6812      	ldr	r2, [r2, #0]
 72e:	2a00      	cmp	r2, #0
 730:	d001      	beq.n	736 <MIDI_ProcessRXBuffer+0x6e>
			{
				MIDI_NoteOffFunc(MIDI_Status0.DB1, byte);
 732:	78d8      	ldrb	r0, [r3, #3]
 734:	4790      	blx	r2
			MIDI_Status0.DataCount++;
			MIDI_ByteProcessor(byte);
		}

		// Process the next byte
		MIDI_ProcessRXBuffer();
 736:	f7ff ffc7 	bl	6c8 <MIDI_ProcessRXBuffer>
	}
}
 73a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 73c:	40064000 	.word	0x40064000
 740:	1000013c 	.word	0x1000013c
 744:	10000122 	.word	0x10000122
 748:	10000121 	.word	0x10000121
 74c:	1000012c 	.word	0x1000012c
 750:	10000128 	.word	0x10000128

00000754 <UART0_IRQHandler>:

void UART0_IRQHandler(void)
{
 754:	b508      	push	{r3, lr}
	// Insert value into RB
	Chip_UART_RXIntHandlerRB(LPC_USART0, &MIDI_RxBuffer);
 756:	4802      	ldr	r0, [pc, #8]	; (760 <UART0_IRQHandler+0xc>)
 758:	4902      	ldr	r1, [pc, #8]	; (764 <UART0_IRQHandler+0x10>)
 75a:	f000 fa2f 	bl	bbc <Chip_UART_RXIntHandlerRB>
}
 75e:	bd08      	pop	{r3, pc}
 760:	40064000 	.word	0x40064000
 764:	1000013c 	.word	0x1000013c

00000768 <TLC_Init>:
#include "BAP_TLC_DAC.h"

uint8_t TLC_LDAC_pin;

void TLC_Init()
{
 768:	b510      	push	{r4, lr}
	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_HI)) & ~((uint32_t) SPI_CFG_SPI_EN);
 76a:	2392      	movs	r3, #146	; 0x92
 76c:	4c0c      	ldr	r4, [pc, #48]	; (7a0 <TLC_Init+0x38>)
 76e:	005b      	lsls	r3, r3, #1
 770:	6023      	str	r3, [r4, #0]

	// Set the rate to 1MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 1000000));
 772:	1c20      	adds	r0, r4, #0
 774:	490b      	ldr	r1, [pc, #44]	; (7a4 <TLC_Init+0x3c>)
 776:	f000 f9c5 	bl	b04 <Chip_SPI_CalClkRateDivider>
 77a:	b280      	uxth	r0, r0
 77c:	6260      	str	r0, [r4, #36]	; 0x24
 * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_CLR_*)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
{
	pSPI->STAT |= Flag;
 77e:	68a3      	ldr	r3, [r4, #8]
 780:	223c      	movs	r2, #60	; 0x3c
 782:	4313      	orrs	r3, r2
 784:	60a3      	str	r3, [r4, #8]

	// Clear status flags
	Chip_SPI_ClearStatus(LPC_SPI0, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);

	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN | SPI_INTENCLR_RXDYEN | SPI_INTENCLR_RXOVEN | SPI_INTENCLR_TXUREN, DISABLE);
 786:	1c20      	adds	r0, r4, #0
 788:	210f      	movs	r1, #15
 78a:	2200      	movs	r2, #0
 78c:	f000 f9c2 	bl	b14 <Chip_SPI_Int_Cmd>
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
{
	pSPI->CFG |= SPI_CFG_SPI_EN;
 790:	6822      	ldr	r2, [r4, #0]
 792:	2301      	movs	r3, #1
 794:	431a      	orrs	r2, r3
 796:	6022      	str	r2, [r4, #0]
 798:	4a03      	ldr	r2, [pc, #12]	; (7a8 <TLC_Init+0x40>)
 79a:	6013      	str	r3, [r2, #0]

	// Enable the SPI
	Chip_SPI_Enable(LPC_SPI0);
 	NVIC_EnableIRQ(SPI0_IRQn);
}
 79c:	bd10      	pop	{r4, pc}
 79e:	46c0      	nop			; (mov r8, r8)
 7a0:	40058000 	.word	0x40058000
 7a4:	000f4240 	.word	0x000f4240
 7a8:	e000e100 	.word	0xe000e100

000007ac <TLC_SetDACValue>:


void TLC_SetDACValue(TLC_DACNumber DAC, TLC_Range range, uint8_t* value)
{
	// A frame is 11 bits: 2 bit address, 1 bit range, 8 bits data.
	uint16_t frame = (uint16_t)(TLC_DAC(DAC) | TLC_RNG(range) | TLC_Datamask(*value));
 7ac:	7813      	ldrb	r3, [r2, #0]
 7ae:	0209      	lsls	r1, r1, #8
 7b0:	4319      	orrs	r1, r3
 7b2:	0240      	lsls	r0, r0, #9
 7b4:	4301      	orrs	r1, r0
 7b6:	b289      	uxth	r1, r1
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
 */
STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
{
	return pSPI->STAT;
 7b8:	4b04      	ldr	r3, [pc, #16]	; (7cc <TLC_SetDACValue+0x20>)
 7ba:	689a      	ldr	r2, [r3, #8]

	// Wait for the SPI to be ready
	// This is a blocking method
	while (!(Chip_SPI_GetStatus(LPC_SPI0) & SPI_STAT_TXRDY)){/*do nothing*/}
 7bc:	0790      	lsls	r0, r2, #30
 7be:	d5fb      	bpl.n	7b8 <TLC_SetDACValue+0xc>
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 7c0:	20a7      	movs	r0, #167	; 0xa7
 7c2:	0500      	lsls	r0, r0, #20
 7c4:	4308      	orrs	r0, r1
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 7c6:	6198      	str	r0, [r3, #24]
	// Send a frame.
	// Since there is no need to read a response,
	// and the full message fits with a frame,
	// we assume this will be the final frame.
	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 11);
}
 7c8:	4770      	bx	lr
 7ca:	46c0      	nop			; (mov r8, r8)
 7cc:	40058000 	.word	0x40058000

000007d0 <WaveGenStart>:
}


void WaveGenStart(WaveGen* Generator)
{
	switch(Generator->ID)
 7d0:	7803      	ldrb	r3, [r0, #0]
 7d2:	2b00      	cmp	r3, #0
 7d4:	d104      	bne.n	7e0 <WaveGenStart+0x10>
	{
	case 0:
		LPC_SCT->CTRL_U &= ~(1 << 2);
 7d6:	4b03      	ldr	r3, [pc, #12]	; (7e4 <WaveGenStart+0x14>)
 7d8:	2104      	movs	r1, #4
 7da:	685a      	ldr	r2, [r3, #4]
 7dc:	438a      	bics	r2, r1
 7de:	605a      	str	r2, [r3, #4]
		break;
	case 1:
		break;
	}
}
 7e0:	4770      	bx	lr
 7e2:	46c0      	nop			; (mov r8, r8)
 7e4:	50004000 	.word	0x50004000

000007e8 <setWidth>:


void setWidth(WaveGen* Generator, uint8_t percentage)
{
 7e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 7ea:	1c05      	adds	r5, r0, #0
 7ec:	1c0c      	adds	r4, r1, #0
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 7ee:	f000 f91f 	bl	a30 <Chip_Clock_GetSystemClockRate>
	int genID = Generator->ID;
 7f2:	782f      	ldrb	r7, [r5, #0]


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 7f4:	686e      	ldr	r6, [r5, #4]
	int genID = Generator->ID;

	// TODO: actually write some good code here instead of dumb code.
	if ((genID < 0) || (genID > 3)) {
 7f6:	2f03      	cmp	r7, #3
 7f8:	d818      	bhi.n	82c <setWidth+0x44>
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
 7fa:	2301      	movs	r3, #1
	if ((genID < 0) || (genID > 3)) {
		return;
	}

	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
 7fc:	2c63      	cmp	r4, #99	; 0x63
 7fe:	d810      	bhi.n	822 <setWidth+0x3a>


void setWidth(WaveGen* Generator, uint8_t percentage)
{
	uint32_t value;
	uint32_t reload = Chip_Clock_GetSystemClockRate() / Generator->frequency;
 800:	f000 fb17 	bl	e32 <__aeabi_ui2f>
 804:	1c31      	adds	r1, r6, #0
 806:	f000 fa61 	bl	ccc <__aeabi_fdiv>
 80a:	f000 facf 	bl	dac <__aeabi_f2uiz>
 80e:	1c06      	adds	r6, r0, #0
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
		value = reload + 1;
 810:	1c43      	adds	r3, r0, #1
	// If highest, set match as close to beginning as possible
	if (percentage >= 100) {
		value = 1;
	}
	// If Lowest, set as close to frequency as possible
	else if (percentage == 0) {
 812:	2c00      	cmp	r4, #0
 814:	d005      	beq.n	822 <setWidth+0x3a>
		value = reload + 1;
	}
	else {
		uint32_t newTicks;

		newTicks = (reload * percentage)/100;
 816:	1c20      	adds	r0, r4, #0
 818:	4370      	muls	r0, r6
 81a:	2164      	movs	r1, #100	; 0x64
 81c:	f000 fa1b 	bl	c56 <__aeabi_uidiv>

		/* Approximate duty cycle rate */
		value = reload - newTicks;
 820:	1a33      	subs	r3, r6, r0
	}

	LPC_SCT->MATCHREL[genID + 1].U = value;
 822:	3781      	adds	r7, #129	; 0x81
 824:	4a02      	ldr	r2, [pc, #8]	; (830 <setWidth+0x48>)
 826:	00bf      	lsls	r7, r7, #2
 828:	50bb      	str	r3, [r7, r2]
	Generator->width = percentage;
 82a:	722c      	strb	r4, [r5, #8]
}
 82c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 82e:	46c0      	nop			; (mov r8, r8)
 830:	50004000 	.word	0x50004000

00000834 <WaveGenInit>:

/********************************************************************************************************
 * 											FUNCTIONS													*
 *******************************************************************************************************/
void WaveGenInit(WaveGen* Generator, float freq)
{
 834:	b538      	push	{r3, r4, r5, lr}
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 836:	4c14      	ldr	r4, [pc, #80]	; (888 <WaveGenInit+0x54>)
 838:	2301      	movs	r3, #1

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 83a:	2207      	movs	r2, #7
void WaveGenInit(WaveGen* Generator, float freq)
{
	//TODO: Get the hard-coded crap out of here.

	/* Configure the SCT as a 32bit counter using the bus clock */
	LPC_SCT->CONFIG = SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_CLKMODE_BUSCLK;
 83c:	6023      	str	r3, [r4, #0]

	/* Initial CTOUT0 state is high */
	LPC_SCT->OUTPUT = (7 << 0);
 83e:	6522      	str	r2, [r4, #80]	; 0x50
	{
		freq = 1;
	}

	/* Setup for match mode */
	LPC_SCT->REGMODE_L = 0;
 840:	1c22      	adds	r2, r4, #0
 842:	2500      	movs	r5, #0
 844:	324c      	adds	r2, #76	; 0x4c
 846:	8015      	strh	r5, [r2, #0]

	// what does this do?
	LPC_SCT->EVENT[0].CTRL = 0x00001000;
 848:	2180      	movs	r1, #128	; 0x80
 84a:	22c1      	movs	r2, #193	; 0xc1
 84c:	0149      	lsls	r1, r1, #5
 84e:	0092      	lsls	r2, r2, #2
 850:	50a1      	str	r1, [r4, r2]

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;
 852:	22c0      	movs	r2, #192	; 0xc0
 854:	4259      	negs	r1, r3
 856:	0092      	lsls	r2, r2, #2
 858:	50a1      	str	r1, [r4, r2]
	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 85a:	4a0c      	ldr	r2, [pc, #48]	; (88c <WaveGenInit+0x58>)

	// By writing all ones, all events are unmasked and allowed to happen.
	LPC_SCT->EVENT[0].STATE = 0xFFFFFFFF;

	// Event 0 is used to limit the counter
	LPC_SCT->LIMIT_L = (1 << 0);
 85c:	8123      	strh	r3, [r4, #8]

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
 85e:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[1].CLR = (1 << 0);
 860:	4a0b      	ldr	r2, [pc, #44]	; (890 <WaveGenInit+0x5c>)

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 862:	490c      	ldr	r1, [pc, #48]	; (894 <WaveGenInit+0x60>)
	LPC_SCT->LIMIT_L = (1 << 0);

	/* For CTOUT0, event 1 is used to clear the output */

	LPC_SCT->OUT[0].CLR = (1 << 0);
	LPC_SCT->OUT[1].CLR = (1 << 0);
 864:	50a3      	str	r3, [r4, r2]

	/* Setup event 1 to trigger on match 1 and set CTOUT0 high */
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
 866:	22c3      	movs	r2, #195	; 0xc3
 868:	0092      	lsls	r2, r2, #2
 86a:	50a1      	str	r1, [r4, r2]
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
 86c:	22c2      	movs	r2, #194	; 0xc2
 86e:	0092      	lsls	r2, r2, #2
 870:	50a3      	str	r3, [r4, r2]
	LPC_SCT->OUT[0].SET = (1 << 1);
 872:	23a0      	movs	r3, #160	; 0xa0
 874:	2202      	movs	r2, #2
 876:	00db      	lsls	r3, r3, #3
 878:	50e2      	str	r2, [r4, r3]

	setWidth(Generator, 50);
 87a:	2132      	movs	r1, #50	; 0x32

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 87c:	3406      	adds	r4, #6
	LPC_SCT->EVENT[1].CTRL = (1 << 0) | (1 << 12);
	// What does this do?
	LPC_SCT->EVENT[1].STATE = 1;
	LPC_SCT->OUT[0].SET = (1 << 1);

	setWidth(Generator, 50);
 87e:	f7ff ffb3 	bl	7e8 <setWidth>

	/* Don't use states */
	// Do we need this?  resets to 0.
	LPC_SCT->STATE_L = 0;
 882:	87e5      	strh	r5, [r4, #62]	; 0x3e
}
 884:	bd38      	pop	{r3, r4, r5, pc}
 886:	46c0      	nop			; (mov r8, r8)
 888:	50004000 	.word	0x50004000
 88c:	00000504 	.word	0x00000504
 890:	0000050c 	.word	0x0000050c
 894:	00001001 	.word	0x00001001

00000898 <setReload>:
}


void setReload(WaveGen* Generator, int reload)
{
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
 898:	7802      	ldrb	r2, [r0, #0]
 89a:	4b02      	ldr	r3, [pc, #8]	; (8a4 <setReload+0xc>)
 89c:	3280      	adds	r2, #128	; 0x80
 89e:	0092      	lsls	r2, r2, #2
 8a0:	50d1      	str	r1, [r2, r3]
}
 8a2:	4770      	bx	lr
 8a4:	50004000 	.word	0x50004000

000008a8 <updateFreq>:

void updateFreq(WaveGen* Generator)
{
 8a8:	b510      	push	{r4, lr}
 8aa:	1c04      	adds	r4, r0, #0
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 8ac:	f000 f8c0 	bl	a30 <Chip_Clock_GetSystemClockRate>
 8b0:	7822      	ldrb	r2, [r4, #0]
 8b2:	4b07      	ldr	r3, [pc, #28]	; (8d0 <updateFreq+0x28>)
 8b4:	3280      	adds	r2, #128	; 0x80
 8b6:	0092      	lsls	r2, r2, #2
 8b8:	58d1      	ldr	r1, [r2, r3]
 8ba:	f000 f9cc 	bl	c56 <__aeabi_uidiv>
 8be:	f000 fab8 	bl	e32 <__aeabi_ui2f>
	setWidth(Generator, Generator->width);
 8c2:	7a21      	ldrb	r1, [r4, #8]
	LPC_SCT->MATCHREL[Generator->ID].U = reload;
}

void updateFreq(WaveGen* Generator)
{
	Generator->frequency = Chip_Clock_GetSystemClockRate() / LPC_SCT->MATCHREL[Generator->ID].U;
 8c4:	6060      	str	r0, [r4, #4]
	setWidth(Generator, Generator->width);
 8c6:	1c20      	adds	r0, r4, #0
 8c8:	f7ff ff8e 	bl	7e8 <setWidth>
}
 8cc:	bd10      	pop	{r4, pc}
 8ce:	46c0      	nop			; (mov r8, r8)
 8d0:	50004000 	.word	0x50004000

000008d4 <i_lscale>:
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 8d4:	b538      	push	{r3, r4, r5, lr}
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
 8d6:	1a09      	subs	r1, r1, r0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 8d8:	1c05      	adds	r5, r0, #0
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
	{
		return y;
 8da:	2000      	movs	r0, #0
	x = (x > top) ? top : x;
	return x;
}

int32_t i_lscale(int32_t minX, int32_t maxX, int32_t minY, int32_t maxY, int32_t x)
{
 8dc:	1c14      	adds	r4, r2, #0
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
	int32_t X = x - minX;

	// Block Div0 and Mult0
	if( DeltaX == 0)
 8de:	4281      	cmp	r1, r0
 8e0:	d007      	beq.n	8f2 <i_lscale+0x1e>
	// Initialize the return value
	int32_t y = 0;

	// calculate the change in both axis
	int32_t DeltaX = maxX - minX;
	int32_t DeltaY = maxY - minY;
 8e2:	1a9b      	subs	r3, r3, r2
	int32_t X = x - minX;
 8e4:	9a04      	ldr	r2, [sp, #16]
 8e6:	1b55      	subs	r5, r2, r5
	{
		return y;
	}

	// calculate scaled position
	y = minY + ((DeltaY *X) /DeltaX);
 8e8:	1c28      	adds	r0, r5, #0
 8ea:	4358      	muls	r0, r3
 8ec:	f000 f9b0 	bl	c50 <__aeabi_idiv>
 8f0:	1820      	adds	r0, r4, r0
	//{
	//	y += (maxY > minY ? maxY : minY);
	//}

	return y;
}
 8f2:	bd38      	pop	{r3, r4, r5, pc}

000008f4 <LFSR>:
}

uint32_t LFSR()
{
	static uint32_t lfsr = 0xACE1u;
	uint8_t lsb = lfsr & 1;
 8f4:	4b05      	ldr	r3, [pc, #20]	; (90c <LFSR+0x18>)
 8f6:	6819      	ldr	r1, [r3, #0]
	lfsr >>= 1;
 8f8:	084a      	lsrs	r2, r1, #1

	if (lsb == 1)
 8fa:	07c8      	lsls	r0, r1, #31
 8fc:	d502      	bpl.n	904 <LFSR+0x10>
	{
		/* Only apply toggle mask if output bit is 1. */
		lfsr ^= 0xB400u;
 8fe:	21b4      	movs	r1, #180	; 0xb4
 900:	0209      	lsls	r1, r1, #8
 902:	404a      	eors	r2, r1
 904:	601a      	str	r2, [r3, #0]
	}
	return lfsr;
 906:	6818      	ldr	r0, [r3, #0]
}
 908:	4770      	bx	lr
 90a:	46c0      	nop			; (mov r8, r8)
 90c:	10000114 	.word	0x10000114

00000910 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 910:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 912:	f000 f88d 	bl	a30 <Chip_Clock_GetSystemClockRate>
 916:	4b01      	ldr	r3, [pc, #4]	; (91c <SystemCoreClockUpdate+0xc>)
 918:	6018      	str	r0, [r3, #0]
}
 91a:	bd08      	pop	{r3, pc}
 91c:	10000150 	.word	0x10000150

00000920 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 920:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 922:	05c2      	lsls	r2, r0, #23
 924:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 926:	211f      	movs	r1, #31
 928:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 92a:	0092      	lsls	r2, r2, #2
 92c:	4b03      	ldr	r3, [pc, #12]	; (93c <Chip_Clock_GetWDTLFORate+0x1c>)
 92e:	58d0      	ldr	r0, [r2, r3]
 930:	3101      	adds	r1, #1
 932:	0049      	lsls	r1, r1, #1
 934:	f000 f98f 	bl	c56 <__aeabi_uidiv>
}
 938:	bd08      	pop	{r3, pc}
 93a:	46c0      	nop			; (mov r8, r8)
 93c:	00000efc 	.word	0x00000efc

00000940 <Chip_Clock_GetPLLFreq>:

/* Compute a PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t msel = ((PLLReg & 0x1F) + 1);
 940:	231f      	movs	r3, #31
 942:	4018      	ands	r0, r3
 944:	3001      	adds	r0, #1

	return inputRate * msel;
 946:	4348      	muls	r0, r1
}
 948:	4770      	bx	lr
 94a:	46c0      	nop			; (mov r8, r8)

0000094c <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 94c:	4b03      	ldr	r3, [pc, #12]	; (95c <Chip_Clock_SetSystemPLLSource+0x10>)
 94e:	6418      	str	r0, [r3, #64]	; 0x40
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;
 950:	2200      	movs	r2, #0
 952:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;
 954:	2201      	movs	r2, #1
 956:	645a      	str	r2, [r3, #68]	; 0x44
}
 958:	4770      	bx	lr
 95a:	46c0      	nop			; (mov r8, r8)
 95c:	40048000 	.word	0x40048000

00000960 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 960:	4b03      	ldr	r3, [pc, #12]	; (970 <Chip_Clock_SetMainClockSource+0x10>)
 962:	6718      	str	r0, [r3, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN  = 0;
 964:	2200      	movs	r2, #0
 966:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 968:	2201      	movs	r2, #1
 96a:	675a      	str	r2, [r3, #116]	; 0x74
}
 96c:	4770      	bx	lr
 96e:	46c0      	nop			; (mov r8, r8)
 970:	40048000 	.word	0x40048000

00000974 <Chip_Clock_SetCLKOUTSource>:

/* Set CLKOUT clock source and divider */
void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
{
	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
 974:	4b05      	ldr	r3, [pc, #20]	; (98c <Chip_Clock_SetCLKOUTSource+0x18>)
 976:	22e0      	movs	r2, #224	; 0xe0
 978:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 0;
 97a:	22e4      	movs	r2, #228	; 0xe4
 97c:	2000      	movs	r0, #0
 97e:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 1;
 980:	2001      	movs	r0, #1
 982:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTDIV = div;
 984:	22e8      	movs	r2, #232	; 0xe8
 986:	5099      	str	r1, [r3, r2]
}
 988:	4770      	bx	lr
 98a:	46c0      	nop			; (mov r8, r8)
 98c:	40048000 	.word	0x40048000

00000990 <Chip_Clock_GetWDTOSCRate>:

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 990:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 992:	4b02      	ldr	r3, [pc, #8]	; (99c <Chip_Clock_GetWDTOSCRate+0xc>)
 994:	6a58      	ldr	r0, [r3, #36]	; 0x24
 996:	f7ff ffc3 	bl	920 <Chip_Clock_GetWDTLFORate>
}
 99a:	bd08      	pop	{r3, pc}
 99c:	40048000 	.word	0x40048000

000009a0 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 9a0:	4b09      	ldr	r3, [pc, #36]	; (9c8 <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 9a2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 9a4:	2303      	movs	r3, #3
 9a6:	4013      	ands	r3, r2
 9a8:	2b01      	cmp	r3, #1
 9aa:	d005      	beq.n	9b8 <Chip_Clock_GetSystemPLLInClockRate+0x18>
 9ac:	2b03      	cmp	r3, #3
 9ae:	d006      	beq.n	9be <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 9b0:	2b00      	cmp	r3, #0
 9b2:	d107      	bne.n	9c4 <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 9b4:	4805      	ldr	r0, [pc, #20]	; (9cc <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 9b6:	e006      	b.n	9c6 <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 9b8:	4b05      	ldr	r3, [pc, #20]	; (9d0 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 9ba:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 9bc:	e003      	b.n	9c6 <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 9be:	4b05      	ldr	r3, [pc, #20]	; (9d4 <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 9c0:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 9c2:	e000      	b.n	9c6 <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 9c4:	2000      	movs	r0, #0
		break;
	}

	return clkRate;
}
 9c6:	4770      	bx	lr
 9c8:	40048000 	.word	0x40048000
 9cc:	00b71b00 	.word	0x00b71b00
 9d0:	00000e6c 	.word	0x00000e6c
 9d4:	00000e70 	.word	0x00000e70

000009d8 <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 9d8:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 9da:	4b04      	ldr	r3, [pc, #16]	; (9ec <Chip_Clock_GetSystemPLLOutClockRate+0x14>)
 9dc:	689c      	ldr	r4, [r3, #8]
 9de:	f7ff ffdf 	bl	9a0 <Chip_Clock_GetSystemPLLInClockRate>
 9e2:	1c01      	adds	r1, r0, #0
 9e4:	1c20      	adds	r0, r4, #0
 9e6:	f7ff ffab 	bl	940 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 9ea:	bd10      	pop	{r4, pc}
 9ec:	40048000 	.word	0x40048000

000009f0 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 9f0:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 9f2:	4b0d      	ldr	r3, [pc, #52]	; (a28 <Chip_Clock_GetMainClockRate+0x38>)
 9f4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 9f6:	2303      	movs	r3, #3
 9f8:	4013      	ands	r3, r2
 9fa:	2b01      	cmp	r3, #1
 9fc:	d009      	beq.n	a12 <Chip_Clock_GetMainClockRate+0x22>
 9fe:	dc02      	bgt.n	a06 <Chip_Clock_GetMainClockRate+0x16>
 a00:	2b00      	cmp	r3, #0
 a02:	d00f      	beq.n	a24 <Chip_Clock_GetMainClockRate+0x34>
 a04:	e003      	b.n	a0e <Chip_Clock_GetMainClockRate+0x1e>
 a06:	2b02      	cmp	r3, #2
 a08:	d006      	beq.n	a18 <Chip_Clock_GetMainClockRate+0x28>
 a0a:	2b03      	cmp	r3, #3
 a0c:	d007      	beq.n	a1e <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 a0e:	2000      	movs	r0, #0
 a10:	e009      	b.n	a26 <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 a12:	f7ff ffc5 	bl	9a0 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 a16:	e006      	b.n	a26 <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 a18:	f7ff ffba 	bl	990 <Chip_Clock_GetWDTOSCRate>
		break;
 a1c:	e003      	b.n	a26 <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 a1e:	f7ff ffdb 	bl	9d8 <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 a22:	e000      	b.n	a26 <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 a24:	4801      	ldr	r0, [pc, #4]	; (a2c <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 a26:	bd08      	pop	{r3, pc}
 a28:	40048000 	.word	0x40048000
 a2c:	00b71b00 	.word	0x00b71b00

00000a30 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 a30:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 a32:	f7ff ffdd 	bl	9f0 <Chip_Clock_GetMainClockRate>
 a36:	4b02      	ldr	r3, [pc, #8]	; (a40 <Chip_Clock_GetSystemClockRate+0x10>)
 a38:	6f99      	ldr	r1, [r3, #120]	; 0x78
 a3a:	f000 f90c 	bl	c56 <__aeabi_uidiv>
}
 a3e:	bd08      	pop	{r3, pc}
 a40:	40048000 	.word	0x40048000

00000a44 <RingBuffer_Init>:
 ****************************************************************************/

/* Initialize ring buffer */
int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
{
	RingBuff->data = buffer;
 a44:	6001      	str	r1, [r0, #0]
	RingBuff->count = count;
 a46:	6043      	str	r3, [r0, #4]
	RingBuff->itemSz = itemSize;
 a48:	6082      	str	r2, [r0, #8]
	RingBuff->head = RingBuff->tail = 0;
 a4a:	2300      	movs	r3, #0
 a4c:	6103      	str	r3, [r0, #16]
 a4e:	60c3      	str	r3, [r0, #12]

	return 1;
}
 a50:	2001      	movs	r0, #1
 a52:	4770      	bx	lr

00000a54 <RingBuffer_Insert>:

/* Insert a single item into Ring Buffer */
int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
{
 a54:	b538      	push	{r3, r4, r5, lr}
 a56:	1c04      	adds	r4, r0, #0
	uint8_t *ptr = RingBuff->data;
 a58:	6805      	ldr	r5, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 a5a:	68c2      	ldr	r2, [r0, #12]
 a5c:	6903      	ldr	r3, [r0, #16]
 a5e:	1ad2      	subs	r2, r2, r3
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is full, otherwise 0
 */
STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
{
	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
 a60:	6843      	ldr	r3, [r0, #4]

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
 a62:	429a      	cmp	r2, r3
 a64:	da0d      	bge.n	a82 <RingBuffer_Insert+0x2e>
		return 0;

	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
 a66:	3b01      	subs	r3, #1
 a68:	68c2      	ldr	r2, [r0, #12]
 a6a:	4013      	ands	r3, r2
 a6c:	6882      	ldr	r2, [r0, #8]
 a6e:	1c10      	adds	r0, r2, #0
 a70:	4358      	muls	r0, r3
 a72:	1828      	adds	r0, r5, r0
	memcpy(ptr, data, RingBuff->itemSz);
 a74:	f000 f8e4 	bl	c40 <memcpy>
	RingBuff->head++;
 a78:	68e3      	ldr	r3, [r4, #12]
 a7a:	3301      	adds	r3, #1
 a7c:	60e3      	str	r3, [r4, #12]

	return 1;
 a7e:	2001      	movs	r0, #1
 a80:	e000      	b.n	a84 <RingBuffer_Insert+0x30>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
		return 0;
 a82:	2000      	movs	r0, #0
	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
	memcpy(ptr, data, RingBuff->itemSz);
	RingBuff->head++;

	return 1;
}
 a84:	bd38      	pop	{r3, r4, r5, pc}
 a86:	46c0      	nop			; (mov r8, r8)

00000a88 <RingBuffer_PopMult>:
	return 1;
}

/* Pop multiple items from Ring buffer */
int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
{
 a88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 a8a:	1c04      	adds	r4, r0, #0
 a8c:	1c0f      	adds	r7, r1, #0
	uint8_t *ptr = RingBuff->data;
 a8e:	6801      	ldr	r1, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 a90:	68c3      	ldr	r3, [r0, #12]
 a92:	6900      	ldr	r0, [r0, #16]
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
 a94:	4283      	cmp	r3, r0
 a96:	d032      	beq.n	afe <RingBuffer_PopMult+0x76>
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 a98:	68e0      	ldr	r0, [r4, #12]
 a9a:	6923      	ldr	r3, [r4, #16]
 a9c:	1ac0      	subs	r0, r0, r3
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
 a9e:	6866      	ldr	r6, [r4, #4]
 aa0:	1e73      	subs	r3, r6, #1
 aa2:	6925      	ldr	r5, [r4, #16]
 aa4:	402b      	ands	r3, r5
 aa6:	181d      	adds	r5, r3, r0
 aa8:	42b5      	cmp	r5, r6
 aaa:	d301      	bcc.n	ab0 <RingBuffer_PopMult+0x28>
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
 aac:	1af6      	subs	r6, r6, r3
 aae:	e000      	b.n	ab2 <RingBuffer_PopMult+0x2a>
	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;

	/* Calculate the segment lengths */
	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
 ab0:	1c06      	adds	r6, r0, #0
	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count)
		cnt1 = RingBuff->count - RB_INDT(RingBuff);
	cnt2 -= cnt1;
 ab2:	1b80      	subs	r0, r0, r6

	cnt1 = MIN(cnt1, num);
 ab4:	1e15      	subs	r5, r2, #0
 ab6:	42b5      	cmp	r5, r6
 ab8:	dd00      	ble.n	abc <RingBuffer_PopMult+0x34>
 aba:	1c35      	adds	r5, r6, #0
	num -= cnt1;
 abc:	1b56      	subs	r6, r2, r5

	cnt2 = MIN(cnt2, num);
 abe:	4286      	cmp	r6, r0
 ac0:	dd00      	ble.n	ac4 <RingBuffer_PopMult+0x3c>
 ac2:	1c06      	adds	r6, r0, #0
	num -= cnt2;

	/* Write segment 1 */
	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
 ac4:	68a2      	ldr	r2, [r4, #8]
 ac6:	4353      	muls	r3, r2
 ac8:	18c9      	adds	r1, r1, r3
	memcpy(data, ptr, cnt1 * RingBuff->itemSz);
 aca:	436a      	muls	r2, r5
 acc:	1c38      	adds	r0, r7, #0
 ace:	f000 f8b7 	bl	c40 <memcpy>
	RingBuff->tail += cnt1;
 ad2:	6922      	ldr	r2, [r4, #16]
 ad4:	18ab      	adds	r3, r5, r2
 ad6:	6123      	str	r3, [r4, #16]

	/* Write segment 2 */
	ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
 ad8:	6861      	ldr	r1, [r4, #4]
 ada:	3901      	subs	r1, #1
 adc:	400b      	ands	r3, r1
 ade:	68a2      	ldr	r2, [r4, #8]
 ae0:	1c11      	adds	r1, r2, #0
 ae2:	4359      	muls	r1, r3
 ae4:	6823      	ldr	r3, [r4, #0]
 ae6:	1859      	adds	r1, r3, r1
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
 ae8:	1c10      	adds	r0, r2, #0
 aea:	4368      	muls	r0, r5
 aec:	1838      	adds	r0, r7, r0
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
 aee:	4372      	muls	r2, r6
 af0:	f000 f8a6 	bl	c40 <memcpy>
	RingBuff->tail += cnt2;
 af4:	6922      	ldr	r2, [r4, #16]
 af6:	1993      	adds	r3, r2, r6
 af8:	6123      	str	r3, [r4, #16]

	return cnt1 + cnt2;
 afa:	19a8      	adds	r0, r5, r6
 afc:	e000      	b.n	b00 <RingBuffer_PopMult+0x78>
	uint8_t *ptr = RingBuff->data;
	int cnt1, cnt2;

	/* We cannot insert when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;
 afe:	2000      	movs	r0, #0
	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
	memcpy(data, ptr, cnt2 * RingBuff->itemSz);
	RingBuff->tail += cnt2;

	return cnt1 + cnt2;
}
 b00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 b02:	46c0      	nop			; (mov r8, r8)

00000b04 <Chip_SPI_CalClkRateDivider>:
 * Public functions
 ****************************************************************************/

/* Calculate the Clock Rate Divider for SPI Peripheral */
uint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
{
 b04:	b510      	push	{r4, lr}
 b06:	1c0c      	adds	r4, r1, #0
	uint32_t SPIClk;
	uint32_t DivVal = 1;

	/* Get SPI clock rate */
	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
 b08:	f7ff ff92 	bl	a30 <Chip_Clock_GetSystemClockRate>

	DivVal = SPIClk / bitRate;
 b0c:	1c21      	adds	r1, r4, #0
 b0e:	f000 f8a2 	bl	c56 <__aeabi_uidiv>

	return DivVal;
}
 b12:	bd10      	pop	{r4, pc}

00000b14 <Chip_SPI_Int_Cmd>:
}

/* Disable/Enable Interrupt */
void Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
{
	if (NewState ==  ENABLE) {
 b14:	2a01      	cmp	r2, #1
 b16:	d103      	bne.n	b20 <Chip_SPI_Int_Cmd+0xc>
		pSPI->INTENSET |= IntMask;
 b18:	68c3      	ldr	r3, [r0, #12]
 b1a:	4319      	orrs	r1, r3
 b1c:	60c1      	str	r1, [r0, #12]
 b1e:	e002      	b.n	b26 <Chip_SPI_Int_Cmd+0x12>
	}
	else {
		pSPI->INTENCLR |= IntMask;
 b20:	6903      	ldr	r3, [r0, #16]
 b22:	4319      	orrs	r1, r3
 b24:	6101      	str	r1, [r0, #16]
	}
}
 b26:	4770      	bx	lr

00000b28 <Chip_SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 b28:	b508      	push	{r3, lr}
#if defined (USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 b2a:	2002      	movs	r0, #2
 b2c:	f000 f874 	bl	c18 <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 b30:	2000      	movs	r0, #0
 b32:	f7ff ff0b 	bl	94c <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~(0x3));
 b36:	4b10      	ldr	r3, [pc, #64]	; (b78 <Chip_SystemInit+0x50>)
 b38:	691a      	ldr	r2, [r3, #16]
 b3a:	2103      	movs	r1, #3
 b3c:	438a      	bics	r2, r1

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 b3e:	2101      	movs	r1, #1
 b40:	430a      	orrs	r2, r1
 b42:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 b44:	2080      	movs	r0, #128	; 0x80
 b46:	f000 f855 	bl	bf4 <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 b4a:	2241      	movs	r2, #65	; 0x41
 b4c:	4b0b      	ldr	r3, [pc, #44]	; (b7c <Chip_SystemInit+0x54>)
 b4e:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 b50:	2080      	movs	r0, #128	; 0x80
 b52:	f000 f861 	bl	c18 <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 b56:	4909      	ldr	r1, [pc, #36]	; (b7c <Chip_SystemInit+0x54>)
 b58:	2201      	movs	r2, #1
 b5a:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 b5c:	421a      	tst	r2, r3
 b5e:	d0fc      	beq.n	b5a <Chip_SystemInit+0x32>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 b60:	2201      	movs	r2, #1
 b62:	4b06      	ldr	r3, [pc, #24]	; (b7c <Chip_SystemInit+0x54>)
 b64:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 b66:	2003      	movs	r0, #3
 b68:	f7ff fefa 	bl	960 <Chip_Clock_SetMainClockSource>
#endif

	/* Select the CLKOUT clocking source */
	Chip_Clock_SetCLKOUTSource(SYSCTL_CLKOUTSRC_MAINSYSCLK, 1);
 b6c:	2003      	movs	r0, #3
 b6e:	2101      	movs	r1, #1
 b70:	f7ff ff00 	bl	974 <Chip_Clock_SetCLKOUTSource>
}
 b74:	bd08      	pop	{r3, pc}
 b76:	46c0      	nop			; (mov r8, r8)
 b78:	40040000 	.word	0x40040000
 b7c:	40048000 	.word	0x40048000

00000b80 <Chip_UART_SetBaud>:
	return readBytes;
}

/* Set baud rate for UART */
void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
 b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b82:	1c07      	adds	r7, r0, #0
 b84:	1c0e      	adds	r6, r1, #0
	uint32_t err, uart_fra_multiplier, baudRateGenerator;
	uint32_t systemCoreClock = Chip_Clock_GetMainClockRate();
 b86:	f7ff ff33 	bl	9f0 <Chip_Clock_GetMainClockRate>
 b8a:	1c05      	adds	r5, r0, #0

	/* Calculate baudrate generator value */
	baudRateGenerator = systemCoreClock / (16 * baudrate);
 b8c:	0131      	lsls	r1, r6, #4
 b8e:	f000 f862 	bl	c56 <__aeabi_uidiv>
 b92:	1c04      	adds	r4, r0, #0
	err = systemCoreClock - baudRateGenerator * 16 * baudrate;
 b94:	4346      	muls	r6, r0
 b96:	0131      	lsls	r1, r6, #4
 b98:	1a6d      	subs	r5, r5, r1
	uart_fra_multiplier = (err * 0xFF) / (baudRateGenerator * 16 * baudrate);
 b9a:	0228      	lsls	r0, r5, #8
 b9c:	1b40      	subs	r0, r0, r5
 b9e:	f000 f85a 	bl	c56 <__aeabi_uidiv>
	pUART->BRG = baudRateGenerator - 1;	/* baud rate */
 ba2:	3c01      	subs	r4, #1
 ba4:	623c      	str	r4, [r7, #32]
 * @param   div  :  Fractional Generator Divider value, should be 0xFF
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGDivider(uint8_t div)
{
	LPC_SYSCTL->UARTFRGDIV = (uint32_t) div;
 ba6:	4b04      	ldr	r3, [pc, #16]	; (bb8 <Chip_UART_SetBaud+0x38>)
 ba8:	22ff      	movs	r2, #255	; 0xff
 baa:	21f0      	movs	r1, #240	; 0xf0
 bac:	505a      	str	r2, [r3, r1]
 * @param   mult  :  An 8-bit value (0-255) U_PCLK = UARTCLKDIV/(1 + MULT/256)
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_SetUSARTFRGMultiplier(uint8_t mult)
{
	LPC_SYSCTL->UARTFRGMULT = (uint32_t) mult;
 bae:	4002      	ands	r2, r0
 bb0:	21f4      	movs	r1, #244	; 0xf4
 bb2:	505a      	str	r2, [r3, r1]
	Chip_SYSCTL_SetUSARTFRGDivider(0xFF);	/* value 0xFF is always used */
	Chip_SYSCTL_SetUSARTFRGMultiplier(uart_fra_multiplier);
}
 bb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 bb6:	46c0      	nop			; (mov r8, r8)
 bb8:	40048000 	.word	0x40048000

00000bbc <Chip_UART_RXIntHandlerRB>:

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
 bbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 bbe:	b083      	sub	sp, #12
 bc0:	1c04      	adds	r4, r0, #0
 bc2:	1c0f      	adds	r7, r1, #0
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 bc4:	2601      	movs	r6, #1
		uint8_t ch = Chip_UART_ReadByte(pUART);
 bc6:	466d      	mov	r5, sp
 bc8:	3507      	adds	r5, #7

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 bca:	e005      	b.n	bd8 <Chip_UART_RXIntHandlerRB+0x1c>
 *			FIFO status should be read first prior to using this function
 */
STATIC INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
{
	/* Strip off undefined reserved bits, keep 9 lower bits */
	return (uint32_t) (pUART->RXDATA & 0x000001FF);
 bcc:	6963      	ldr	r3, [r4, #20]
		uint8_t ch = Chip_UART_ReadByte(pUART);
 bce:	702b      	strb	r3, [r5, #0]
		RingBuffer_Insert(pRB, &ch);
 bd0:	1c38      	adds	r0, r7, #0
 bd2:	1c29      	adds	r1, r5, #0
 bd4:	f7ff ff3e 	bl	a54 <RingBuffer_Insert>
 *			with one or more UART_STAT_* definitions to determine
 *			statuses.
 */
STATIC INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
{
	return pUART->STAT;
 bd8:	68a3      	ldr	r3, [r4, #8]

/* UART receive-only interrupt handler for ring buffers */
void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
{
	/* New data will be ignored if data not popped in time */
	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
 bda:	421e      	tst	r6, r3
 bdc:	d1f6      	bne.n	bcc <Chip_UART_RXIntHandlerRB+0x10>
		uint8_t ch = Chip_UART_ReadByte(pUART);
		RingBuffer_Insert(pRB, &ch);
	}
}
 bde:	b003      	add	sp, #12
 be0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 be2:	46c0      	nop			; (mov r8, r8)

00000be4 <Chip_UART_ReadRB>:
	return ret;
}

/* Copy data from a receive ring buffer */
int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
{
 be4:	b508      	push	{r3, lr}
	(void) pUART;

	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
 be6:	1c08      	adds	r0, r1, #0
 be8:	1c11      	adds	r1, r2, #0
 bea:	1c1a      	adds	r2, r3, #0
 bec:	f7ff ff4c 	bl	a88 <RingBuffer_PopMult>
}
 bf0:	bd08      	pop	{r3, pc}
 bf2:	46c0      	nop			; (mov r8, r8)

00000bf4 <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 bf4:	4a05      	ldr	r2, [pc, #20]	; (c0c <Chip_SYSCTL_PowerDown+0x18>)
 bf6:	238e      	movs	r3, #142	; 0x8e
 bf8:	009b      	lsls	r3, r3, #2
 bfa:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 bfc:	4308      	orrs	r0, r1
 bfe:	4904      	ldr	r1, [pc, #16]	; (c10 <Chip_SYSCTL_PowerDown+0x1c>)
 c00:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 c02:	4904      	ldr	r1, [pc, #16]	; (c14 <Chip_SYSCTL_PowerDown+0x20>)
 c04:	4308      	orrs	r0, r1
 c06:	50d0      	str	r0, [r2, r3]
}
 c08:	4770      	bx	lr
 c0a:	46c0      	nop			; (mov r8, r8)
 c0c:	40048000 	.word	0x40048000
 c10:	000080ef 	.word	0x000080ef
 c14:	00006d10 	.word	0x00006d10

00000c18 <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 c18:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 c1a:	4a06      	ldr	r2, [pc, #24]	; (c34 <Chip_SYSCTL_PowerUp+0x1c>)
 c1c:	238e      	movs	r3, #142	; 0x8e
 c1e:	009b      	lsls	r3, r3, #2
 c20:	58d4      	ldr	r4, [r2, r3]
 c22:	4905      	ldr	r1, [pc, #20]	; (c38 <Chip_SYSCTL_PowerUp+0x20>)
 c24:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 c26:	4001      	ands	r1, r0
 c28:	438c      	bics	r4, r1
 c2a:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 c2c:	4803      	ldr	r0, [pc, #12]	; (c3c <Chip_SYSCTL_PowerUp+0x24>)
 c2e:	4301      	orrs	r1, r0
 c30:	50d1      	str	r1, [r2, r3]
}
 c32:	bd10      	pop	{r4, pc}
 c34:	40048000 	.word	0x40048000
 c38:	000080ef 	.word	0x000080ef
 c3c:	00006d10 	.word	0x00006d10

00000c40 <memcpy>:
 c40:	b508      	push	{r3, lr}
 c42:	f000 f8fc 	bl	e3e <__aeabi_memcpy>
 c46:	bd08      	pop	{r3, pc}

00000c48 <__weak_main>:
 c48:	b508      	push	{r3, lr}
 c4a:	f7ff fb59 	bl	300 <main>
 c4e:	bd08      	pop	{r3, pc}

00000c50 <__aeabi_idiv>:
 c50:	0003      	movs	r3, r0
 c52:	430b      	orrs	r3, r1
 c54:	d421      	bmi.n	c9a <idiv_negative>

00000c56 <__aeabi_uidiv>:
 c56:	2900      	cmp	r1, #0
 c58:	d031      	beq.n	cbe <idiv_divzero>
 c5a:	2201      	movs	r2, #1
 c5c:	07d2      	lsls	r2, r2, #31
 c5e:	0903      	lsrs	r3, r0, #4
 c60:	e001      	b.n	c66 <div_search4a>

00000c62 <div_search4>:
 c62:	0109      	lsls	r1, r1, #4
 c64:	0912      	lsrs	r2, r2, #4

00000c66 <div_search4a>:
 c66:	4299      	cmp	r1, r3
 c68:	d9fb      	bls.n	c62 <div_search4>
 c6a:	0843      	lsrs	r3, r0, #1
 c6c:	e001      	b.n	c72 <div_search1a>

00000c6e <div_search1>:
 c6e:	0049      	lsls	r1, r1, #1
 c70:	0852      	lsrs	r2, r2, #1

00000c72 <div_search1a>:
 c72:	4299      	cmp	r1, r3
 c74:	d9fb      	bls.n	c6e <div_search1>
 c76:	e000      	b.n	c7a <div_loop1a>

00000c78 <div_loop1>:
 c78:	0849      	lsrs	r1, r1, #1

00000c7a <div_loop1a>:
 c7a:	1a40      	subs	r0, r0, r1
 c7c:	d307      	bcc.n	c8e <div1>

00000c7e <div2>:
 c7e:	4152      	adcs	r2, r2
 c80:	d3fa      	bcc.n	c78 <div_loop1>
 c82:	4601      	mov	r1, r0
 c84:	4610      	mov	r0, r2
 c86:	4770      	bx	lr

00000c88 <div_loop2>:
 c88:	0849      	lsrs	r1, r1, #1
 c8a:	1840      	adds	r0, r0, r1
 c8c:	d2f7      	bcs.n	c7e <div2>

00000c8e <div1>:
 c8e:	1892      	adds	r2, r2, r2
 c90:	d3fa      	bcc.n	c88 <div_loop2>
 c92:	1840      	adds	r0, r0, r1
 c94:	4601      	mov	r1, r0
 c96:	4610      	mov	r0, r2
 c98:	4770      	bx	lr

00000c9a <idiv_negative>:
 c9a:	0fcb      	lsrs	r3, r1, #31
 c9c:	d000      	beq.n	ca0 <idiv_neg1>
 c9e:	4249      	negs	r1, r1

00000ca0 <idiv_neg1>:
 ca0:	1002      	asrs	r2, r0, #32
 ca2:	d500      	bpl.n	ca6 <idiv_neg2>
 ca4:	4240      	negs	r0, r0

00000ca6 <idiv_neg2>:
 ca6:	4053      	eors	r3, r2
 ca8:	b508      	push	{r3, lr}
 caa:	f7ff ffd4 	bl	c56 <__aeabi_uidiv>
 cae:	bc0c      	pop	{r2, r3}

00000cb0 <idiv_sign>:
 cb0:	1052      	asrs	r2, r2, #1
 cb2:	d300      	bcc.n	cb6 <idiv_sign1>
 cb4:	4240      	negs	r0, r0

00000cb6 <idiv_sign1>:
 cb6:	2a00      	cmp	r2, #0
 cb8:	d500      	bpl.n	cbc <idiv_ret>
 cba:	4249      	negs	r1, r1

00000cbc <idiv_ret>:
 cbc:	4718      	bx	r3

00000cbe <idiv_divzero>:
 cbe:	46f4      	mov	ip, lr
 cc0:	2000      	movs	r0, #0
 cc2:	f000 f801 	bl	cc8 <__aeabi_idiv0>
 cc6:	4760      	bx	ip

00000cc8 <__aeabi_idiv0>:
 cc8:	4770      	bx	lr
	...

00000ccc <__aeabi_fdiv>:
 ccc:	b570      	push	{r4, r5, r6, lr}
 cce:	0dc2      	lsrs	r2, r0, #23
 cd0:	24ff      	movs	r4, #255	; 0xff
 cd2:	4022      	ands	r2, r4
 cd4:	d04b      	beq.n	d6e <__aeabi_fdiv+0xa2>
 cd6:	42a2      	cmp	r2, r4
 cd8:	d049      	beq.n	d6e <__aeabi_fdiv+0xa2>
 cda:	0dcb      	lsrs	r3, r1, #23
 cdc:	4023      	ands	r3, r4
 cde:	d046      	beq.n	d6e <__aeabi_fdiv+0xa2>
 ce0:	42a3      	cmp	r3, r4
 ce2:	d044      	beq.n	d6e <__aeabi_fdiv+0xa2>
 ce4:	1c0e      	adds	r6, r1, #0
 ce6:	2580      	movs	r5, #128	; 0x80
 ce8:	1ad4      	subs	r4, r2, r3
 cea:	062d      	lsls	r5, r5, #24
 cec:	020b      	lsls	r3, r1, #8
 cee:	4046      	eors	r6, r0
 cf0:	0200      	lsls	r0, r0, #8
 cf2:	4328      	orrs	r0, r5
 cf4:	431d      	orrs	r5, r3
 cf6:	086b      	lsrs	r3, r5, #1
 cf8:	3b01      	subs	r3, #1
 cfa:	0842      	lsrs	r2, r0, #1
 cfc:	429a      	cmp	r2, r3
 cfe:	da02      	bge.n	d06 <__aeabi_fdiv+0x3a>
 d00:	1c21      	adds	r1, r4, #0
 d02:	317d      	adds	r1, #125	; 0x7d
 d04:	e002      	b.n	d0c <__aeabi_fdiv+0x40>
 d06:	1c21      	adds	r1, r4, #0
 d08:	1052      	asrs	r2, r2, #1
 d0a:	317e      	adds	r1, #126	; 0x7e
 d0c:	0ff0      	lsrs	r0, r6, #31
 d0e:	01c0      	lsls	r0, r0, #7
 d10:	0052      	lsls	r2, r2, #1
 d12:	1ad4      	subs	r4, r2, r3
 d14:	d400      	bmi.n	d18 <__aeabi_fdiv+0x4c>
 d16:	1c22      	adds	r2, r4, #0
 d18:	0052      	lsls	r2, r2, #1
 d1a:	1ad4      	subs	r4, r2, r3
 d1c:	d400      	bmi.n	d20 <__aeabi_fdiv+0x54>
 d1e:	1c22      	adds	r2, r4, #0
 d20:	0052      	lsls	r2, r2, #1
 d22:	1ad4      	subs	r4, r2, r3
 d24:	d400      	bmi.n	d28 <__aeabi_fdiv+0x5c>
 d26:	1c22      	adds	r2, r4, #0
 d28:	0052      	lsls	r2, r2, #1
 d2a:	1ad4      	subs	r4, r2, r3
 d2c:	d400      	bmi.n	d30 <__aeabi_fdiv+0x64>
 d2e:	1c22      	adds	r2, r4, #0
 d30:	0052      	lsls	r2, r2, #1
 d32:	1ad4      	subs	r4, r2, r3
 d34:	d400      	bmi.n	d38 <__aeabi_fdiv+0x6c>
 d36:	1c22      	adds	r2, r4, #0
 d38:	0052      	lsls	r2, r2, #1
 d3a:	1ad4      	subs	r4, r2, r3
 d3c:	d400      	bmi.n	d40 <__aeabi_fdiv+0x74>
 d3e:	1c22      	adds	r2, r4, #0
 d40:	0694      	lsls	r4, r2, #26
 d42:	4320      	orrs	r0, r4
 d44:	243f      	movs	r4, #63	; 0x3f
 d46:	43a2      	bics	r2, r4
 d48:	241a      	movs	r4, #26
 d4a:	41e0      	rors	r0, r4
 d4c:	0204      	lsls	r4, r0, #8
 d4e:	d5df      	bpl.n	d10 <__aeabi_fdiv+0x44>
 d50:	0052      	lsls	r2, r2, #1
 d52:	1ad3      	subs	r3, r2, r3
 d54:	43db      	mvns	r3, r3
 d56:	0fdb      	lsrs	r3, r3, #31
 d58:	18c0      	adds	r0, r0, r3
 d5a:	29fd      	cmp	r1, #253	; 0xfd
 d5c:	d802      	bhi.n	d64 <__aeabi_fdiv+0x98>
 d5e:	05c9      	lsls	r1, r1, #23
 d60:	1840      	adds	r0, r0, r1
 d62:	e01f      	b.n	da4 <__aeabi_fdiv+0xd8>
 d64:	0fc0      	lsrs	r0, r0, #31
 d66:	07c0      	lsls	r0, r0, #31
 d68:	2900      	cmp	r1, #0
 d6a:	da14      	bge.n	d96 <__aeabi_fdiv+0xca>
 d6c:	e01a      	b.n	da4 <__aeabi_fdiv+0xd8>
 d6e:	25ff      	movs	r5, #255	; 0xff
 d70:	0044      	lsls	r4, r0, #1
 d72:	062d      	lsls	r5, r5, #24
 d74:	42ac      	cmp	r4, r5
 d76:	d814      	bhi.n	da2 <__aeabi_fdiv+0xd6>
 d78:	004a      	lsls	r2, r1, #1
 d7a:	42aa      	cmp	r2, r5
 d7c:	d811      	bhi.n	da2 <__aeabi_fdiv+0xd6>
 d7e:	1c0b      	adds	r3, r1, #0
 d80:	4303      	orrs	r3, r0
 d82:	005b      	lsls	r3, r3, #1
 d84:	0e1b      	lsrs	r3, r3, #24
 d86:	d00c      	beq.n	da2 <__aeabi_fdiv+0xd6>
 d88:	4048      	eors	r0, r1
 d8a:	0fc0      	lsrs	r0, r0, #31
 d8c:	07c0      	lsls	r0, r0, #31
 d8e:	0e23      	lsrs	r3, r4, #24
 d90:	d008      	beq.n	da4 <__aeabi_fdiv+0xd8>
 d92:	42aa      	cmp	r2, r5
 d94:	d003      	beq.n	d9e <__aeabi_fdiv+0xd2>
 d96:	23ff      	movs	r3, #255	; 0xff
 d98:	05db      	lsls	r3, r3, #23
 d9a:	4318      	orrs	r0, r3
 d9c:	e002      	b.n	da4 <__aeabi_fdiv+0xd8>
 d9e:	4294      	cmp	r4, r2
 da0:	d100      	bne.n	da4 <__aeabi_fdiv+0xd8>
 da2:	4801      	ldr	r0, [pc, #4]	; (da8 <__aeabi_fdiv+0xdc>)
 da4:	bd70      	pop	{r4, r5, r6, pc}
 da6:	46c0      	nop			; (mov r8, r8)
 da8:	7fc00000 	.word	0x7fc00000

00000dac <__aeabi_f2uiz>:
 dac:	2280      	movs	r2, #128	; 0x80
 dae:	0dc3      	lsrs	r3, r0, #23
 db0:	0201      	lsls	r1, r0, #8
 db2:	0612      	lsls	r2, r2, #24
 db4:	209e      	movs	r0, #158	; 0x9e
 db6:	4311      	orrs	r1, r2
 db8:	1ac0      	subs	r0, r0, r3
 dba:	d402      	bmi.n	dc2 <__aeabi_f2uiz+0x16>
 dbc:	40c1      	lsrs	r1, r0
 dbe:	1c08      	adds	r0, r1, #0
 dc0:	e006      	b.n	dd0 <__aeabi_f2uiz+0x24>
 dc2:	2bfe      	cmp	r3, #254	; 0xfe
 dc4:	d902      	bls.n	dcc <__aeabi_f2uiz+0x20>
 dc6:	2000      	movs	r0, #0
 dc8:	4291      	cmp	r1, r2
 dca:	d101      	bne.n	dd0 <__aeabi_f2uiz+0x24>
 dcc:	0a18      	lsrs	r0, r3, #8
 dce:	3801      	subs	r0, #1
 dd0:	4770      	bx	lr

00000dd2 <__bhs_ui2f>:
 dd2:	2800      	cmp	r0, #0
 dd4:	d02b      	beq.n	e2e <__bhs_ui2f+0x5c>
 dd6:	0c03      	lsrs	r3, r0, #16
 dd8:	d101      	bne.n	dde <__bhs_ui2f+0xc>
 dda:	0400      	lsls	r0, r0, #16
 ddc:	e002      	b.n	de4 <__bhs_ui2f+0x12>
 dde:	2380      	movs	r3, #128	; 0x80
 de0:	051b      	lsls	r3, r3, #20
 de2:	18c9      	adds	r1, r1, r3
 de4:	0e03      	lsrs	r3, r0, #24
 de6:	d101      	bne.n	dec <__bhs_ui2f+0x1a>
 de8:	0200      	lsls	r0, r0, #8
 dea:	e002      	b.n	df2 <__bhs_ui2f+0x20>
 dec:	2380      	movs	r3, #128	; 0x80
 dee:	04db      	lsls	r3, r3, #19
 df0:	18c9      	adds	r1, r1, r3
 df2:	0f03      	lsrs	r3, r0, #28
 df4:	d101      	bne.n	dfa <__bhs_ui2f+0x28>
 df6:	0100      	lsls	r0, r0, #4
 df8:	e002      	b.n	e00 <__bhs_ui2f+0x2e>
 dfa:	2380      	movs	r3, #128	; 0x80
 dfc:	049b      	lsls	r3, r3, #18
 dfe:	18c9      	adds	r1, r1, r3
 e00:	0f83      	lsrs	r3, r0, #30
 e02:	d101      	bne.n	e08 <__bhs_ui2f+0x36>
 e04:	0080      	lsls	r0, r0, #2
 e06:	e002      	b.n	e0e <__bhs_ui2f+0x3c>
 e08:	2380      	movs	r3, #128	; 0x80
 e0a:	045b      	lsls	r3, r3, #17
 e0c:	18c9      	adds	r1, r1, r3
 e0e:	2800      	cmp	r0, #0
 e10:	db01      	blt.n	e16 <__bhs_ui2f+0x44>
 e12:	0040      	lsls	r0, r0, #1
 e14:	e002      	b.n	e1c <__bhs_ui2f+0x4a>
 e16:	2380      	movs	r3, #128	; 0x80
 e18:	041b      	lsls	r3, r3, #16
 e1a:	18c9      	adds	r1, r1, r3
 e1c:	3080      	adds	r0, #128	; 0x80
 e1e:	1203      	asrs	r3, r0, #8
 e20:	1859      	adds	r1, r3, r1
 e22:	0600      	lsls	r0, r0, #24
 e24:	d101      	bne.n	e2a <__bhs_ui2f+0x58>
 e26:	2301      	movs	r3, #1
 e28:	4399      	bics	r1, r3
 e2a:	1c08      	adds	r0, r1, #0
 e2c:	e000      	b.n	e30 <__bhs_ui2f+0x5e>
 e2e:	2000      	movs	r0, #0
 e30:	4770      	bx	lr

00000e32 <__aeabi_ui2f>:
 e32:	b508      	push	{r3, lr}
 e34:	2180      	movs	r1, #128	; 0x80
 e36:	05c9      	lsls	r1, r1, #23
 e38:	f7ff ffcb 	bl	dd2 <__bhs_ui2f>
 e3c:	bd08      	pop	{r3, pc}

00000e3e <__aeabi_memcpy>:
 e3e:	4684      	mov	ip, r0
 e40:	0783      	lsls	r3, r0, #30
 e42:	d108      	bne.n	e56 <copy1_start>
 e44:	078b      	lsls	r3, r1, #30
 e46:	d106      	bne.n	e56 <copy1_start>
 e48:	1f13      	subs	r3, r2, #4
 e4a:	d304      	bcc.n	e56 <copy1_start>

00000e4c <copy4>:
 e4c:	c904      	ldmia	r1!, {r2}
 e4e:	c004      	stmia	r0!, {r2}
 e50:	3b04      	subs	r3, #4
 e52:	d2fb      	bcs.n	e4c <copy4>
 e54:	1d1a      	adds	r2, r3, #4

00000e56 <copy1_start>:
 e56:	4252      	negs	r2, r2
 e58:	d005      	beq.n	e66 <copy1_ret>
 e5a:	1a89      	subs	r1, r1, r2
 e5c:	1a80      	subs	r0, r0, r2

00000e5e <copy1>:
 e5e:	5c8b      	ldrb	r3, [r1, r2]
 e60:	5483      	strb	r3, [r0, r2]
 e62:	3201      	adds	r2, #1
 e64:	d1fb      	bne.n	e5e <copy1>

00000e66 <copy1_ret>:
 e66:	4660      	mov	r0, ip
 e68:	4770      	bx	lr
	...

00000e6c <OscRateIn>:
 e6c:	1b00 00b7                                   ....

00000e70 <ExtRateIn>:
 e70:	0000 0000                                   ....

00000e74 <MIDIto30MhzReload>:
 e74:	0dfe 0d35 0c77 0bc4 0b1b 0a7c 09e5 0957     ..5.w.....|...W.
 e84:	08d0 0852 07da 0769 06ff 069a 063b 05e2     ..R...i.....;...
 e94:	058d 053d 04f2 04ab 0468 0428 03ed 03b4     ..=.....h.(.....
 ea4:	037f 034d 031d 02f0 02c6 029e 0278 0255     ..M.........x.U.
 eb4:	0233 0214 01f6 01da 01bf 01a6 018e 0178     3.............x.
 ec4:	0163 014f 013c 012a 0119 0109 00fa 00ec     c.O.<.*.........
 ed4:	00df 00d2 00c7 00bb 00b1 00a7 009d 0094     ................
 ee4:	008c 0084 007d 0076 006f 0069 0063 005d     ....}.v.o.i.c.].
 ef4:	0058 0053 004e 004a                         X.S.N.J.

00000efc <wdtOSCRate>:
 efc:	0000 0000 27c0 0009 0590 0010 5cc0 0015     .....'.......\..
 f0c:	b3f0 001a 0b20 0020 9f00 0024 32e0 0029     .... . ...$..2).
 f1c:	c6c0 002d 9750 0031 67e0 0035 3870 0039     ..-.P.1..g5.p89.
 f2c:	0900 003d 1640 0040 2380 0043 30c0 0046     ..=.@.@..#C..0F.
