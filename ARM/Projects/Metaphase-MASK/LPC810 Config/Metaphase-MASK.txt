
Metaphase-MASK.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 10 00 10 ed 00 00 00 d5 00 00 00 d9 00 00 00     ................
	...
  2c:	dd 00 00 00 00 00 00 00 00 00 00 00 e1 00 00 00     ................
  3c:	e5 00 00 00 39 07 00 00 e9 00 00 00 00 00 00 00     ....9...........
  4c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  5c:	00 00 00 00 3d 06 00 00 e9 00 00 00 e9 00 00 00     ....=...........
  6c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  7c:	e9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................
  b0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000b80 	.word	0x00000b80
  c4:	10000000 	.word	0x10000000
  c8:	00000000 	.word	0x00000000

000000cc <__bss_section_table>:
  cc:	10000000 	.word	0x10000000
  d0:	000000ec 	.word	0x000000ec

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>
  d6:	46c0      	nop			; (mov r8, r8)

000000d8 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d8:	e7fe      	b.n	d8 <HardFault_Handler>
  da:	46c0      	nop			; (mov r8, r8)

000000dc <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  dc:	e7fe      	b.n	dc <SVC_Handler>
  de:	46c0      	nop			; (mov r8, r8)

000000e0 <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  e0:	e7fe      	b.n	e0 <PendSV_Handler>
  e2:	46c0      	nop			; (mov r8, r8)

000000e4 <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  e4:	e7fe      	b.n	e4 <SysTick_Handler>
  e6:	46c0      	nop			; (mov r8, r8)

000000e8 <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  e8:	e7fe      	b.n	e8 <BOD_IRQHandler>
  ea:	46c0      	nop			; (mov r8, r8)

000000ec <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
  ec:	b570      	push	{r4, r5, r6, lr}

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
  ee:	4c17      	ldr	r4, [pc, #92]	; (14c <ResetISR+0x60>)
  f0:	4d17      	ldr	r5, [pc, #92]	; (150 <ResetISR+0x64>)
  f2:	42ac      	cmp	r4, r5
  f4:	d20e      	bcs.n	114 <ResetISR+0x28>
        LoadAddr = *SectionTableAddr++;
  f6:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
  f8:	6861      	ldr	r1, [r4, #4]
  fa:	340c      	adds	r4, #12
  fc:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
  fe:	681a      	ldr	r2, [r3, #0]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 100:	2300      	movs	r3, #0
 102:	2a00      	cmp	r2, #0
 104:	d0f5      	beq.n	f2 <ResetISR+0x6>
        *pulDest++ = *pulSrc++;
 106:	581e      	ldr	r6, [r3, r0]
 108:	505e      	str	r6, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 10a:	3304      	adds	r3, #4
 10c:	429a      	cmp	r2, r3
 10e:	d8fa      	bhi.n	106 <ResetISR+0x1a>

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 110:	42ac      	cmp	r4, r5
 112:	d3f0      	bcc.n	f6 <ResetISR+0xa>
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 114:	4a0f      	ldr	r2, [pc, #60]	; (154 <ResetISR+0x68>)
 116:	4294      	cmp	r4, r2
 118:	d213      	bcs.n	142 <ResetISR+0x56>
 11a:	1c23      	adds	r3, r4, #0
 11c:	3308      	adds	r3, #8
 11e:	1dd5      	adds	r5, r2, #7
 120:	1aed      	subs	r5, r5, r3
 122:	08ed      	lsrs	r5, r5, #3
 124:	00ed      	lsls	r5, r5, #3
 126:	195d      	adds	r5, r3, r5

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 128:	2100      	movs	r1, #0
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
 12a:	6862      	ldr	r2, [r4, #4]
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
 12c:	6820      	ldr	r0, [r4, #0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 12e:	2300      	movs	r3, #0
 130:	2a00      	cmp	r2, #0
 132:	d003      	beq.n	13c <ResetISR+0x50>
        *pulDest++ = 0;
 134:	5019      	str	r1, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 136:	3304      	adds	r3, #4
 138:	429a      	cmp	r2, r3
 13a:	d8fb      	bhi.n	134 <ResetISR+0x48>
 13c:	3408      	adds	r4, #8
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 13e:	42ac      	cmp	r4, r5
 140:	d1f3      	bne.n	12a <ResetISR+0x3e>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 142:	f000 f949 	bl	3d8 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 146:	f000 fc9f 	bl	a88 <__weak_main>
 14a:	e7fe      	b.n	14a <ResetISR+0x5e>
 14c:	000000c0 	.word	0x000000c0
 150:	000000cc 	.word	0x000000cc
 154:	000000d4 	.word	0x000000d4

00000158 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
 158:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 15a:	2300      	movs	r3, #0
 15c:	2a00      	cmp	r2, #0
 15e:	d004      	beq.n	16a <data_init+0x12>
        *pulDest++ = *pulSrc++;
 160:	581c      	ldr	r4, [r3, r0]
 162:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 164:	3304      	adds	r3, #4
 166:	429a      	cmp	r2, r3
 168:	d8fa      	bhi.n	160 <data_init+0x8>
        *pulDest++ = *pulSrc++;
}
 16a:	bd10      	pop	{r4, pc}

0000016c <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 16c:	2300      	movs	r3, #0
        *pulDest++ = 0;
 16e:	2200      	movs	r2, #0

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 170:	2900      	cmp	r1, #0
 172:	d003      	beq.n	17c <bss_init+0x10>
        *pulDest++ = 0;
 174:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 176:	3304      	adds	r3, #4
 178:	4299      	cmp	r1, r3
 17a:	d8fb      	bhi.n	174 <bss_init+0x8>
        *pulDest++ = 0;
}
 17c:	4770      	bx	lr
 17e:	46c0      	nop			; (mov r8, r8)
 180:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 184:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 188:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 18c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 190:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 194:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 198:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 19c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1fc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 200:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 204:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 208:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 20c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 210:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 214:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 218:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 21c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 220:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 224:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 228:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 22c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 230:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 23c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 24c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 25c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 26c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 27c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 28c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 29c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffff ffff                                   ....

00000300 <main>:
#include "BAP_MAX1164x_ADC.h"

#define LED_LOCATION    (14)
#define LPC812

int main(void) {
 300:	b570      	push	{r4, r5, r6, lr}
 302:	b0a4      	sub	sp, #144	; 0x90
	// Standard boot procedure
	CoreClockInit_30Hz();
 304:	f000 f880 	bl	408 <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 308:	4a2c      	ldr	r2, [pc, #176]	; (3bc <main+0xbc>)
 30a:	2380      	movs	r3, #128	; 0x80
 30c:	58d0      	ldr	r0, [r2, r3]
 30e:	2140      	movs	r1, #64	; 0x40
 310:	4301      	orrs	r1, r0
 312:	50d1      	str	r1, [r2, r3]
 314:	58d0      	ldr	r0, [r2, r3]
 316:	2180      	movs	r1, #128	; 0x80
 318:	0109      	lsls	r1, r1, #4
 31a:	4301      	orrs	r1, r0
 31c:	50d1      	str	r1, [r2, r3]
 31e:	58d0      	ldr	r0, [r2, r3]
 320:	2180      	movs	r1, #128	; 0x80
 322:	0309      	lsls	r1, r1, #12
 324:	4301      	orrs	r1, r0
 326:	50d1      	str	r1, [r2, r3]
 328:	58d0      	ldr	r0, [r2, r3]
 32a:	2120      	movs	r1, #32
 32c:	4301      	orrs	r1, r0
 32e:	50d1      	str	r1, [r2, r3]
 330:	58d1      	ldr	r1, [r2, r3]
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);
#ifdef LPC812
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
 332:	4823      	ldr	r0, [pc, #140]	; (3c0 <main+0xc0>)
 334:	4319      	orrs	r1, r3
 336:	50d1      	str	r1, [r2, r3]
 338:	4922      	ldr	r1, [pc, #136]	; (3c4 <main+0xc4>)
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 33a:	244f      	movs	r4, #79	; 0x4f
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);
#ifdef LPC812
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
 33c:	60c8      	str	r0, [r1, #12]
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
 33e:	4822      	ldr	r0, [pc, #136]	; (3c8 <main+0xc8>)
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 340:	4264      	negs	r4, r4
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
 342:	6108      	str	r0, [r1, #16]
	/* I2C0_SDA */
	LPC_SWM->PINASSIGN[7] = 0x0bffffffUL;
 344:	4821      	ldr	r0, [pc, #132]	; (3cc <main+0xcc>)
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 346:	2580      	movs	r5, #128	; 0x80
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
	/* I2C0_SDA */
	LPC_SWM->PINASSIGN[7] = 0x0bffffffUL;
 348:	61c8      	str	r0, [r1, #28]
	/* I2C0_SCL */
	LPC_SWM->PINASSIGN[8] = 0xffffff0aUL;
 34a:	20f6      	movs	r0, #246	; 0xf6
 34c:	4240      	negs	r0, r0
 34e:	6208      	str	r0, [r1, #32]
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 350:	20e0      	movs	r0, #224	; 0xe0
 352:	0040      	lsls	r0, r0, #1
 354:	500c      	str	r4, [r1, r0]
 * @param	clk	: Clock to disable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL &= ~(1 << clk);
 356:	58d1      	ldr	r1, [r2, r3]
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 358:	24a0      	movs	r4, #160	; 0xa0
 35a:	4399      	bics	r1, r3
 35c:	50d1      	str	r1, [r2, r3]
 35e:	0624      	lsls	r4, r4, #24
 360:	019b      	lsls	r3, r3, #6
 362:	58e2      	ldr	r2, [r4, r3]
 364:	01ed      	lsls	r5, r5, #7
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 366:	2688      	movs	r6, #136	; 0x88
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 368:	432a      	orrs	r2, r5
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 36a:	01b6      	lsls	r6, r6, #6
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 36c:	50e2      	str	r2, [r4, r3]
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 36e:	51a5      	str	r5, [r4, r6]

	// Initialize the ADC
	TLV_Init();
 370:	f000 f972 	bl	658 <TLV_Init>

	//LPC_GPIO_PORT->CLR[0] = 1 << LED_LOCATION;
	// Initialize the Analog-to-Digital converter
	MAX1164x_t ADC;
	MAX1164x_Init(&ADC, IOCON_PIO11, IOCON_PIO10);
 374:	2208      	movs	r2, #8
 376:	4668      	mov	r0, sp
 378:	2107      	movs	r1, #7
 37a:	f000 f89b 	bl	4b4 <MAX1164x_Init>
	MAX1164x_SetSpeed(&ADC, MAX1164x_SPD_HI);
 37e:	4668      	mov	r0, sp
 380:	2101      	movs	r1, #1
 382:	f000 f8f3 	bl	56c <MAX1164x_SetSpeed>
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 386:	51a5      	str	r5, [r4, r6]

	// Initialize the 32-position selector
	Selector_Init(LPC_CMP);
 388:	4811      	ldr	r0, [pc, #68]	; (3d0 <main+0xd0>)
 38a:	f000 f829 	bl	3e0 <Selector_Init>
 38e:	4c11      	ldr	r4, [pc, #68]	; (3d4 <main+0xd4>)
	while(1)
	{
		MAX1164x_RequestNewSample(&ADC);
		if (sample_count != last_count)
		{
			TLV_SetDACValue(TLV_DAC_1, TLV_SPD_Fast, ADC.sample_buffer.channel[0]);
 390:	2688      	movs	r6, #136	; 0x88
			TLV_SetDACValue(TLV_DAC_2, TLV_SPD_Fast, ADC.sample_buffer.channel[1]);
 392:	258a      	movs	r5, #138	; 0x8a
	// Initialize the 32-position selector
	Selector_Init(LPC_CMP);
	uint16_t last_count = 0;
	while(1)
	{
		MAX1164x_RequestNewSample(&ADC);
 394:	4668      	mov	r0, sp
 396:	f000 f921 	bl	5dc <MAX1164x_RequestNewSample>
		if (sample_count != last_count)
 39a:	8823      	ldrh	r3, [r4, #0]
 39c:	2b00      	cmp	r3, #0
 39e:	d0f9      	beq.n	394 <main+0x94>
		{
			TLV_SetDACValue(TLV_DAC_1, TLV_SPD_Fast, ADC.sample_buffer.channel[0]);
 3a0:	466b      	mov	r3, sp
 3a2:	5b9a      	ldrh	r2, [r3, r6]
 3a4:	2101      	movs	r1, #1
 3a6:	2000      	movs	r0, #0
 3a8:	f000 f98a 	bl	6c0 <TLV_SetDACValue>
			TLV_SetDACValue(TLV_DAC_2, TLV_SPD_Fast, ADC.sample_buffer.channel[1]);
 3ac:	466b      	mov	r3, sp
 3ae:	5b5a      	ldrh	r2, [r3, r5]
 3b0:	2101      	movs	r1, #1
 3b2:	2001      	movs	r0, #1
 3b4:	f000 f984 	bl	6c0 <TLV_SetDACValue>
 3b8:	e7ec      	b.n	394 <main+0x94>
 3ba:	46c0      	nop			; (mov r8, r8)
 3bc:	40048000 	.word	0x40048000
 3c0:	06ffffff 	.word	0x06ffffff
 3c4:	4000c000 	.word	0x4000c000
 3c8:	ff11ff07 	.word	0xff11ff07
 3cc:	0bffffff 	.word	0x0bffffff
 3d0:	40024000 	.word	0x40024000
 3d4:	10000004 	.word	0x10000004

000003d8 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 3d8:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 3da:	f000 fb25 	bl	a28 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 3de:	bd08      	pop	{r3, pc}

000003e0 <Selector_Init>:
 *      Author: Matt
 */

#include "BAP_32Sel.h"

void Selector_Init(LPC_CMP_T* ACMP){
 3e0:	b507      	push	{r0, r1, r2, lr}
	// Turn on the analog comparator
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_ACMP_PD);
 3e2:	2080      	movs	r0, #128	; 0x80
 3e4:	0200      	lsls	r0, r0, #8
 3e6:	f000 fb0b 	bl	a00 <Chip_SYSCTL_PowerUp>
 * @param	pACMP	: Pointer to Analog Comparator block
 * @return	Nothing
 */
STATIC INLINE void Chip_ACMP_EnableVoltLadder(LPC_CMP_T *pACMP)
{
	pACMP->LAD |= ACMP_LADENAB_BIT;
 3ea:	4806      	ldr	r0, [pc, #24]	; (404 <Selector_Init+0x24>)
 3ec:	2201      	movs	r2, #1
 3ee:	6843      	ldr	r3, [r0, #4]
	// Enable the voltage ladder
	Chip_ACMP_EnableVoltLadder(LPC_CMP);

	// Set up comparator:
	// set COMPEDGE on both edges, use the ACMP_in1 as the positive input, the ladder as the negative, with no hysteresis.
	Chip_ACMP_SetupAMCPRefs(LPC_CMP, ACMP_EDGESEL_BOTH, ACMP_POSIN_ACMP_I1, ACMP_NEGIN_VLO, ACMP_HYS_NONE);
 3f0:	2110      	movs	r1, #16
 3f2:	4313      	orrs	r3, r2
 3f4:	6043      	str	r3, [r0, #4]
 3f6:	2280      	movs	r2, #128	; 0x80
 3f8:	2300      	movs	r3, #0
 3fa:	9300      	str	r3, [sp, #0]
 3fc:	0052      	lsls	r2, r2, #1
 3fe:	f000 f9dd 	bl	7bc <Chip_ACMP_SetupAMCPRefs>
}
 402:	bd07      	pop	{r0, r1, r2, pc}
 404:	40024000 	.word	0x40024000

00000408 <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 408:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 40a:	4b0d      	ldr	r3, [pc, #52]	; (440 <CoreClockInit_30Hz+0x38>)
 40c:	2224      	movs	r2, #36	; 0x24
 40e:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 410:	228e      	movs	r2, #142	; 0x8e
 412:	0092      	lsls	r2, r2, #2
 414:	5899      	ldr	r1, [r3, r2]
 416:	2080      	movs	r0, #128	; 0x80
 418:	4381      	bics	r1, r0
 41a:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 41c:	68d8      	ldr	r0, [r3, #12]
 41e:	2101      	movs	r1, #1
 420:	4a07      	ldr	r2, [pc, #28]	; (440 <CoreClockInit_30Hz+0x38>)
 422:	4208      	tst	r0, r1
 424:	d0fa      	beq.n	41c <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 426:	2003      	movs	r0, #3
 428:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 42a:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 42c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 42e:	07d1      	lsls	r1, r2, #31
 430:	d5fc      	bpl.n	42c <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 432:	4b03      	ldr	r3, [pc, #12]	; (440 <CoreClockInit_30Hz+0x38>)
 434:	2202      	movs	r2, #2
 436:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 438:	f000 f9ce 	bl	7d8 <SystemCoreClockUpdate>
}
 43c:	bd08      	pop	{r3, pc}
 43e:	46c0      	nop			; (mov r8, r8)
 440:	40048000 	.word	0x40048000

00000444 <MAX1164x_WriteCmd>:
/////////////////// Static Global Variables //////////////////////////////
static I2C_HANDLE_T* localHandle;
////////////////////// Static Functions /////////////////////////////////

static void MAX1164x_WriteCmd(MAX1164x_t* MAX1164x, uint8_t cmd)
{
 444:	b570      	push	{r4, r5, r6, lr}
 446:	b08a      	sub	sp, #40	; 0x28
	// Maximum CMD is a two-byte write cycle following the 1 byte address & R/W indicator
	uint8_t SendData[2];
	int i = 0;

	SendData[i++] = (uint8_t) (MAX1164x_I2C_ADDR_7BIT << 1);
 448:	ab01      	add	r3, sp, #4
 44a:	226c      	movs	r2, #108	; 0x6c
 44c:	701a      	strb	r2, [r3, #0]
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
 44e:	9306      	str	r3, [sp, #24]
	// Maximum CMD is a two-byte write cycle following the 1 byte address & R/W indicator
	uint8_t SendData[2];
	int i = 0;

	SendData[i++] = (uint8_t) (MAX1164x_I2C_ADDR_7BIT << 1);
	SendData[i++] = cmd;
 450:	7059      	strb	r1, [r3, #1]

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
 452:	2300      	movs	r3, #0
 454:	9305      	str	r3, [sp, #20]
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 456:	2202      	movs	r2, #2
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 458:	1c03      	adds	r3, r0, #0
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 45a:	9204      	str	r2, [sp, #16]
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 45c:	338c      	adds	r3, #140	; 0x8c
 45e:	781b      	ldrb	r3, [r3, #0]
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 460:	ac04      	add	r4, sp, #16
	param.stop_flag         = MAX1164x->UseStopFlag;

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 462:	4e09      	ldr	r6, [pc, #36]	; (488 <MAX1164x_WriteCmd+0x44>)
	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 464:	7523      	strb	r3, [r4, #20]

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 466:	6833      	ldr	r3, [r6, #0]
/////////////////// Static Global Variables //////////////////////////////
static I2C_HANDLE_T* localHandle;
////////////////////// Static Functions /////////////////////////////////

static void MAX1164x_WriteCmd(MAX1164x_t* MAX1164x, uint8_t cmd)
{
 468:	1c05      	adds	r5, r0, #0
	param.stop_flag         = MAX1164x->UseStopFlag;

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 46a:	695b      	ldr	r3, [r3, #20]
 46c:	4907      	ldr	r1, [pc, #28]	; (48c <MAX1164x_WriteCmd+0x48>)
 46e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 470:	6840      	ldr	r0, [r0, #4]
 472:	4798      	blx	r3
	LPC_I2CD_API->i2c_master_transmit_poll(MAX1164x->i2cHandleMaster, &param, &result);
 474:	6833      	ldr	r3, [r6, #0]
 476:	6868      	ldr	r0, [r5, #4]
 478:	695b      	ldr	r3, [r3, #20]
 47a:	1c21      	adds	r1, r4, #0
 47c:	685b      	ldr	r3, [r3, #4]
 47e:	aa02      	add	r2, sp, #8
 480:	4798      	blx	r3
}
 482:	b00a      	add	sp, #40	; 0x28
 484:	bd70      	pop	{r4, r5, r6, pc}
 486:	46c0      	nop			; (mov r8, r8)
 488:	1fff1ff8 	.word	0x1fff1ff8
 48c:	00002710 	.word	0x00002710

00000490 <MAX1164x_CBFunc>:

void MAX1164x_CBFunc(uint32_t err, uint32_t n)
{
	sample_count++;
 490:	4b02      	ldr	r3, [pc, #8]	; (49c <MAX1164x_CBFunc+0xc>)
 492:	881a      	ldrh	r2, [r3, #0]
 494:	3201      	adds	r2, #1
 496:	b292      	uxth	r2, r2
 498:	801a      	strh	r2, [r3, #0]
}
 49a:	4770      	bx	lr
 49c:	10000004 	.word	0x10000004

000004a0 <MAX1164x_UpdateConfig>:

////////////////////////// Public Functions ///////////////////////////////////

void MAX1164x_UpdateConfig(MAX1164x_t* MAX1164x)
{
 4a0:	b508      	push	{r3, lr}
	MAX1164x_WriteCmd(MAX1164x, MAX1164x->ConfigReg.Register);
 4a2:	7841      	ldrb	r1, [r0, #1]
 4a4:	f7ff ffce 	bl	444 <MAX1164x_WriteCmd>
}
 4a8:	bd08      	pop	{r3, pc}

000004aa <MAX1164x_UpdateSetup>:


void MAX1164x_UpdateSetup(MAX1164x_t* MAX1164x)
{
 4aa:	b508      	push	{r3, lr}
	MAX1164x_WriteCmd(MAX1164x, MAX1164x->SetupReg.Register);
 4ac:	7801      	ldrb	r1, [r0, #0]
 4ae:	f7ff ffc9 	bl	444 <MAX1164x_WriteCmd>
}
 4b2:	bd08      	pop	{r3, pc}

000004b4 <MAX1164x_Init>:
/***
 * Initialize the MAX1164x interface
 * Params: Speed, SDA pin, SCL pin
 */
void MAX1164x_Init(MAX1164x_t* MAX1164x, CHIP_PINx_T sda, CHIP_PINx_T scl)
{
 4b4:	b570      	push	{r4, r5, r6, lr}
 4b6:	1c0e      	adds	r6, r1, #0
 4b8:	1c04      	adds	r4, r0, #0
 4ba:	1c15      	adds	r5, r2, #0
	// Initialize the peripheral
	Chip_I2C_Init();
 4bc:	f000 fa26 	bl	90c <Chip_I2C_Init>

	// Allow for 400kHz+ bit rate
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, sda, PIN_I2CMODE_FASTPLUS);
 4c0:	1c31      	adds	r1, r6, #0
 4c2:	4822      	ldr	r0, [pc, #136]	; (54c <MAX1164x_Init+0x98>)
 4c4:	2202      	movs	r2, #2
 4c6:	f000 fa31 	bl	92c <Chip_IOCON_PinSetI2CMode>
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, scl, PIN_I2CMODE_FASTPLUS);
 4ca:	1c29      	adds	r1, r5, #0
 4cc:	481f      	ldr	r0, [pc, #124]	; (54c <MAX1164x_Init+0x98>)
 4ce:	2202      	movs	r2, #2
 4d0:	f000 fa2c 	bl	92c <Chip_IOCON_PinSetI2CMode>

	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
 4d4:	2382      	movs	r3, #130	; 0x82
 4d6:	7023      	strb	r3, [r4, #0]
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;

	// Initialize the use stop flag bool
	MAX1164x->UseStopFlag = TRUE;
 4d8:	1c22      	adds	r2, r4, #0
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, sda, PIN_I2CMODE_FASTPLUS);
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, scl, PIN_I2CMODE_FASTPLUS);

	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;
 4da:	2301      	movs	r3, #1

	// Initialize the use stop flag bool
	MAX1164x->UseStopFlag = TRUE;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4dc:	4e1c      	ldr	r6, [pc, #112]	; (550 <MAX1164x_Init+0x9c>)
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, sda, PIN_I2CMODE_FASTPLUS);
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, scl, PIN_I2CMODE_FASTPLUS);

	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;
 4de:	7063      	strb	r3, [r4, #1]

	// Initialize the use stop flag bool
	MAX1164x->UseStopFlag = TRUE;
 4e0:	328c      	adds	r2, #140	; 0x8c
 4e2:	7013      	strb	r3, [r2, #0]

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4e4:	6833      	ldr	r3, [r6, #0]
 4e6:	1c21      	adds	r1, r4, #0
 4e8:	695b      	ldr	r3, [r3, #20]
 4ea:	3108      	adds	r1, #8
 4ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 4ee:	4819      	ldr	r0, [pc, #100]	; (554 <MAX1164x_Init+0xa0>)
 4f0:	4798      	blx	r3
 4f2:	4b19      	ldr	r3, [pc, #100]	; (558 <MAX1164x_Init+0xa4>)

	sample_count = 0;
 4f4:	2200      	movs	r2, #0

	// Initialize the use stop flag bool
	MAX1164x->UseStopFlag = TRUE;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4f6:	6018      	str	r0, [r3, #0]

	sample_count = 0;
 4f8:	4b18      	ldr	r3, [pc, #96]	; (55c <MAX1164x_Init+0xa8>)

	// Initialize the use stop flag bool
	MAX1164x->UseStopFlag = TRUE;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4fa:	1c05      	adds	r5, r0, #0
 4fc:	6060      	str	r0, [r4, #4]

	sample_count = 0;
 4fe:	801a      	strh	r2, [r3, #0]

	if (MAX1164x->i2cHandleMaster == NULL)
 500:	4290      	cmp	r0, r2
 502:	d100      	bne.n	506 <MAX1164x_Init+0x52>
 504:	e7fe      	b.n	504 <MAX1164x_Init+0x50>
		// If we get here, problems.  We should probably address this
		while(1){};
	}

	// Set I2C bitrate to normal "fast" mode
	if (LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE) != LPC_OK)
 506:	6833      	ldr	r3, [r6, #0]
 508:	695b      	ldr	r3, [r3, #20]
 50a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 50c:	f000 f9f4 	bl	8f8 <Chip_Clock_GetSystemClockRate>
 510:	4a13      	ldr	r2, [pc, #76]	; (560 <MAX1164x_Init+0xac>)
 512:	1c01      	adds	r1, r0, #0
 514:	1c28      	adds	r0, r5, #0
 516:	47b0      	blx	r6
 518:	1e05      	subs	r5, r0, #0
 51a:	d000      	beq.n	51e <MAX1164x_Init+0x6a>
 51c:	e7fe      	b.n	51c <MAX1164x_Init+0x68>
		// If we get here, problems.  We should probably address this
		while(1){};
	}

	// Setup for use with external clock for max speed
	MAX1164x->SetupReg.BitField.clk = MAX1164x_EXT_CLK;
 51e:	7823      	ldrb	r3, [r4, #0]
 520:	2208      	movs	r2, #8
 522:	4313      	orrs	r3, r2
 524:	7023      	strb	r3, [r4, #0]

	// Set scan bits to scan up from in 0
	MAX1164x->ConfigReg.BitField.scan = MAX1164x_SCANFROMIN0;
 526:	7863      	ldrb	r3, [r4, #1]
	// Set scan to catch both inputs
	MAX1164x->ConfigReg.BitField.chan_sel = MAX1164x_CHAN_B;
 528:	2260      	movs	r2, #96	; 0x60
 52a:	4393      	bics	r3, r2
 52c:	2202      	movs	r2, #2
 52e:	4313      	orrs	r3, r2
 530:	7063      	strb	r3, [r4, #1]

	MAX1164x_UpdateSetup(MAX1164x);
 532:	1c20      	adds	r0, r4, #0
 534:	f7ff ffb9 	bl	4aa <MAX1164x_UpdateSetup>
	MAX1164x_UpdateConfig(MAX1164x);
 538:	1c20      	adds	r0, r4, #0
 53a:	f7ff ffb1 	bl	4a0 <MAX1164x_UpdateConfig>

	interruptErrorFlag = LPC_OK;
 53e:	4b09      	ldr	r3, [pc, #36]	; (564 <MAX1164x_Init+0xb0>)

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 540:	2280      	movs	r2, #128	; 0x80
 542:	601d      	str	r5, [r3, #0]
 544:	4b08      	ldr	r3, [pc, #32]	; (568 <MAX1164x_Init+0xb4>)
 546:	0052      	lsls	r2, r2, #1
 548:	601a      	str	r2, [r3, #0]

	NVIC_EnableIRQ(I2C_IRQn);
}
 54a:	bd70      	pop	{r4, r5, r6, pc}
 54c:	40044000 	.word	0x40044000
 550:	1fff1ff8 	.word	0x1fff1ff8
 554:	40050000 	.word	0x40050000
 558:	10000000 	.word	0x10000000
 55c:	10000004 	.word	0x10000004
 560:	00061a80 	.word	0x00061a80
 564:	10000008 	.word	0x10000008
 568:	e000e100 	.word	0xe000e100

0000056c <MAX1164x_SetSpeed>:


void MAX1164x_SetSpeed(MAX1164x_t* MAX1164x, bool spd)
{
 56c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 56e:	1c06      	adds	r6, r0, #0
 570:	368c      	adds	r6, #140	; 0x8c
 572:	4d16      	ldr	r5, [pc, #88]	; (5cc <MAX1164x_SetSpeed+0x60>)
 574:	4c16      	ldr	r4, [pc, #88]	; (5d0 <MAX1164x_SetSpeed+0x64>)
	// Switch the clock to external if high-speed is requested
	// And speed up the bit i2C bit rate
	if (spd == MAX1164x_SPD_HI)
 576:	2900      	cmp	r1, #0
 578:	d01b      	beq.n	5b2 <MAX1164x_SetSpeed+0x46>
	{
		// Set the UseStopFlag bool
		MAX1164x->UseStopFlag = FALSE;
 57a:	2300      	movs	r3, #0
 57c:	7033      	strb	r3, [r6, #0]

		I2C_InitiateHighSpeedMode(MAX1164x->i2cHandleMaster);
 57e:	6840      	ldr	r0, [r0, #4]
 580:	f000 f8fc 	bl	77c <I2C_InitiateHighSpeedMode>

		// Set I2C bitrate to normal "High Speed" mode
		if (LPC_I2CD_API->i2c_set_bitrate( localHandle,
 584:	682b      	ldr	r3, [r5, #0]
										   Chip_Clock_GetSystemClockRate(),
										   MAX1164x_HIGHSPEED_BITRATE) != LPC_OK )
 586:	6827      	ldr	r7, [r4, #0]
		MAX1164x->UseStopFlag = FALSE;

		I2C_InitiateHighSpeedMode(MAX1164x->i2cHandleMaster);

		// Set I2C bitrate to normal "High Speed" mode
		if (LPC_I2CD_API->i2c_set_bitrate( localHandle,
 588:	695b      	ldr	r3, [r3, #20]
 58a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 58c:	f000 f9b4 	bl	8f8 <Chip_Clock_GetSystemClockRate>
 590:	4a10      	ldr	r2, [pc, #64]	; (5d4 <MAX1164x_SetSpeed+0x68>)
 592:	1c01      	adds	r1, r0, #0
 594:	1c38      	adds	r0, r7, #0
 596:	47b0      	blx	r6
 598:	2800      	cmp	r0, #0
 59a:	d016      	beq.n	5ca <MAX1164x_SetSpeed+0x5e>
										   Chip_Clock_GetSystemClockRate(),
										   MAX1164x_HIGHSPEED_BITRATE) != LPC_OK )
		{
			// If we get here, it means the bus can't move that quickly. Back it off a bit.
			LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE);
 59c:	682b      	ldr	r3, [r5, #0]
 59e:	6824      	ldr	r4, [r4, #0]
 5a0:	695b      	ldr	r3, [r3, #20]
 5a2:	6b9d      	ldr	r5, [r3, #56]	; 0x38
 5a4:	f000 f9a8 	bl	8f8 <Chip_Clock_GetSystemClockRate>
 5a8:	4a0b      	ldr	r2, [pc, #44]	; (5d8 <MAX1164x_SetSpeed+0x6c>)
 5aa:	1c01      	adds	r1, r0, #0
 5ac:	1c20      	adds	r0, r4, #0
 5ae:	47a8      	blx	r5
 5b0:	e00b      	b.n	5ca <MAX1164x_SetSpeed+0x5e>

	}
	else
	{
		// If we get here, it means the bus can't move that quickly. Back it off a bit.
		LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE);
 5b2:	682b      	ldr	r3, [r5, #0]
 5b4:	6824      	ldr	r4, [r4, #0]
 5b6:	695b      	ldr	r3, [r3, #20]
 5b8:	6b9d      	ldr	r5, [r3, #56]	; 0x38
 5ba:	f000 f99d 	bl	8f8 <Chip_Clock_GetSystemClockRate>
 5be:	4a06      	ldr	r2, [pc, #24]	; (5d8 <MAX1164x_SetSpeed+0x6c>)
 5c0:	1c01      	adds	r1, r0, #0
 5c2:	1c20      	adds	r0, r4, #0
 5c4:	47a8      	blx	r5
		MAX1164x->UseStopFlag = TRUE;
 5c6:	2301      	movs	r3, #1
 5c8:	7033      	strb	r3, [r6, #0]
	}
}
 5ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 5cc:	1fff1ff8 	.word	0x1fff1ff8
 5d0:	10000000 	.word	0x10000000
 5d4:	000f4240 	.word	0x000f4240
 5d8:	00061a80 	.word	0x00061a80

000005dc <MAX1164x_RequestNewSample>:



ErrorCode_t MAX1164x_RequestNewSample(MAX1164x_t* MAX1164x)
{
 5dc:	b570      	push	{r4, r5, r6, lr}
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	MAX1164x->sample_buffer.buffer[0] = (MAX1164x_I2C_ADDR_7BIT << 1);
 5de:	1c03      	adds	r3, r0, #0
 5e0:	3388      	adds	r3, #136	; 0x88
 5e2:	226c      	movs	r2, #108	; 0x6c
}



ErrorCode_t MAX1164x_RequestNewSample(MAX1164x_t* MAX1164x)
{
 5e4:	b088      	sub	sp, #32
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	MAX1164x->sample_buffer.buffer[0] = (MAX1164x_I2C_ADDR_7BIT << 1);
 5e6:	701a      	strb	r2, [r3, #0]

	param.num_bytes_send    = 0;
 5e8:	2200      	movs	r2, #0
 5ea:	9202      	str	r2, [sp, #8]
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
 5ec:	2204      	movs	r2, #4
 5ee:	9203      	str	r2, [sp, #12]
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
 5f0:	9305      	str	r3, [sp, #20]
	param.stop_flag = MAX1164x->UseStopFlag;
 5f2:	308c      	adds	r0, #140	; 0x8c
 5f4:	7803      	ldrb	r3, [r0, #0]
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	MAX1164x->sample_buffer.buffer[0] = (MAX1164x_I2C_ADDR_7BIT << 1);

	param.num_bytes_send    = 0;
 5f6:	ac02      	add	r4, sp, #8
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
	param.stop_flag = MAX1164x->UseStopFlag;
 5f8:	7523      	strb	r3, [r4, #20]
	param.func_pt = MAX1164x_CBFunc;
 5fa:	4b0b      	ldr	r3, [pc, #44]	; (628 <MAX1164x_RequestNewSample+0x4c>)

	/* Set timeout (much) greater than the transfer length */
	LPC_I2CD_API->i2c_set_timeout(localHandle, 100000);
 5fc:	4e0b      	ldr	r6, [pc, #44]	; (62c <MAX1164x_RequestNewSample+0x50>)

	param.num_bytes_send    = 0;
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
	param.stop_flag = MAX1164x->UseStopFlag;
	param.func_pt = MAX1164x_CBFunc;
 5fe:	9306      	str	r3, [sp, #24]

	/* Set timeout (much) greater than the transfer length */
	LPC_I2CD_API->i2c_set_timeout(localHandle, 100000);
 600:	6833      	ldr	r3, [r6, #0]
 602:	4d0b      	ldr	r5, [pc, #44]	; (630 <MAX1164x_RequestNewSample+0x54>)
 604:	695b      	ldr	r3, [r3, #20]
 606:	6828      	ldr	r0, [r5, #0]
 608:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 60a:	490a      	ldr	r1, [pc, #40]	; (634 <MAX1164x_RequestNewSample+0x58>)
 60c:	4798      	blx	r3

	interruptErrorFlag = -1;
 60e:	4b0a      	ldr	r3, [pc, #40]	; (638 <MAX1164x_RequestNewSample+0x5c>)
 610:	2201      	movs	r2, #1
 612:	4252      	negs	r2, r2
 614:	601a      	str	r2, [r3, #0]

	/* Do master read transfer */
	int error =  LPC_I2CD_API->i2c_master_receive_intr(localHandle, &param, &result);
 616:	6833      	ldr	r3, [r6, #0]
 618:	6828      	ldr	r0, [r5, #0]
 61a:	695b      	ldr	r3, [r3, #20]
 61c:	1c21      	adds	r1, r4, #0
 61e:	695b      	ldr	r3, [r3, #20]
 620:	466a      	mov	r2, sp
 622:	4798      	blx	r3
///	while (interruptErrorFlag == -1) {
///		__WFI();
///	}

	return error;
}
 624:	b008      	add	sp, #32
 626:	bd70      	pop	{r4, r5, r6, pc}
 628:	00000491 	.word	0x00000491
 62c:	1fff1ff8 	.word	0x1fff1ff8
 630:	10000000 	.word	0x10000000
 634:	000186a0 	.word	0x000186a0
 638:	10000008 	.word	0x10000008

0000063c <I2C_IRQHandler>:


void I2C_IRQHandler(void)
{
 63c:	b508      	push	{r3, lr}
	/* Call I2C ISR function in ROM with the I2C handle */
	LPC_I2CD_API->i2c_isr_handler(localHandle);
 63e:	4b04      	ldr	r3, [pc, #16]	; (650 <I2C_IRQHandler+0x14>)
 640:	4a04      	ldr	r2, [pc, #16]	; (654 <I2C_IRQHandler+0x18>)
 642:	681b      	ldr	r3, [r3, #0]
 644:	6810      	ldr	r0, [r2, #0]
 646:	695b      	ldr	r3, [r3, #20]
 648:	681b      	ldr	r3, [r3, #0]
 64a:	4798      	blx	r3
}
 64c:	bd08      	pop	{r3, pc}
 64e:	46c0      	nop			; (mov r8, r8)
 650:	1fff1ff8 	.word	0x1fff1ff8
 654:	10000000 	.word	0x10000000

00000658 <TLV_Init>:
RINGBUFF_T TLC_TxBuffer;



void TLV_Init()
{
 658:	b538      	push	{r3, r4, r5, lr}
	// Prep the Transmit frame buffer
	RingBuffer_Init(&TLC_TxBuffer, &TLC_TxBufData, sizeof(uint16_t), TLV_BUFFER_SIZE);
 65a:	4913      	ldr	r1, [pc, #76]	; (6a8 <TLV_Init+0x50>)
 65c:	2202      	movs	r2, #2
 65e:	2364      	movs	r3, #100	; 0x64
 660:	4812      	ldr	r0, [pc, #72]	; (6ac <TLV_Init+0x54>)
 662:	f000 f96f 	bl	944 <RingBuffer_Init>
 * @note	The peripheral will stay in reset until reset is de-asserted. Call
 * Chip_SYSCTL_DeassertPeriphReset() to de-assert the reset
 */
STATIC INLINE void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL &= ~(1 << (uint32_t) periph);
 666:	4b12      	ldr	r3, [pc, #72]	; (6b0 <TLV_Init+0x58>)
 668:	2501      	movs	r5, #1
 66a:	685a      	ldr	r2, [r3, #4]
	Chip_SYSCTL_PeriphReset(RESET_SPI0);

	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_LO)) & ~((uint32_t) SPI_CFG_SPI_EN);
 66c:	4c11      	ldr	r4, [pc, #68]	; (6b4 <TLV_Init+0x5c>)
 66e:	43aa      	bics	r2, r5
 670:	605a      	str	r2, [r3, #4]
 * @param	periph	: Peripheral to de-assert reset for
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL |= (1 << (uint32_t) periph);
 672:	685a      	ldr	r2, [r3, #4]

	// Set the rate to 10MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 10000000));
 674:	1c20      	adds	r0, r4, #0
 676:	432a      	orrs	r2, r5
 678:	605a      	str	r2, [r3, #4]
	// Prep the Transmit frame buffer
	RingBuffer_Init(&TLC_TxBuffer, &TLC_TxBufData, sizeof(uint16_t), TLV_BUFFER_SIZE);
	Chip_SYSCTL_PeriphReset(RESET_SPI0);

	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_LO)) & ~((uint32_t) SPI_CFG_SPI_EN);
 67a:	2324      	movs	r3, #36	; 0x24
 67c:	6023      	str	r3, [r4, #0]

	// Set the rate to 10MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 10000000));
 67e:	490e      	ldr	r1, [pc, #56]	; (6b8 <TLV_Init+0x60>)
 680:	f000 f99a 	bl	9b8 <Chip_SPI_CalClkRateDivider>
 684:	b280      	uxth	r0, r0
 686:	6260      	str	r0, [r4, #36]	; 0x24
 * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_CLR_*)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
{
	pSPI->STAT |= Flag;
 688:	68a3      	ldr	r3, [r4, #8]
 68a:	223c      	movs	r2, #60	; 0x3c
 68c:	4313      	orrs	r3, r2
 68e:	60a3      	str	r3, [r4, #8]

	// Clear status flags
	Chip_SPI_ClearStatus(LPC_SPI0, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);

	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN | SPI_INTENCLR_RXDYEN | SPI_INTENCLR_RXOVEN | SPI_INTENCLR_TXUREN, DISABLE);
 690:	1c20      	adds	r0, r4, #0
 692:	210f      	movs	r1, #15
 694:	2200      	movs	r2, #0
 696:	f000 f997 	bl	9c8 <Chip_SPI_Int_Cmd>
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
{
	pSPI->CFG |= SPI_CFG_SPI_EN;
 69a:	6823      	ldr	r3, [r4, #0]
 69c:	432b      	orrs	r3, r5
 69e:	6023      	str	r3, [r4, #0]
 6a0:	4b06      	ldr	r3, [pc, #24]	; (6bc <TLV_Init+0x64>)
 6a2:	601d      	str	r5, [r3, #0]

	// Enable the SPI
	Chip_SPI_Enable(LPC_SPI0);
 	NVIC_EnableIRQ(SPI0_IRQn);
}
 6a4:	bd38      	pop	{r3, r4, r5, pc}
 6a6:	46c0      	nop			; (mov r8, r8)
 6a8:	10000020 	.word	0x10000020
 6ac:	1000000c 	.word	0x1000000c
 6b0:	40048000 	.word	0x40048000
 6b4:	40058000 	.word	0x40058000
 6b8:	00989680 	.word	0x00989680
 6bc:	e000e100 	.word	0xe000e100

000006c0 <TLV_SetDACValue>:

/***
 * Sets the value for the selected DAC.  Returns -1 on error, 0 on success
 */
int8_t TLV_SetDACValue(TLV_DACNumber DAC, TLV_Speed speed, uint16_t value)
{
 6c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint16_t frame = 0;

	// Code the frame with the right dac and speed
	switch(DAC)
 6c2:	2800      	cmp	r0, #0
 6c4:	d006      	beq.n	6d4 <TLV_SetDACValue+0x14>
 6c6:	2801      	cmp	r0, #1
 6c8:	d12c      	bne.n	724 <TLV_SetDACValue+0x64>
	{
	case(TLV_DAC_1):
			frame = TLV_R1(1) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 6ca:	0512      	lsls	r2, r2, #20
 6cc:	0389      	lsls	r1, r1, #14
 6ce:	0d12      	lsrs	r2, r2, #20
 6d0:	4311      	orrs	r1, r2
 6d2:	e006      	b.n	6e2 <TLV_SetDACValue+0x22>

	// Code the frame with the right dac and speed
	switch(DAC)
	{
	case(TLV_DAC_1):
			frame = TLV_R1(1) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 6d4:	4b15      	ldr	r3, [pc, #84]	; (72c <TLV_SetDACValue+0x6c>)
 6d6:	0512      	lsls	r2, r2, #20
 6d8:	0d12      	lsrs	r2, r2, #20
 6da:	431a      	orrs	r2, r3
 6dc:	038b      	lsls	r3, r1, #14
 6de:	1c11      	adds	r1, r2, #0
 6e0:	4319      	orrs	r1, r3
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
 */
STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
{
	return pSPI->STAT;
 6e2:	4813      	ldr	r0, [pc, #76]	; (730 <TLV_SetDACValue+0x70>)
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 6e4:	466b      	mov	r3, sp
 6e6:	6884      	ldr	r4, [r0, #8]
 6e8:	80d9      	strh	r1, [r3, #6]
 6ea:	466a      	mov	r2, sp
		return -1; //Error: Not a valid dac number
		break;
	}

	// If the SPI is ready and the buffer is empty.
    if ((Chip_SPI_GetStatus(LPC_SPI0) & SPI_STAT_TXRDY) && RingBuffer_IsEmpty(&TLC_TxBuffer))
 6ec:	2102      	movs	r1, #2
 6ee:	3206      	adds	r2, #6
 6f0:	4b10      	ldr	r3, [pc, #64]	; (734 <TLV_SetDACValue+0x74>)
 6f2:	420c      	tst	r4, r1
 6f4:	d00d      	beq.n	712 <TLV_SetDACValue+0x52>
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 6f6:	68dd      	ldr	r5, [r3, #12]
 6f8:	691c      	ldr	r4, [r3, #16]
 6fa:	42a5      	cmp	r5, r4
 6fc:	d109      	bne.n	712 <TLV_SetDACValue+0x52>
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 6fe:	8812      	ldrh	r2, [r2, #0]
 700:	23f7      	movs	r3, #247	; 0xf7
 702:	051b      	lsls	r3, r3, #20
 704:	4313      	orrs	r3, r2
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 706:	6183      	str	r3, [r0, #24]
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

		// enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN, ENABLE);
 708:	2201      	movs	r2, #1
 70a:	f000 f95d 	bl	9c8 <Chip_SPI_Int_Cmd>
	// Otherwise insert the new frame onto the buffer
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
	{
    	return -1;
	}
    return 0;
 70e:	2000      	movs	r0, #0
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

		// enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN, ENABLE);
 710:	e009      	b.n	726 <TLV_SetDACValue+0x66>
    }

	// Otherwise insert the new frame onto the buffer
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
 712:	1c18      	adds	r0, r3, #0
 714:	1c11      	adds	r1, r2, #0
 716:	f000 f91d 	bl	954 <RingBuffer_Insert>
 71a:	4243      	negs	r3, r0
 71c:	4158      	adcs	r0, r3
 71e:	4240      	negs	r0, r0
 720:	b2c0      	uxtb	r0, r0
 722:	e000      	b.n	726 <TLV_SetDACValue+0x66>
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
			break;
	default:
		return -1; //Error: Not a valid dac number
 724:	20ff      	movs	r0, #255	; 0xff
 726:	b240      	sxtb	r0, r0
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
	{
    	return -1;
	}
    return 0;
}
 728:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 72a:	46c0      	nop			; (mov r8, r8)
 72c:	ffff8000 	.word	0xffff8000
 730:	40058000 	.word	0x40058000
 734:	1000000c 	.word	0x1000000c

00000738 <SPI0_IRQHandler>:


void SPI0_IRQHandler(void)
{
 738:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN, DISABLE);
 73a:	4c0e      	ldr	r4, [pc, #56]	; (774 <SPI0_IRQHandler+0x3c>)
 73c:	2200      	movs	r2, #0
 73e:	1c20      	adds	r0, r4, #0
 740:	2102      	movs	r1, #2
 742:	f000 f941 	bl	9c8 <Chip_SPI_Int_Cmd>
 746:	480c      	ldr	r0, [pc, #48]	; (778 <SPI0_IRQHandler+0x40>)
 748:	68c2      	ldr	r2, [r0, #12]
 74a:	6903      	ldr	r3, [r0, #16]

	// If the buffer isn't empty, load up the next frame
	if (!RingBuffer_IsEmpty(&TLC_TxBuffer))
 74c:	429a      	cmp	r2, r3
 74e:	d010      	beq.n	772 <SPI0_IRQHandler+0x3a>
	{
		// Get the next value
		uint16_t frame = 0;
 750:	466d      	mov	r5, sp
 752:	2300      	movs	r3, #0
 754:	80eb      	strh	r3, [r5, #6]
 756:	3506      	adds	r5, #6
		RingBuffer_Pop(&TLC_TxBuffer, &frame);
 758:	1c29      	adds	r1, r5, #0
 75a:	f000 f915 	bl	988 <RingBuffer_Pop>
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 75e:	882a      	ldrh	r2, [r5, #0]
 760:	23f7      	movs	r3, #247	; 0xf7
 762:	051b      	lsls	r3, r3, #20
 764:	4313      	orrs	r3, r2
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 766:	61a3      	str	r3, [r4, #24]
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

    	// Enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN , ENABLE);
 768:	1c20      	adds	r0, r4, #0
 76a:	2102      	movs	r1, #2
 76c:	2201      	movs	r2, #1
 76e:	f000 f92b 	bl	9c8 <Chip_SPI_Int_Cmd>
	}
}
 772:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 774:	40058000 	.word	0x40058000
 778:	1000000c 	.word	0x1000000c

0000077c <I2C_InitiateHighSpeedMode>:

/***
 * Remember to set the pins to operate in high-speed mode if using this function
 */
ErrorCode_t I2C_InitiateHighSpeedMode(I2C_HANDLE_T I2CHandle)
{
 77c:	b570      	push	{r4, r5, r6, lr}
 77e:	b08a      	sub	sp, #40	; 0x28
	uint8_t HighSpeed = I2C_MASTERCMD_HIGHSPEED;
 780:	466b      	mov	r3, sp
 782:	220f      	movs	r2, #15
 784:	71da      	strb	r2, [r3, #7]
 786:	3307      	adds	r3, #7
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
	param.buffer_ptr_send   = &HighSpeed;
 788:	9306      	str	r3, [sp, #24]
{
	uint8_t HighSpeed = I2C_MASTERCMD_HIGHSPEED;
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
 78a:	ac04      	add	r4, sp, #16
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
 78c:	2300      	movs	r3, #0
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!

	LPC_I2CD_API->i2c_set_timeout(I2CHandle, 1000);
 78e:	4e0a      	ldr	r6, [pc, #40]	; (7b8 <I2C_InitiateHighSpeedMode+0x3c>)
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!
 790:	7523      	strb	r3, [r4, #20]
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
 792:	9305      	str	r3, [sp, #20]
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!

	LPC_I2CD_API->i2c_set_timeout(I2CHandle, 1000);
 794:	6833      	ldr	r3, [r6, #0]
{
	uint8_t HighSpeed = I2C_MASTERCMD_HIGHSPEED;
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
 796:	2201      	movs	r2, #1
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!

	LPC_I2CD_API->i2c_set_timeout(I2CHandle, 1000);
 798:	695b      	ldr	r3, [r3, #20]
 79a:	21fa      	movs	r1, #250	; 0xfa
{
	uint8_t HighSpeed = I2C_MASTERCMD_HIGHSPEED;
	I2C_PARAM_T param;
	I2C_RESULT_T result;

	param.num_bytes_send    = 1;
 79c:	9204      	str	r2, [sp, #16]
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!

	LPC_I2CD_API->i2c_set_timeout(I2CHandle, 1000);
 79e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 7a0:	0089      	lsls	r1, r1, #2

/***
 * Remember to set the pins to operate in high-speed mode if using this function
 */
ErrorCode_t I2C_InitiateHighSpeedMode(I2C_HANDLE_T I2CHandle)
{
 7a2:	1c05      	adds	r5, r0, #0
	param.num_bytes_send    = 1;
	param.buffer_ptr_send   = &HighSpeed;
	param.num_bytes_rec     = 0;
	param.stop_flag         = 0; // No stop flags after going into high-speed mode!

	LPC_I2CD_API->i2c_set_timeout(I2CHandle, 1000);
 7a4:	4798      	blx	r3

	// Write the message, return the errors.
	return  LPC_I2CD_API->i2c_master_transmit_poll(I2CHandle, &param, &result);
 7a6:	6833      	ldr	r3, [r6, #0]
 7a8:	1c28      	adds	r0, r5, #0
 7aa:	695b      	ldr	r3, [r3, #20]
 7ac:	1c21      	adds	r1, r4, #0
 7ae:	685b      	ldr	r3, [r3, #4]
 7b0:	aa02      	add	r2, sp, #8
 7b2:	4798      	blx	r3
}
 7b4:	b00a      	add	sp, #40	; 0x28
 7b6:	bd70      	pop	{r4, r5, r6, pc}
 7b8:	1fff1ff8 	.word	0x1fff1ff8

000007bc <Chip_ACMP_SetupAMCPRefs>:

/* Helper function for setting up ACMP control */
void Chip_ACMP_SetupAMCPRefs(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel,
							 ACMP_POS_INPUT_T Posinput, ACMP_NEG_INPUT_T Neginput,
							 ACMP_HYS_T hys)
{
 7bc:	b530      	push	{r4, r5, lr}
	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK |
 7be:	6805      	ldr	r5, [r0, #0]
 7c0:	4c04      	ldr	r4, [pc, #16]	; (7d4 <Chip_ACMP_SetupAMCPRefs+0x18>)
 7c2:	402c      	ands	r4, r5
								   ACMP_COMPVMSEL_MASK | ACMP_COMPVPSEL_MASK | ACMP_EDGESEL_MASK);

	/* Select negative input */
	pACMP->CTRL = reg | (uint32_t) edgeSel | (uint32_t) Posinput |
 7c4:	4321      	orrs	r1, r4
 7c6:	430a      	orrs	r2, r1
 7c8:	431a      	orrs	r2, r3
				  (uint32_t) Neginput | (uint32_t) hys;
 7ca:	9b03      	ldr	r3, [sp, #12]
 7cc:	431a      	orrs	r2, r3
{
	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK |
								   ACMP_COMPVMSEL_MASK | ACMP_COMPVPSEL_MASK | ACMP_EDGESEL_MASK);

	/* Select negative input */
	pACMP->CTRL = reg | (uint32_t) edgeSel | (uint32_t) Posinput |
 7ce:	6002      	str	r2, [r0, #0]
				  (uint32_t) Neginput | (uint32_t) hys;
}
 7d0:	bd30      	pop	{r4, r5, pc}
 7d2:	46c0      	nop			; (mov r8, r8)
 7d4:	f9ffc0e7 	.word	0xf9ffc0e7

000007d8 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 7d8:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 7da:	f000 f88d 	bl	8f8 <Chip_Clock_GetSystemClockRate>
 7de:	4b01      	ldr	r3, [pc, #4]	; (7e4 <SystemCoreClockUpdate+0xc>)
 7e0:	6018      	str	r0, [r3, #0]
}
 7e2:	bd08      	pop	{r3, pc}
 7e4:	100000e8 	.word	0x100000e8

000007e8 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 7e8:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 7ea:	05c2      	lsls	r2, r0, #23
 7ec:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 7ee:	211f      	movs	r1, #31
 7f0:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 7f2:	0092      	lsls	r2, r2, #2
 7f4:	4b03      	ldr	r3, [pc, #12]	; (804 <Chip_Clock_GetWDTLFORate+0x1c>)
 7f6:	58d0      	ldr	r0, [r2, r3]
 7f8:	3101      	adds	r1, #1
 7fa:	0049      	lsls	r1, r1, #1
 7fc:	f000 f94b 	bl	a96 <__aeabi_uidiv>
}
 800:	bd08      	pop	{r3, pc}
 802:	46c0      	nop			; (mov r8, r8)
 804:	00000b40 	.word	0x00000b40

00000808 <Chip_Clock_GetPLLFreq>:

/* Compute a PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t msel = ((PLLReg & 0x1F) + 1);
 808:	231f      	movs	r3, #31
 80a:	4018      	ands	r0, r3
 80c:	3001      	adds	r0, #1

	return inputRate * msel;
 80e:	4348      	muls	r0, r1
}
 810:	4770      	bx	lr
 812:	46c0      	nop			; (mov r8, r8)

00000814 <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 814:	4b03      	ldr	r3, [pc, #12]	; (824 <Chip_Clock_SetSystemPLLSource+0x10>)
 816:	6418      	str	r0, [r3, #64]	; 0x40
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;
 818:	2200      	movs	r2, #0
 81a:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;
 81c:	2201      	movs	r2, #1
 81e:	645a      	str	r2, [r3, #68]	; 0x44
}
 820:	4770      	bx	lr
 822:	46c0      	nop			; (mov r8, r8)
 824:	40048000 	.word	0x40048000

00000828 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 828:	4b03      	ldr	r3, [pc, #12]	; (838 <Chip_Clock_SetMainClockSource+0x10>)
 82a:	6718      	str	r0, [r3, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN  = 0;
 82c:	2200      	movs	r2, #0
 82e:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 830:	2201      	movs	r2, #1
 832:	675a      	str	r2, [r3, #116]	; 0x74
}
 834:	4770      	bx	lr
 836:	46c0      	nop			; (mov r8, r8)
 838:	40048000 	.word	0x40048000

0000083c <Chip_Clock_SetCLKOUTSource>:

/* Set CLKOUT clock source and divider */
void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
{
	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
 83c:	4b05      	ldr	r3, [pc, #20]	; (854 <Chip_Clock_SetCLKOUTSource+0x18>)
 83e:	22e0      	movs	r2, #224	; 0xe0
 840:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 0;
 842:	22e4      	movs	r2, #228	; 0xe4
 844:	2000      	movs	r0, #0
 846:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 1;
 848:	2001      	movs	r0, #1
 84a:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTDIV = div;
 84c:	22e8      	movs	r2, #232	; 0xe8
 84e:	5099      	str	r1, [r3, r2]
}
 850:	4770      	bx	lr
 852:	46c0      	nop			; (mov r8, r8)
 854:	40048000 	.word	0x40048000

00000858 <Chip_Clock_GetWDTOSCRate>:

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 858:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 85a:	4b02      	ldr	r3, [pc, #8]	; (864 <Chip_Clock_GetWDTOSCRate+0xc>)
 85c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 85e:	f7ff ffc3 	bl	7e8 <Chip_Clock_GetWDTLFORate>
}
 862:	bd08      	pop	{r3, pc}
 864:	40048000 	.word	0x40048000

00000868 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 868:	4b09      	ldr	r3, [pc, #36]	; (890 <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 86a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 86c:	2303      	movs	r3, #3
 86e:	4013      	ands	r3, r2
 870:	2b01      	cmp	r3, #1
 872:	d005      	beq.n	880 <Chip_Clock_GetSystemPLLInClockRate+0x18>
 874:	2b03      	cmp	r3, #3
 876:	d006      	beq.n	886 <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 878:	2b00      	cmp	r3, #0
 87a:	d107      	bne.n	88c <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 87c:	4805      	ldr	r0, [pc, #20]	; (894 <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 87e:	e006      	b.n	88e <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 880:	4b05      	ldr	r3, [pc, #20]	; (898 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 882:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 884:	e003      	b.n	88e <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 886:	4b05      	ldr	r3, [pc, #20]	; (89c <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 888:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 88a:	e000      	b.n	88e <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 88c:	2000      	movs	r0, #0
		break;
	}

	return clkRate;
}
 88e:	4770      	bx	lr
 890:	40048000 	.word	0x40048000
 894:	00b71b00 	.word	0x00b71b00
 898:	00000b38 	.word	0x00000b38
 89c:	00000b3c 	.word	0x00000b3c

000008a0 <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 8a0:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 8a2:	4b04      	ldr	r3, [pc, #16]	; (8b4 <Chip_Clock_GetSystemPLLOutClockRate+0x14>)
 8a4:	689c      	ldr	r4, [r3, #8]
 8a6:	f7ff ffdf 	bl	868 <Chip_Clock_GetSystemPLLInClockRate>
 8aa:	1c01      	adds	r1, r0, #0
 8ac:	1c20      	adds	r0, r4, #0
 8ae:	f7ff ffab 	bl	808 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 8b2:	bd10      	pop	{r4, pc}
 8b4:	40048000 	.word	0x40048000

000008b8 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 8b8:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 8ba:	4b0d      	ldr	r3, [pc, #52]	; (8f0 <Chip_Clock_GetMainClockRate+0x38>)
 8bc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8be:	2303      	movs	r3, #3
 8c0:	4013      	ands	r3, r2
 8c2:	2b01      	cmp	r3, #1
 8c4:	d009      	beq.n	8da <Chip_Clock_GetMainClockRate+0x22>
 8c6:	dc02      	bgt.n	8ce <Chip_Clock_GetMainClockRate+0x16>
 8c8:	2b00      	cmp	r3, #0
 8ca:	d00f      	beq.n	8ec <Chip_Clock_GetMainClockRate+0x34>
 8cc:	e003      	b.n	8d6 <Chip_Clock_GetMainClockRate+0x1e>
 8ce:	2b02      	cmp	r3, #2
 8d0:	d006      	beq.n	8e0 <Chip_Clock_GetMainClockRate+0x28>
 8d2:	2b03      	cmp	r3, #3
 8d4:	d007      	beq.n	8e6 <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 8d6:	2000      	movs	r0, #0
 8d8:	e009      	b.n	8ee <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 8da:	f7ff ffc5 	bl	868 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 8de:	e006      	b.n	8ee <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 8e0:	f7ff ffba 	bl	858 <Chip_Clock_GetWDTOSCRate>
		break;
 8e4:	e003      	b.n	8ee <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 8e6:	f7ff ffdb 	bl	8a0 <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 8ea:	e000      	b.n	8ee <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 8ec:	4801      	ldr	r0, [pc, #4]	; (8f4 <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 8ee:	bd08      	pop	{r3, pc}
 8f0:	40048000 	.word	0x40048000
 8f4:	00b71b00 	.word	0x00b71b00

000008f8 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 8f8:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 8fa:	f7ff ffdd 	bl	8b8 <Chip_Clock_GetMainClockRate>
 8fe:	4b02      	ldr	r3, [pc, #8]	; (908 <Chip_Clock_GetSystemClockRate+0x10>)
 900:	6f99      	ldr	r1, [r3, #120]	; 0x78
 902:	f000 f8c8 	bl	a96 <__aeabi_uidiv>
}
 906:	bd08      	pop	{r3, pc}
 908:	40048000 	.word	0x40048000

0000090c <Chip_I2C_Init>:
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 90c:	4b06      	ldr	r3, [pc, #24]	; (928 <Chip_I2C_Init+0x1c>)
 90e:	2280      	movs	r2, #128	; 0x80
 910:	5898      	ldr	r0, [r3, r2]
 912:	2120      	movs	r1, #32
 914:	4301      	orrs	r1, r0
 916:	5099      	str	r1, [r3, r2]
 * @note	The peripheral will stay in reset until reset is de-asserted. Call
 * Chip_SYSCTL_DeassertPeriphReset() to de-assert the reset
 */
STATIC INLINE void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL &= ~(1 << (uint32_t) periph);
 918:	6859      	ldr	r1, [r3, #4]
 91a:	2240      	movs	r2, #64	; 0x40
 91c:	4391      	bics	r1, r2
 91e:	6059      	str	r1, [r3, #4]
 * @param	periph	: Peripheral to de-assert reset for
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL |= (1 << (uint32_t) periph);
 920:	6859      	ldr	r1, [r3, #4]
 922:	430a      	orrs	r2, r1
 924:	605a      	str	r2, [r3, #4]
{
	/* Enable I2C clock */
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_I2C);
	/* Peripheral reset control to I2C */
	Chip_SYSCTL_PeriphReset(RESET_I2C);
}
 926:	4770      	bx	lr
 928:	40048000 	.word	0x40048000

0000092c <Chip_IOCON_PinSetI2CMode>:
	pIOCON->PIO0[pin] = reg | (clkdiv << PIN_CLKDIV_BITNUM);
}

/* Set the I2C mode for a pin. */
void Chip_IOCON_PinSetI2CMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_I2CMODE_T mode)
{
 92c:	b510      	push	{r4, lr}
	uint32_t reg;

	/* I2C mode bits only for I2C pins */
	reg = pIOCON->PIO0[pin] & ~(PIN_I2CMODE_MASK);
 92e:	0089      	lsls	r1, r1, #2
 930:	580c      	ldr	r4, [r1, r0]
 932:	4b03      	ldr	r3, [pc, #12]	; (940 <Chip_IOCON_PinSetI2CMode+0x14>)
 934:	4023      	ands	r3, r4
	pIOCON->PIO0[pin] = reg | (mode << PIN_I2CMODE_BITNUM);
 936:	0212      	lsls	r2, r2, #8
 938:	431a      	orrs	r2, r3
 93a:	500a      	str	r2, [r1, r0]
}
 93c:	bd10      	pop	{r4, pc}
 93e:	46c0      	nop			; (mov r8, r8)
 940:	fffffcff 	.word	0xfffffcff

00000944 <RingBuffer_Init>:
 ****************************************************************************/

/* Initialize ring buffer */
int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
{
	RingBuff->data = buffer;
 944:	6001      	str	r1, [r0, #0]
	RingBuff->count = count;
 946:	6043      	str	r3, [r0, #4]
	RingBuff->itemSz = itemSize;
 948:	6082      	str	r2, [r0, #8]
	RingBuff->head = RingBuff->tail = 0;
 94a:	2300      	movs	r3, #0
 94c:	6103      	str	r3, [r0, #16]
 94e:	60c3      	str	r3, [r0, #12]

	return 1;
}
 950:	2001      	movs	r0, #1
 952:	4770      	bx	lr

00000954 <RingBuffer_Insert>:

/* Insert a single item into Ring Buffer */
int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
{
 954:	b538      	push	{r3, r4, r5, lr}
 956:	1c04      	adds	r4, r0, #0
	uint8_t *ptr = RingBuff->data;
 958:	6805      	ldr	r5, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 95a:	68c2      	ldr	r2, [r0, #12]
 95c:	6903      	ldr	r3, [r0, #16]
 95e:	1ad2      	subs	r2, r2, r3
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is full, otherwise 0
 */
STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
{
	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
 960:	6843      	ldr	r3, [r0, #4]

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
 962:	429a      	cmp	r2, r3
 964:	da0d      	bge.n	982 <RingBuffer_Insert+0x2e>
		return 0;

	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
 966:	3b01      	subs	r3, #1
 968:	68c2      	ldr	r2, [r0, #12]
 96a:	4013      	ands	r3, r2
 96c:	6882      	ldr	r2, [r0, #8]
 96e:	1c10      	adds	r0, r2, #0
 970:	4358      	muls	r0, r3
 972:	1828      	adds	r0, r5, r0
	memcpy(ptr, data, RingBuff->itemSz);
 974:	f000 f884 	bl	a80 <memcpy>
	RingBuff->head++;
 978:	68e3      	ldr	r3, [r4, #12]
 97a:	3301      	adds	r3, #1
 97c:	60e3      	str	r3, [r4, #12]

	return 1;
 97e:	2001      	movs	r0, #1
 980:	e000      	b.n	984 <RingBuffer_Insert+0x30>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
		return 0;
 982:	2000      	movs	r0, #0
	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
	memcpy(ptr, data, RingBuff->itemSz);
	RingBuff->head++;

	return 1;
}
 984:	bd38      	pop	{r3, r4, r5, pc}
 986:	46c0      	nop			; (mov r8, r8)

00000988 <RingBuffer_Pop>:
	return cnt1 + cnt2;
}

/* Pop single item from Ring Buffer */
int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data)
{
 988:	b510      	push	{r4, lr}
 98a:	1c04      	adds	r4, r0, #0
 98c:	1c08      	adds	r0, r1, #0
	uint8_t *ptr = RingBuff->data;
 98e:	6821      	ldr	r1, [r4, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 990:	68e2      	ldr	r2, [r4, #12]
 992:	6923      	ldr	r3, [r4, #16]

	/* We cannot pop when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
 994:	429a      	cmp	r2, r3
 996:	d00d      	beq.n	9b4 <RingBuffer_Pop+0x2c>
		return 0;

	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
 998:	6863      	ldr	r3, [r4, #4]
 99a:	3b01      	subs	r3, #1
 99c:	6922      	ldr	r2, [r4, #16]
 99e:	4013      	ands	r3, r2
 9a0:	68a2      	ldr	r2, [r4, #8]
 9a2:	4353      	muls	r3, r2
 9a4:	18c9      	adds	r1, r1, r3
	memcpy(data, ptr, RingBuff->itemSz);
 9a6:	f000 f86b 	bl	a80 <memcpy>
	RingBuff->tail++;
 9aa:	6923      	ldr	r3, [r4, #16]
 9ac:	3301      	adds	r3, #1
 9ae:	6123      	str	r3, [r4, #16]

	return 1;
 9b0:	2001      	movs	r0, #1
 9b2:	e000      	b.n	9b6 <RingBuffer_Pop+0x2e>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot pop when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;
 9b4:	2000      	movs	r0, #0
	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
	memcpy(data, ptr, RingBuff->itemSz);
	RingBuff->tail++;

	return 1;
}
 9b6:	bd10      	pop	{r4, pc}

000009b8 <Chip_SPI_CalClkRateDivider>:
 * Public functions
 ****************************************************************************/

/* Calculate the Clock Rate Divider for SPI Peripheral */
uint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
{
 9b8:	b510      	push	{r4, lr}
 9ba:	1c0c      	adds	r4, r1, #0
	uint32_t SPIClk;
	uint32_t DivVal = 1;

	/* Get SPI clock rate */
	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
 9bc:	f7ff ff9c 	bl	8f8 <Chip_Clock_GetSystemClockRate>

	DivVal = SPIClk / bitRate;
 9c0:	1c21      	adds	r1, r4, #0
 9c2:	f000 f868 	bl	a96 <__aeabi_uidiv>

	return DivVal;
}
 9c6:	bd10      	pop	{r4, pc}

000009c8 <Chip_SPI_Int_Cmd>:
}

/* Disable/Enable Interrupt */
void Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
{
	if (NewState ==  ENABLE) {
 9c8:	2a01      	cmp	r2, #1
 9ca:	d103      	bne.n	9d4 <Chip_SPI_Int_Cmd+0xc>
		pSPI->INTENSET |= IntMask;
 9cc:	68c3      	ldr	r3, [r0, #12]
 9ce:	4319      	orrs	r1, r3
 9d0:	60c1      	str	r1, [r0, #12]
 9d2:	e002      	b.n	9da <Chip_SPI_Int_Cmd+0x12>
	}
	else {
		pSPI->INTENCLR |= IntMask;
 9d4:	6903      	ldr	r3, [r0, #16]
 9d6:	4319      	orrs	r1, r3
 9d8:	6101      	str	r1, [r0, #16]
	}
}
 9da:	4770      	bx	lr

000009dc <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 9dc:	4a05      	ldr	r2, [pc, #20]	; (9f4 <Chip_SYSCTL_PowerDown+0x18>)
 9de:	238e      	movs	r3, #142	; 0x8e
 9e0:	009b      	lsls	r3, r3, #2
 9e2:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 9e4:	4308      	orrs	r0, r1
 9e6:	4904      	ldr	r1, [pc, #16]	; (9f8 <Chip_SYSCTL_PowerDown+0x1c>)
 9e8:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 9ea:	4904      	ldr	r1, [pc, #16]	; (9fc <Chip_SYSCTL_PowerDown+0x20>)
 9ec:	4308      	orrs	r0, r1
 9ee:	50d0      	str	r0, [r2, r3]
}
 9f0:	4770      	bx	lr
 9f2:	46c0      	nop			; (mov r8, r8)
 9f4:	40048000 	.word	0x40048000
 9f8:	000080ef 	.word	0x000080ef
 9fc:	00006d10 	.word	0x00006d10

00000a00 <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 a00:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 a02:	4a06      	ldr	r2, [pc, #24]	; (a1c <Chip_SYSCTL_PowerUp+0x1c>)
 a04:	238e      	movs	r3, #142	; 0x8e
 a06:	009b      	lsls	r3, r3, #2
 a08:	58d4      	ldr	r4, [r2, r3]
 a0a:	4905      	ldr	r1, [pc, #20]	; (a20 <Chip_SYSCTL_PowerUp+0x20>)
 a0c:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 a0e:	4001      	ands	r1, r0
 a10:	438c      	bics	r4, r1
 a12:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 a14:	4803      	ldr	r0, [pc, #12]	; (a24 <Chip_SYSCTL_PowerUp+0x24>)
 a16:	4301      	orrs	r1, r0
 a18:	50d1      	str	r1, [r2, r3]
}
 a1a:	bd10      	pop	{r4, pc}
 a1c:	40048000 	.word	0x40048000
 a20:	000080ef 	.word	0x000080ef
 a24:	00006d10 	.word	0x00006d10

00000a28 <Chip_SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 a28:	b508      	push	{r3, lr}
#if defined (USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 a2a:	2002      	movs	r0, #2
 a2c:	f7ff ffe8 	bl	a00 <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 a30:	2000      	movs	r0, #0
 a32:	f7ff feef 	bl	814 <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~(0x3));
 a36:	4b10      	ldr	r3, [pc, #64]	; (a78 <Chip_SystemInit+0x50>)
 a38:	691a      	ldr	r2, [r3, #16]
 a3a:	2103      	movs	r1, #3
 a3c:	438a      	bics	r2, r1

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 a3e:	2101      	movs	r1, #1
 a40:	430a      	orrs	r2, r1
 a42:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 a44:	2080      	movs	r0, #128	; 0x80
 a46:	f7ff ffc9 	bl	9dc <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 a4a:	2241      	movs	r2, #65	; 0x41
 a4c:	4b0b      	ldr	r3, [pc, #44]	; (a7c <Chip_SystemInit+0x54>)
 a4e:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 a50:	2080      	movs	r0, #128	; 0x80
 a52:	f7ff ffd5 	bl	a00 <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 a56:	4909      	ldr	r1, [pc, #36]	; (a7c <Chip_SystemInit+0x54>)
 a58:	2201      	movs	r2, #1
 a5a:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 a5c:	421a      	tst	r2, r3
 a5e:	d0fc      	beq.n	a5a <Chip_SystemInit+0x32>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 a60:	2201      	movs	r2, #1
 a62:	4b06      	ldr	r3, [pc, #24]	; (a7c <Chip_SystemInit+0x54>)
 a64:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 a66:	2003      	movs	r0, #3
 a68:	f7ff fede 	bl	828 <Chip_Clock_SetMainClockSource>
#endif

	/* Select the CLKOUT clocking source */
	Chip_Clock_SetCLKOUTSource(SYSCTL_CLKOUTSRC_MAINSYSCLK, 1);
 a6c:	2003      	movs	r0, #3
 a6e:	2101      	movs	r1, #1
 a70:	f7ff fee4 	bl	83c <Chip_Clock_SetCLKOUTSource>
}
 a74:	bd08      	pop	{r3, pc}
 a76:	46c0      	nop			; (mov r8, r8)
 a78:	40040000 	.word	0x40040000
 a7c:	40048000 	.word	0x40048000

00000a80 <memcpy>:
 a80:	b508      	push	{r3, lr}
 a82:	f000 f842 	bl	b0a <__aeabi_memcpy>
 a86:	bd08      	pop	{r3, pc}

00000a88 <__weak_main>:
 a88:	b508      	push	{r3, lr}
 a8a:	f7ff fc39 	bl	300 <main>
 a8e:	bd08      	pop	{r3, pc}

00000a90 <__aeabi_idiv>:
 a90:	0003      	movs	r3, r0
 a92:	430b      	orrs	r3, r1
 a94:	d421      	bmi.n	ada <idiv_negative>

00000a96 <__aeabi_uidiv>:
 a96:	2900      	cmp	r1, #0
 a98:	d031      	beq.n	afe <idiv_divzero>
 a9a:	2201      	movs	r2, #1
 a9c:	07d2      	lsls	r2, r2, #31
 a9e:	0903      	lsrs	r3, r0, #4
 aa0:	e001      	b.n	aa6 <div_search4a>

00000aa2 <div_search4>:
 aa2:	0109      	lsls	r1, r1, #4
 aa4:	0912      	lsrs	r2, r2, #4

00000aa6 <div_search4a>:
 aa6:	4299      	cmp	r1, r3
 aa8:	d9fb      	bls.n	aa2 <div_search4>
 aaa:	0843      	lsrs	r3, r0, #1
 aac:	e001      	b.n	ab2 <div_search1a>

00000aae <div_search1>:
 aae:	0049      	lsls	r1, r1, #1
 ab0:	0852      	lsrs	r2, r2, #1

00000ab2 <div_search1a>:
 ab2:	4299      	cmp	r1, r3
 ab4:	d9fb      	bls.n	aae <div_search1>
 ab6:	e000      	b.n	aba <div_loop1a>

00000ab8 <div_loop1>:
 ab8:	0849      	lsrs	r1, r1, #1

00000aba <div_loop1a>:
 aba:	1a40      	subs	r0, r0, r1
 abc:	d307      	bcc.n	ace <div1>

00000abe <div2>:
 abe:	4152      	adcs	r2, r2
 ac0:	d3fa      	bcc.n	ab8 <div_loop1>
 ac2:	4601      	mov	r1, r0
 ac4:	4610      	mov	r0, r2
 ac6:	4770      	bx	lr

00000ac8 <div_loop2>:
 ac8:	0849      	lsrs	r1, r1, #1
 aca:	1840      	adds	r0, r0, r1
 acc:	d2f7      	bcs.n	abe <div2>

00000ace <div1>:
 ace:	1892      	adds	r2, r2, r2
 ad0:	d3fa      	bcc.n	ac8 <div_loop2>
 ad2:	1840      	adds	r0, r0, r1
 ad4:	4601      	mov	r1, r0
 ad6:	4610      	mov	r0, r2
 ad8:	4770      	bx	lr

00000ada <idiv_negative>:
 ada:	0fcb      	lsrs	r3, r1, #31
 adc:	d000      	beq.n	ae0 <idiv_neg1>
 ade:	4249      	negs	r1, r1

00000ae0 <idiv_neg1>:
 ae0:	1002      	asrs	r2, r0, #32
 ae2:	d500      	bpl.n	ae6 <idiv_neg2>
 ae4:	4240      	negs	r0, r0

00000ae6 <idiv_neg2>:
 ae6:	4053      	eors	r3, r2
 ae8:	b508      	push	{r3, lr}
 aea:	f7ff ffd4 	bl	a96 <__aeabi_uidiv>
 aee:	bc0c      	pop	{r2, r3}

00000af0 <idiv_sign>:
 af0:	1052      	asrs	r2, r2, #1
 af2:	d300      	bcc.n	af6 <idiv_sign1>
 af4:	4240      	negs	r0, r0

00000af6 <idiv_sign1>:
 af6:	2a00      	cmp	r2, #0
 af8:	d500      	bpl.n	afc <idiv_ret>
 afa:	4249      	negs	r1, r1

00000afc <idiv_ret>:
 afc:	4718      	bx	r3

00000afe <idiv_divzero>:
 afe:	46f4      	mov	ip, lr
 b00:	2000      	movs	r0, #0
 b02:	f000 f801 	bl	b08 <__aeabi_idiv0>
 b06:	4760      	bx	ip

00000b08 <__aeabi_idiv0>:
 b08:	4770      	bx	lr

00000b0a <__aeabi_memcpy>:
 b0a:	4684      	mov	ip, r0
 b0c:	0783      	lsls	r3, r0, #30
 b0e:	d108      	bne.n	b22 <copy1_start>
 b10:	078b      	lsls	r3, r1, #30
 b12:	d106      	bne.n	b22 <copy1_start>
 b14:	1f13      	subs	r3, r2, #4
 b16:	d304      	bcc.n	b22 <copy1_start>

00000b18 <copy4>:
 b18:	c904      	ldmia	r1!, {r2}
 b1a:	c004      	stmia	r0!, {r2}
 b1c:	3b04      	subs	r3, #4
 b1e:	d2fb      	bcs.n	b18 <copy4>
 b20:	1d1a      	adds	r2, r3, #4

00000b22 <copy1_start>:
 b22:	4252      	negs	r2, r2
 b24:	d005      	beq.n	b32 <copy1_ret>
 b26:	1a89      	subs	r1, r1, r2
 b28:	1a80      	subs	r0, r0, r2

00000b2a <copy1>:
 b2a:	5c8b      	ldrb	r3, [r1, r2]
 b2c:	5483      	strb	r3, [r0, r2]
 b2e:	3201      	adds	r2, #1
 b30:	d1fb      	bne.n	b2a <copy1>

00000b32 <copy1_ret>:
 b32:	4660      	mov	r0, ip
 b34:	4770      	bx	lr
	...

00000b38 <OscRateIn>:
 b38:	1b00 00b7                                   ....

00000b3c <ExtRateIn>:
 b3c:	0000 0000                                   ....

00000b40 <wdtOSCRate>:
 b40:	0000 0000 27c0 0009 0590 0010 5cc0 0015     .....'.......\..
 b50:	b3f0 001a 0b20 0020 9f00 0024 32e0 0029     .... . ...$..2).
 b60:	c6c0 002d 9750 0031 67e0 0035 3870 0039     ..-.P.1..g5.p89.
 b70:	0900 003d 1640 0040 2380 0043 30c0 0046     ..=.@.@..#C..0F.
