
Etude-OpAmpADC.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 10 00 10 ed 00 00 00 d5 00 00 00 d9 00 00 00     ................
	...
  2c:	dd 00 00 00 00 00 00 00 00 00 00 00 e1 00 00 00     ................
  3c:	e5 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  4c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  5c:	00 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................
  6c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  7c:	e9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................
  b0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000624 	.word	0x00000624
  c4:	10000000 	.word	0x10000000
  c8:	00000000 	.word	0x00000000

000000cc <__bss_section_table>:
  cc:	10000000 	.word	0x10000000
  d0:	00000004 	.word	0x00000004

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>
  d6:	46c0      	nop			; (mov r8, r8)

000000d8 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d8:	e7fe      	b.n	d8 <HardFault_Handler>
  da:	46c0      	nop			; (mov r8, r8)

000000dc <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  dc:	e7fe      	b.n	dc <SVC_Handler>
  de:	46c0      	nop			; (mov r8, r8)

000000e0 <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  e0:	e7fe      	b.n	e0 <PendSV_Handler>
  e2:	46c0      	nop			; (mov r8, r8)

000000e4 <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  e4:	e7fe      	b.n	e4 <SysTick_Handler>
  e6:	46c0      	nop			; (mov r8, r8)

000000e8 <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  e8:	e7fe      	b.n	e8 <BOD_IRQHandler>
  ea:	46c0      	nop			; (mov r8, r8)

000000ec <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
  ec:	b570      	push	{r4, r5, r6, lr}

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
  ee:	4c17      	ldr	r4, [pc, #92]	; (14c <ResetISR+0x60>)
  f0:	4d17      	ldr	r5, [pc, #92]	; (150 <ResetISR+0x64>)
  f2:	42ac      	cmp	r4, r5
  f4:	d20e      	bcs.n	114 <ResetISR+0x28>
        LoadAddr = *SectionTableAddr++;
  f6:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
  f8:	6861      	ldr	r1, [r4, #4]
  fa:	340c      	adds	r4, #12
  fc:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
  fe:	681a      	ldr	r2, [r3, #0]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 100:	2300      	movs	r3, #0
 102:	2a00      	cmp	r2, #0
 104:	d0f5      	beq.n	f2 <ResetISR+0x6>
        *pulDest++ = *pulSrc++;
 106:	581e      	ldr	r6, [r3, r0]
 108:	505e      	str	r6, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 10a:	3304      	adds	r3, #4
 10c:	429a      	cmp	r2, r3
 10e:	d8fa      	bhi.n	106 <ResetISR+0x1a>

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 110:	42ac      	cmp	r4, r5
 112:	d3f0      	bcc.n	f6 <ResetISR+0xa>
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 114:	4a0f      	ldr	r2, [pc, #60]	; (154 <ResetISR+0x68>)
 116:	4294      	cmp	r4, r2
 118:	d213      	bcs.n	142 <ResetISR+0x56>
 11a:	1c23      	adds	r3, r4, #0
 11c:	3308      	adds	r3, #8
 11e:	1dd5      	adds	r5, r2, #7
 120:	1aed      	subs	r5, r5, r3
 122:	08ed      	lsrs	r5, r5, #3
 124:	00ed      	lsls	r5, r5, #3
 126:	195d      	adds	r5, r3, r5

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 128:	2100      	movs	r1, #0
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
 12a:	6862      	ldr	r2, [r4, #4]
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
 12c:	6820      	ldr	r0, [r4, #0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 12e:	2300      	movs	r3, #0
 130:	2a00      	cmp	r2, #0
 132:	d003      	beq.n	13c <ResetISR+0x50>
        *pulDest++ = 0;
 134:	5019      	str	r1, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 136:	3304      	adds	r3, #4
 138:	429a      	cmp	r2, r3
 13a:	d8fb      	bhi.n	134 <ResetISR+0x48>
 13c:	3408      	adds	r4, #8
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 13e:	42ac      	cmp	r4, r5
 140:	d1f3      	bne.n	12a <ResetISR+0x3e>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 142:	f000 f907 	bl	354 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 146:	f000 fa07 	bl	558 <__weak_main>
 14a:	e7fe      	b.n	14a <ResetISR+0x5e>
 14c:	000000c0 	.word	0x000000c0
 150:	000000cc 	.word	0x000000cc
 154:	000000d4 	.word	0x000000d4

00000158 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
 158:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 15a:	2300      	movs	r3, #0
 15c:	2a00      	cmp	r2, #0
 15e:	d004      	beq.n	16a <data_init+0x12>
        *pulDest++ = *pulSrc++;
 160:	581c      	ldr	r4, [r3, r0]
 162:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 164:	3304      	adds	r3, #4
 166:	429a      	cmp	r2, r3
 168:	d8fa      	bhi.n	160 <data_init+0x8>
        *pulDest++ = *pulSrc++;
}
 16a:	bd10      	pop	{r4, pc}

0000016c <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 16c:	2300      	movs	r3, #0
        *pulDest++ = 0;
 16e:	2200      	movs	r2, #0

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 170:	2900      	cmp	r1, #0
 172:	d003      	beq.n	17c <bss_init+0x10>
        *pulDest++ = 0;
 174:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 176:	3304      	adds	r3, #4
 178:	4299      	cmp	r1, r3
 17a:	d8fb      	bhi.n	174 <bss_init+0x8>
        *pulDest++ = 0;
}
 17c:	4770      	bx	lr
 17e:	46c0      	nop			; (mov r8, r8)
 180:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 184:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 188:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 18c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 190:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 194:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 198:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 19c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1fc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 200:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 204:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 208:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 20c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 210:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 214:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 218:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 21c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 220:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 224:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 228:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 22c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 230:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 23c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 24c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 25c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 26c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 27c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 28c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 29c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffff ffff                                   ....

00000300 <main>:
#define SAMPLE_WIDTH 0x0FFF
#define FILTER_SIZE 4

void OpAmpADCInit(uint8_t in, uint8_t out);

int main(void) {
 300:	b510      	push	{r4, lr}
	// Standard boot procedure
	CoreClockInit_30Hz();
 302:	f000 f82b 	bl	35c <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL = (1 << clk) | (LPC_SYSCTL->SYSAHBCLKCTRL & ~SYSCTL_SYSAHBCLKCTRL_RESERVED);
 306:	4a11      	ldr	r2, [pc, #68]	; (34c <main+0x4c>)
 308:	2380      	movs	r3, #128	; 0x80
 30a:	58d1      	ldr	r1, [r2, r3]
#ifdef LPC810
    /* Enable SWM clock */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 30c:	4810      	ldr	r0, [pc, #64]	; (350 <main+0x50>)
 30e:	0309      	lsls	r1, r1, #12
 310:	0b09      	lsrs	r1, r1, #12
 312:	4319      	orrs	r1, r3
 314:	50d1      	str	r1, [r2, r3]
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

#ifdef LPC810
    /* Enable SWM clock */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);
 316:	58d1      	ldr	r1, [r2, r3]

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 318:	2401      	movs	r4, #1
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);

#ifdef LPC810
    /* Enable SWM clock */
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);
 31a:	4319      	orrs	r1, r3
 31c:	50d1      	str	r1, [r2, r3]

    /* Pin Assign 1 bit Configuration */
    LPC_SWM->PINENABLE0 = 0xffffffffUL;
 31e:	21e0      	movs	r1, #224	; 0xe0
 320:	0049      	lsls	r1, r1, #1
 322:	4264      	negs	r4, r4
 324:	5044      	str	r4, [r0, r1]
 326:	58d0      	ldr	r0, [r2, r3]
 328:	2140      	movs	r1, #64	; 0x40
 32a:	0300      	lsls	r0, r0, #12
 32c:	0b00      	lsrs	r0, r0, #12
 32e:	4301      	orrs	r1, r0
 330:	50d1      	str	r1, [r2, r3]
	// Global Peripheral Enables:
    Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_GPIO);

	// Configure ADC I/O
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= 1 << ADC_OUT;
 332:	22a0      	movs	r2, #160	; 0xa0
 334:	0612      	lsls	r2, r2, #24
 336:	019b      	lsls	r3, r3, #6
 338:	58d0      	ldr	r0, [r2, r3]
 33a:	2101      	movs	r1, #1
 33c:	4301      	orrs	r1, r0
 33e:	50d1      	str	r1, [r2, r3]
	LPC_GPIO_PORT->DIR[0] |= 1 << ADC_IN;
 340:	58d0      	ldr	r0, [r2, r3]
 342:	2102      	movs	r1, #2
 344:	4301      	orrs	r1, r0
 346:	50d1      	str	r1, [r2, r3]
 348:	e7fe      	b.n	348 <main+0x48>
 34a:	46c0      	nop			; (mov r8, r8)
 34c:	40048000 	.word	0x40048000
 350:	4000c000 	.word	0x4000c000

00000354 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 354:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 356:	f000 f8d5 	bl	504 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 35a:	bd08      	pop	{r3, pc}

0000035c <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 35c:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 35e:	4b0d      	ldr	r3, [pc, #52]	; (394 <CoreClockInit_30Hz+0x38>)
 360:	2224      	movs	r2, #36	; 0x24
 362:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 364:	228e      	movs	r2, #142	; 0x8e
 366:	0092      	lsls	r2, r2, #2
 368:	5899      	ldr	r1, [r3, r2]
 36a:	2080      	movs	r0, #128	; 0x80
 36c:	4381      	bics	r1, r0
 36e:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 370:	68d8      	ldr	r0, [r3, #12]
 372:	2101      	movs	r1, #1
 374:	4a07      	ldr	r2, [pc, #28]	; (394 <CoreClockInit_30Hz+0x38>)
 376:	4208      	tst	r0, r1
 378:	d0fa      	beq.n	370 <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 37a:	2003      	movs	r0, #3
 37c:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 37e:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 380:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 382:	07d1      	lsls	r1, r2, #31
 384:	d5fc      	bpl.n	380 <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 386:	4b03      	ldr	r3, [pc, #12]	; (394 <CoreClockInit_30Hz+0x38>)
 388:	2202      	movs	r2, #2
 38a:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 38c:	f000 f804 	bl	398 <SystemCoreClockUpdate>
}
 390:	bd08      	pop	{r3, pc}
 392:	46c0      	nop			; (mov r8, r8)
 394:	40048000 	.word	0x40048000

00000398 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 398:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 39a:	f000 f883 	bl	4a4 <Chip_Clock_GetSystemClockRate>
 39e:	4b01      	ldr	r3, [pc, #4]	; (3a4 <SystemCoreClockUpdate+0xc>)
 3a0:	6018      	str	r0, [r3, #0]
}
 3a2:	bd08      	pop	{r3, pc}
 3a4:	10000000 	.word	0x10000000

000003a8 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 3a8:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 3aa:	05c2      	lsls	r2, r0, #23
 3ac:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 3ae:	211f      	movs	r1, #31
 3b0:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 3b2:	0092      	lsls	r2, r2, #2
 3b4:	4b03      	ldr	r3, [pc, #12]	; (3c4 <Chip_Clock_GetWDTLFORate+0x1c>)
 3b6:	58d0      	ldr	r0, [r2, r3]
 3b8:	3101      	adds	r1, #1
 3ba:	0049      	lsls	r1, r1, #1
 3bc:	f000 f8d3 	bl	566 <__aeabi_uidiv>
}
 3c0:	bd08      	pop	{r3, pc}
 3c2:	46c0      	nop			; (mov r8, r8)
 3c4:	000005e4 	.word	0x000005e4

000003c8 <Chip_Clock_GetPLLFreq>:

/* Compute PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t m_val = ((PLLReg & 0x1F) + 1);
 3c8:	231f      	movs	r3, #31
 3ca:	4018      	ands	r0, r3
 3cc:	3001      	adds	r0, #1

	return (inputRate * m_val);
 3ce:	4348      	muls	r0, r1
}
 3d0:	4770      	bx	lr
 3d2:	46c0      	nop			; (mov r8, r8)

000003d4 <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 3d4:	4b03      	ldr	r3, [pc, #12]	; (3e4 <Chip_Clock_SetSystemPLLSource+0x10>)
 3d6:	6418      	str	r0, [r3, #64]	; 0x40
    
    /* sequnce a 0 followed by 1 to update PLL source selection */
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;  
 3d8:	2200      	movs	r2, #0
 3da:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;  
 3dc:	2201      	movs	r2, #1
 3de:	645a      	str	r2, [r3, #68]	; 0x44
}
 3e0:	4770      	bx	lr
 3e2:	46c0      	nop			; (mov r8, r8)
 3e4:	40048000 	.word	0x40048000

000003e8 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 3e8:	4b03      	ldr	r3, [pc, #12]	; (3f8 <Chip_Clock_SetMainClockSource+0x10>)
 3ea:	6718      	str	r0, [r3, #112]	; 0x70
    
    /* sequnce a 0 followed by 1 to update MAINCLK source selection */
	LPC_SYSCTL->MAINCLKUEN  = 0;
 3ec:	2200      	movs	r2, #0
 3ee:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 3f0:	2201      	movs	r2, #1
 3f2:	675a      	str	r2, [r3, #116]	; 0x74
}
 3f4:	4770      	bx	lr
 3f6:	46c0      	nop			; (mov r8, r8)
 3f8:	40048000 	.word	0x40048000

000003fc <Chip_Clock_GetWDTOSCRate>:
	LPC_SYSCTL->CLKOUTDIV = div;
}

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 3fc:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL & ~SYSCTL_WDTOSCCTRL_RESERVED);
 3fe:	4b03      	ldr	r3, [pc, #12]	; (40c <Chip_Clock_GetWDTOSCRate+0x10>)
 400:	6a58      	ldr	r0, [r3, #36]	; 0x24
 402:	05c0      	lsls	r0, r0, #23
 404:	0dc0      	lsrs	r0, r0, #23
 406:	f7ff ffcf 	bl	3a8 <Chip_Clock_GetWDTLFORate>
}
 40a:	bd08      	pop	{r3, pc}
 40c:	40048000 	.word	0x40048000

00000410 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 410:	4b09      	ldr	r3, [pc, #36]	; (438 <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 412:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 414:	2303      	movs	r3, #3
 416:	4013      	ands	r3, r2
 418:	2b01      	cmp	r3, #1
 41a:	d005      	beq.n	428 <Chip_Clock_GetSystemPLLInClockRate+0x18>
 41c:	2b03      	cmp	r3, #3
 41e:	d006      	beq.n	42e <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 420:	2b00      	cmp	r3, #0
 422:	d107      	bne.n	434 <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 424:	4805      	ldr	r0, [pc, #20]	; (43c <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 426:	e006      	b.n	436 <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 428:	4b05      	ldr	r3, [pc, #20]	; (440 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 42a:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 42c:	e003      	b.n	436 <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 42e:	4b05      	ldr	r3, [pc, #20]	; (444 <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 430:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 432:	e000      	b.n	436 <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 434:	2000      	movs	r0, #0
	}

	return clkRate;
}
 436:	4770      	bx	lr
 438:	40048000 	.word	0x40048000
 43c:	00b71b00 	.word	0x00b71b00
 440:	000005dc 	.word	0x000005dc
 444:	000005e0 	.word	0x000005e0

00000448 <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 448:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq((LPC_SYSCTL->SYSPLLCTRL & ~SYSCTL_SYSPLLCTRL_RESERVED),
 44a:	4b05      	ldr	r3, [pc, #20]	; (460 <Chip_Clock_GetSystemPLLOutClockRate+0x18>)
 44c:	689b      	ldr	r3, [r3, #8]
 44e:	247f      	movs	r4, #127	; 0x7f
 450:	401c      	ands	r4, r3
 452:	f7ff ffdd 	bl	410 <Chip_Clock_GetSystemPLLInClockRate>
 456:	1c01      	adds	r1, r0, #0
 458:	1c20      	adds	r0, r4, #0
 45a:	f7ff ffb5 	bl	3c8 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 45e:	bd10      	pop	{r4, pc}
 460:	40048000 	.word	0x40048000

00000464 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 464:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 466:	4b0d      	ldr	r3, [pc, #52]	; (49c <Chip_Clock_GetMainClockRate+0x38>)
 468:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 46a:	2303      	movs	r3, #3
 46c:	4013      	ands	r3, r2
 46e:	2b01      	cmp	r3, #1
 470:	d009      	beq.n	486 <Chip_Clock_GetMainClockRate+0x22>
 472:	dc02      	bgt.n	47a <Chip_Clock_GetMainClockRate+0x16>
 474:	2b00      	cmp	r3, #0
 476:	d00f      	beq.n	498 <Chip_Clock_GetMainClockRate+0x34>
 478:	e003      	b.n	482 <Chip_Clock_GetMainClockRate+0x1e>
 47a:	2b02      	cmp	r3, #2
 47c:	d006      	beq.n	48c <Chip_Clock_GetMainClockRate+0x28>
 47e:	2b03      	cmp	r3, #3
 480:	d007      	beq.n	492 <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 482:	2000      	movs	r0, #0
 484:	e009      	b.n	49a <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 486:	f7ff ffc3 	bl	410 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 48a:	e006      	b.n	49a <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 48c:	f7ff ffb6 	bl	3fc <Chip_Clock_GetWDTOSCRate>
		break;
 490:	e003      	b.n	49a <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 492:	f7ff ffd9 	bl	448 <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 496:	e000      	b.n	49a <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 498:	4801      	ldr	r0, [pc, #4]	; (4a0 <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 49a:	bd08      	pop	{r3, pc}
 49c:	40048000 	.word	0x40048000
 4a0:	00b71b00 	.word	0x00b71b00

000004a4 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 4a4:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / (LPC_SYSCTL->SYSAHBCLKDIV & ~SYSCTL_SYSAHBCLKDIV_RESERVED);
 4a6:	f7ff ffdd 	bl	464 <Chip_Clock_GetMainClockRate>
 4aa:	4b03      	ldr	r3, [pc, #12]	; (4b8 <Chip_Clock_GetSystemClockRate+0x14>)
 4ac:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 4ae:	21ff      	movs	r1, #255	; 0xff
 4b0:	4019      	ands	r1, r3
 4b2:	f000 f858 	bl	566 <__aeabi_uidiv>
}
 4b6:	bd08      	pop	{r3, pc}
 4b8:	40048000 	.word	0x40048000

000004bc <Chip_SetupIrcClocking>:
#endif
}

/* Set up and initialize hardware prior to call to main */
void Chip_SetupIrcClocking(void)
{
 4bc:	b508      	push	{r3, lr}
#if defined(USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 4be:	2002      	movs	r0, #2
 4c0:	f000 f836 	bl	530 <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 4c4:	2000      	movs	r0, #0
 4c6:	f7ff ff85 	bl	3d4 <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~((0x3)|FMC_FLASHCFG_RESERVED));
 4ca:	4b0c      	ldr	r3, [pc, #48]	; (4fc <Chip_SetupIrcClocking+0x40>)
 4cc:	691a      	ldr	r2, [r3, #16]

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 4ce:	2201      	movs	r2, #1
 4d0:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 4d2:	2080      	movs	r0, #128	; 0x80
 4d4:	f000 f81a 	bl	50c <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 4d8:	2241      	movs	r2, #65	; 0x41
 4da:	4b09      	ldr	r3, [pc, #36]	; (500 <Chip_SetupIrcClocking+0x44>)
 4dc:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 4de:	2080      	movs	r0, #128	; 0x80
 4e0:	f000 f826 	bl	530 <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 4e4:	4906      	ldr	r1, [pc, #24]	; (500 <Chip_SetupIrcClocking+0x44>)
 4e6:	2201      	movs	r2, #1
 4e8:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 4ea:	421a      	tst	r2, r3
 4ec:	d0fc      	beq.n	4e8 <Chip_SetupIrcClocking+0x2c>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 4ee:	2201      	movs	r2, #1
 4f0:	4b03      	ldr	r3, [pc, #12]	; (500 <Chip_SetupIrcClocking+0x44>)
 4f2:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 4f4:	2003      	movs	r0, #3
 4f6:	f7ff ff77 	bl	3e8 <Chip_Clock_SetMainClockSource>
#endif
}
 4fa:	bd08      	pop	{r3, pc}
 4fc:	40040000 	.word	0x40040000
 500:	40048000 	.word	0x40048000

00000504 <Chip_SystemInit>:

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 504:	b508      	push	{r3, lr}
	/* Initial internal clocking */
	Chip_SetupIrcClocking();
 506:	f7ff ffd9 	bl	4bc <Chip_SetupIrcClocking>
}
 50a:	bd08      	pop	{r3, pc}

0000050c <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 50c:	4a05      	ldr	r2, [pc, #20]	; (524 <Chip_SYSCTL_PowerDown+0x18>)
 50e:	238e      	movs	r3, #142	; 0x8e
 510:	009b      	lsls	r3, r3, #2
 512:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 514:	4308      	orrs	r0, r1
 516:	4904      	ldr	r1, [pc, #16]	; (528 <Chip_SYSCTL_PowerDown+0x1c>)
 518:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 51a:	4904      	ldr	r1, [pc, #16]	; (52c <Chip_SYSCTL_PowerDown+0x20>)
 51c:	4308      	orrs	r0, r1
 51e:	50d0      	str	r0, [r2, r3]
}
 520:	4770      	bx	lr
 522:	46c0      	nop			; (mov r8, r8)
 524:	40048000 	.word	0x40048000
 528:	000080ef 	.word	0x000080ef
 52c:	00006d10 	.word	0x00006d10

00000530 <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 530:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 532:	4a06      	ldr	r2, [pc, #24]	; (54c <Chip_SYSCTL_PowerUp+0x1c>)
 534:	238e      	movs	r3, #142	; 0x8e
 536:	009b      	lsls	r3, r3, #2
 538:	58d4      	ldr	r4, [r2, r3]
 53a:	4905      	ldr	r1, [pc, #20]	; (550 <Chip_SYSCTL_PowerUp+0x20>)
 53c:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 53e:	4001      	ands	r1, r0
 540:	438c      	bics	r4, r1
 542:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 544:	4803      	ldr	r0, [pc, #12]	; (554 <Chip_SYSCTL_PowerUp+0x24>)
 546:	4301      	orrs	r1, r0
 548:	50d1      	str	r1, [r2, r3]
}
 54a:	bd10      	pop	{r4, pc}
 54c:	40048000 	.word	0x40048000
 550:	000080ef 	.word	0x000080ef
 554:	00006d10 	.word	0x00006d10

00000558 <__weak_main>:
 558:	b508      	push	{r3, lr}
 55a:	f7ff fed1 	bl	300 <main>
 55e:	bd08      	pop	{r3, pc}

00000560 <__aeabi_idiv>:
 560:	0003      	movs	r3, r0
 562:	430b      	orrs	r3, r1
 564:	d421      	bmi.n	5aa <idiv_negative>

00000566 <__aeabi_uidiv>:
 566:	2900      	cmp	r1, #0
 568:	d031      	beq.n	5ce <idiv_divzero>
 56a:	2201      	movs	r2, #1
 56c:	07d2      	lsls	r2, r2, #31
 56e:	0903      	lsrs	r3, r0, #4
 570:	e001      	b.n	576 <div_search4a>

00000572 <div_search4>:
 572:	0109      	lsls	r1, r1, #4
 574:	0912      	lsrs	r2, r2, #4

00000576 <div_search4a>:
 576:	4299      	cmp	r1, r3
 578:	d9fb      	bls.n	572 <div_search4>
 57a:	0843      	lsrs	r3, r0, #1
 57c:	e001      	b.n	582 <div_search1a>

0000057e <div_search1>:
 57e:	0049      	lsls	r1, r1, #1
 580:	0852      	lsrs	r2, r2, #1

00000582 <div_search1a>:
 582:	4299      	cmp	r1, r3
 584:	d9fb      	bls.n	57e <div_search1>
 586:	e000      	b.n	58a <div_loop1a>

00000588 <div_loop1>:
 588:	0849      	lsrs	r1, r1, #1

0000058a <div_loop1a>:
 58a:	1a40      	subs	r0, r0, r1
 58c:	d307      	bcc.n	59e <div1>

0000058e <div2>:
 58e:	4152      	adcs	r2, r2
 590:	d3fa      	bcc.n	588 <div_loop1>
 592:	4601      	mov	r1, r0
 594:	4610      	mov	r0, r2
 596:	4770      	bx	lr

00000598 <div_loop2>:
 598:	0849      	lsrs	r1, r1, #1
 59a:	1840      	adds	r0, r0, r1
 59c:	d2f7      	bcs.n	58e <div2>

0000059e <div1>:
 59e:	1892      	adds	r2, r2, r2
 5a0:	d3fa      	bcc.n	598 <div_loop2>
 5a2:	1840      	adds	r0, r0, r1
 5a4:	4601      	mov	r1, r0
 5a6:	4610      	mov	r0, r2
 5a8:	4770      	bx	lr

000005aa <idiv_negative>:
 5aa:	0fcb      	lsrs	r3, r1, #31
 5ac:	d000      	beq.n	5b0 <idiv_neg1>
 5ae:	4249      	negs	r1, r1

000005b0 <idiv_neg1>:
 5b0:	1002      	asrs	r2, r0, #32
 5b2:	d500      	bpl.n	5b6 <idiv_neg2>
 5b4:	4240      	negs	r0, r0

000005b6 <idiv_neg2>:
 5b6:	4053      	eors	r3, r2
 5b8:	b508      	push	{r3, lr}
 5ba:	f7ff ffd4 	bl	566 <__aeabi_uidiv>
 5be:	bc0c      	pop	{r2, r3}

000005c0 <idiv_sign>:
 5c0:	1052      	asrs	r2, r2, #1
 5c2:	d300      	bcc.n	5c6 <idiv_sign1>
 5c4:	4240      	negs	r0, r0

000005c6 <idiv_sign1>:
 5c6:	2a00      	cmp	r2, #0
 5c8:	d500      	bpl.n	5cc <idiv_ret>
 5ca:	4249      	negs	r1, r1

000005cc <idiv_ret>:
 5cc:	4718      	bx	r3

000005ce <idiv_divzero>:
 5ce:	46f4      	mov	ip, lr
 5d0:	2000      	movs	r0, #0
 5d2:	f000 f801 	bl	5d8 <__aeabi_idiv0>
 5d6:	4760      	bx	ip

000005d8 <__aeabi_idiv0>:
 5d8:	4770      	bx	lr
	...

000005dc <OscRateIn>:
 5dc:	1b00 00b7                                   ....

000005e0 <ExtRateIn>:
 5e0:	0000 0000                                   ....

000005e4 <wdtOSCRate>:
 5e4:	0000 0000 27c0 0009 0590 0010 5cc0 0015     .....'.......\..
 5f4:	b3f0 001a 0b20 0020 9f00 0024 32e0 0029     .... . ...$..2).
 604:	c6c0 002d 9750 0031 67e0 0035 3870 0039     ..-.P.1..g5.p89.
 614:	0900 003d 1640 0040 2380 0043 30c0 0046     ..=.@.@..#C..0F.
