
Metaphase-MASK.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
   0:	00 10 00 10 ed 00 00 00 d5 00 00 00 d9 00 00 00     ................
	...
  2c:	dd 00 00 00 00 00 00 00 00 00 00 00 e1 00 00 00     ................
  3c:	e5 00 00 00 fd 06 00 00 e9 00 00 00 00 00 00 00     ................
  4c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  5c:	00 00 00 00 41 07 00 00 e9 00 00 00 e9 00 00 00     ....A...........
  6c:	e9 00 00 00 e9 00 00 00 e9 00 00 00 00 00 00 00     ................
  7c:	e9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
  a0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................
  b0:	e9 00 00 00 e9 00 00 00 e9 00 00 00 e9 00 00 00     ................

000000c0 <__data_section_table>:
  c0:	00000c2c 	.word	0x00000c2c
  c4:	10000000 	.word	0x10000000
  c8:	00000000 	.word	0x00000000

000000cc <__bss_section_table>:
  cc:	10000000 	.word	0x10000000
  d0:	0000005c 	.word	0x0000005c

000000d4 <NMI_Handler>:
// Default exception handlers. Override the ones here by defining your own
// handler routines in your application code.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void NMI_Handler(void)
{
  d4:	e7fe      	b.n	d4 <NMI_Handler>
  d6:	46c0      	nop			; (mov r8, r8)

000000d8 <HardFault_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void HardFault_Handler(void)
{
  d8:	e7fe      	b.n	d8 <HardFault_Handler>
  da:	46c0      	nop			; (mov r8, r8)

000000dc <SVC_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SVC_Handler(void)
{
  dc:	e7fe      	b.n	dc <SVC_Handler>
  de:	46c0      	nop			; (mov r8, r8)

000000e0 <PendSV_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void PendSV_Handler(void)
{
  e0:	e7fe      	b.n	e0 <PendSV_Handler>
  e2:	46c0      	nop			; (mov r8, r8)

000000e4 <SysTick_Handler>:
    {
    }
}
__attribute__ ((section(".after_vectors")))
void SysTick_Handler(void)
{
  e4:	e7fe      	b.n	e4 <SysTick_Handler>
  e6:	46c0      	nop			; (mov r8, r8)

000000e8 <BOD_IRQHandler>:
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void IntDefaultHandler(void)
{
  e8:	e7fe      	b.n	e8 <BOD_IRQHandler>
  ea:	46c0      	nop			; (mov r8, r8)

000000ec <ResetISR>:
// Sets up a simple runtime environment and initializes the C/C++
// library.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void
ResetISR(void) {
  ec:	b570      	push	{r4, r5, r6, lr}

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
  ee:	4c17      	ldr	r4, [pc, #92]	; (14c <ResetISR+0x60>)
  f0:	4d17      	ldr	r5, [pc, #92]	; (150 <ResetISR+0x64>)
  f2:	42ac      	cmp	r4, r5
  f4:	d20e      	bcs.n	114 <ResetISR+0x28>
        LoadAddr = *SectionTableAddr++;
  f6:	6820      	ldr	r0, [r4, #0]
        ExeAddr = *SectionTableAddr++;
  f8:	6861      	ldr	r1, [r4, #4]
  fa:	340c      	adds	r4, #12
  fc:	1f23      	subs	r3, r4, #4
        SectionLen = *SectionTableAddr++;
  fe:	681a      	ldr	r2, [r3, #0]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 100:	2300      	movs	r3, #0
 102:	2a00      	cmp	r2, #0
 104:	d0f5      	beq.n	f2 <ResetISR+0x6>
        *pulDest++ = *pulSrc++;
 106:	581e      	ldr	r6, [r3, r0]
 108:	505e      	str	r6, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 10a:	3304      	adds	r3, #4
 10c:	429a      	cmp	r2, r3
 10e:	d8fa      	bhi.n	106 <ResetISR+0x1a>

    // Load base address of Global Section Table
    SectionTableAddr = &__data_section_table;

    // Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
 110:	42ac      	cmp	r4, r5
 112:	d3f0      	bcc.n	f6 <ResetISR+0xa>
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 114:	4a0f      	ldr	r2, [pc, #60]	; (154 <ResetISR+0x68>)
 116:	4294      	cmp	r4, r2
 118:	d213      	bcs.n	142 <ResetISR+0x56>
 11a:	1c23      	adds	r3, r4, #0
 11c:	3308      	adds	r3, #8
 11e:	1dd5      	adds	r5, r2, #7
 120:	1aed      	subs	r5, r5, r3
 122:	08ed      	lsrs	r5, r5, #3
 124:	00ed      	lsls	r5, r5, #3
 126:	195d      	adds	r5, r3, r5

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 128:	2100      	movs	r1, #0
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
 12a:	6862      	ldr	r2, [r4, #4]
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
 12c:	6820      	ldr	r0, [r4, #0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 12e:	2300      	movs	r3, #0
 130:	2a00      	cmp	r2, #0
 132:	d003      	beq.n	13c <ResetISR+0x50>
        *pulDest++ = 0;
 134:	5019      	str	r1, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 136:	3304      	adds	r3, #4
 138:	429a      	cmp	r2, r3
 13a:	d8fb      	bhi.n	134 <ResetISR+0x48>
 13c:	3408      	adds	r4, #8
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }
    // At this point, SectionTableAddr = &__bss_section_table;
    // Zero fill the bss segment
    while (SectionTableAddr < &__bss_section_table_end) {
 13e:	42ac      	cmp	r4, r5
 140:	d1f3      	bne.n	12a <ResetISR+0x3e>
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
    }
#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
    SystemInit();
 142:	f000 f949 	bl	3d8 <SystemInit>
    __libc_init_array();
#endif

#if defined (__REDLIB__)
    // Call the Redlib library, which in turn calls main()
    __main() ;
 146:	f000 fcf5 	bl	b34 <__weak_main>
 14a:	e7fe      	b.n	14a <ResetISR+0x5e>
 14c:	000000c0 	.word	0x000000c0
 150:	000000cc 	.word	0x000000cc
 154:	000000d4 	.word	0x000000d4

00000158 <data_init>:
// are written as separate functions rather than being inlined within the
// ResetISR() function in order to cope with MCUs with multiple banks of
// memory.
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
 158:	b510      	push	{r4, lr}
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 15a:	2300      	movs	r3, #0
 15c:	2a00      	cmp	r2, #0
 15e:	d004      	beq.n	16a <data_init+0x12>
        *pulDest++ = *pulSrc++;
 160:	581c      	ldr	r4, [r3, r0]
 162:	505c      	str	r4, [r3, r1]
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 164:	3304      	adds	r3, #4
 166:	429a      	cmp	r2, r3
 168:	d8fa      	bhi.n	160 <data_init+0x8>
        *pulDest++ = *pulSrc++;
}
 16a:	bd10      	pop	{r4, pc}

0000016c <bss_init>:

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 16c:	2300      	movs	r3, #0
        *pulDest++ = 0;
 16e:	2200      	movs	r2, #0

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 170:	2900      	cmp	r1, #0
 172:	d003      	beq.n	17c <bss_init+0x10>
        *pulDest++ = 0;
 174:	501a      	str	r2, [r3, r0]

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len) {
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
 176:	3304      	adds	r3, #4
 178:	4299      	cmp	r1, r3
 17a:	d8fb      	bhi.n	174 <bss_init+0x8>
        *pulDest++ = 0;
}
 17c:	4770      	bx	lr
 17e:	46c0      	nop			; (mov r8, r8)
 180:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 184:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 188:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 18c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 190:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 194:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 198:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 19c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 1fc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 200:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 204:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 208:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 20c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 210:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 214:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 218:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 21c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 220:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 224:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 228:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 22c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 230:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 234:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 238:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 23c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 240:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 244:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 248:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 24c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 250:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 254:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 258:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 25c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 260:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 264:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 268:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 26c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 270:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 274:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 278:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 27c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 280:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 284:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 288:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 28c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 290:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 294:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 298:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 29c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2a8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ac:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2b8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2bc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2c8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2cc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2d8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2dc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2e8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2ec:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f0:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f4:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
 2f8:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

000002fc <CRP_WORD>:
 2fc:	ffff ffff                                   ....

00000300 <main>:
#include "BAP_MAX1164x_ADC.h"

#define LED_LOCATION    (14)
#define LPC812

int main(void) {
 300:	b570      	push	{r4, r5, r6, lr}
 302:	b0a4      	sub	sp, #144	; 0x90
	// Standard boot procedure
	CoreClockInit_30Hz();
 304:	f000 f880 	bl	408 <CoreClockInit_30Hz>
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 308:	4a2c      	ldr	r2, [pc, #176]	; (3bc <main+0xbc>)
 30a:	2380      	movs	r3, #128	; 0x80
 30c:	58d0      	ldr	r0, [r2, r3]
 30e:	2140      	movs	r1, #64	; 0x40
 310:	4301      	orrs	r1, r0
 312:	50d1      	str	r1, [r2, r3]
 314:	58d0      	ldr	r0, [r2, r3]
 316:	2180      	movs	r1, #128	; 0x80
 318:	0109      	lsls	r1, r1, #4
 31a:	4301      	orrs	r1, r0
 31c:	50d1      	str	r1, [r2, r3]
 31e:	58d0      	ldr	r0, [r2, r3]
 320:	2180      	movs	r1, #128	; 0x80
 322:	0309      	lsls	r1, r1, #12
 324:	4301      	orrs	r1, r0
 326:	50d1      	str	r1, [r2, r3]
 328:	58d0      	ldr	r0, [r2, r3]
 32a:	2120      	movs	r1, #32
 32c:	4301      	orrs	r1, r0
 32e:	50d1      	str	r1, [r2, r3]
 330:	58d1      	ldr	r1, [r2, r3]
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);
#ifdef LPC812
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
 332:	4823      	ldr	r0, [pc, #140]	; (3c0 <main+0xc0>)
 334:	4319      	orrs	r1, r3
 336:	50d1      	str	r1, [r2, r3]
 338:	4922      	ldr	r1, [pc, #136]	; (3c4 <main+0xc4>)
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 33a:	244f      	movs	r4, #79	; 0x4f
	// Configure Pinout
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_SWM);
#ifdef LPC812
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
 33c:	60c8      	str	r0, [r1, #12]
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
 33e:	4822      	ldr	r0, [pc, #136]	; (3c8 <main+0xc8>)
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 340:	4264      	negs	r4, r4
	/* Pin Assign 8 bit Configuration */
	/* SPI0_SCK */
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
 342:	6108      	str	r0, [r1, #16]
	/* I2C0_SDA */
	LPC_SWM->PINASSIGN[7] = 0x0bffffffUL;
 344:	4821      	ldr	r0, [pc, #132]	; (3cc <main+0xcc>)
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 346:	2580      	movs	r5, #128	; 0x80
	LPC_SWM->PINASSIGN[3] = 0x06ffffffUL;
	/* SPI0_MOSI */
	/* SPI0_SSEL */
	LPC_SWM->PINASSIGN[4] = 0xff11ff07UL;
	/* I2C0_SDA */
	LPC_SWM->PINASSIGN[7] = 0x0bffffffUL;
 348:	61c8      	str	r0, [r1, #28]
	/* I2C0_SCL */
	LPC_SWM->PINASSIGN[8] = 0xffffff0aUL;
 34a:	20f6      	movs	r0, #246	; 0xf6
 34c:	4240      	negs	r0, r0
 34e:	6208      	str	r0, [r1, #32]
	/* Pin Assign 1 bit Configuration */
	/* ACMP_I2 */
	/* SWCLK */
	/* SWDIO */
	/* RESET */
	LPC_SWM->PINENABLE0 = 0xffffffb1UL;
 350:	20e0      	movs	r0, #224	; 0xe0
 352:	0040      	lsls	r0, r0, #1
 354:	500c      	str	r4, [r1, r0]
 * @param	clk	: Clock to disable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_DisablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL &= ~(1 << clk);
 356:	58d1      	ldr	r1, [r2, r3]
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 358:	24a0      	movs	r4, #160	; 0xa0
 35a:	4399      	bics	r1, r3
 35c:	50d1      	str	r1, [r2, r3]
 35e:	0624      	lsls	r4, r4, #24
 360:	019b      	lsls	r3, r3, #6
 362:	58e2      	ldr	r2, [r4, r3]
 364:	01ed      	lsls	r5, r5, #7
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 366:	2688      	movs	r6, #136	; 0x88
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 368:	432a      	orrs	r2, r5
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 36a:	01b6      	lsls	r6, r6, #6
#endif
	Chip_Clock_DisablePeriphClock(SYSCTL_CLOCK_SWM);

	// Configure debug LED
	// TODO: get rid of this
	LPC_GPIO_PORT->DIR[0] |= (1 << LED_LOCATION);
 36c:	50e2      	str	r2, [r4, r3]
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 36e:	51a5      	str	r5, [r4, r6]

	// Initialize the ADC
	TLV_Init();
 370:	f000 f954 	bl	61c <TLV_Init>

	//LPC_GPIO_PORT->CLR[0] = 1 << LED_LOCATION;
	// Initialize the Analog-to-Digital converter
	MAX1164x_t ADC;
	MAX1164x_Init(&ADC, IOCON_PIO11, IOCON_PIO10);
 374:	2208      	movs	r2, #8
 376:	4668      	mov	r0, sp
 378:	2107      	movs	r1, #7
 37a:	f000 f89b 	bl	4b4 <MAX1164x_Init>
	MAX1164x_SetSpeed(&ADC, MAX1164x_SPD_HI);
 37e:	4668      	mov	r0, sp
 380:	2101      	movs	r1, #1
 382:	f000 f8ed 	bl	560 <MAX1164x_SetSpeed>
	LPC_GPIO_PORT->SET[0] = 1 << LED_LOCATION;
 386:	51a5      	str	r5, [r4, r6]

	// Initialize the 32-position selector
	Selector_Init(LPC_CMP);
 388:	4811      	ldr	r0, [pc, #68]	; (3d0 <main+0xd0>)
 38a:	f000 f829 	bl	3e0 <Selector_Init>
 38e:	4c11      	ldr	r4, [pc, #68]	; (3d4 <main+0xd4>)
	while(1)
	{
		MAX1164x_RequestNewSample(&ADC);
		if (sample_count != last_count)
		{
			TLV_SetDACValue(TLV_DAC_1, TLV_SPD_Fast, ADC.sample_buffer.channel[0]);
 390:	2688      	movs	r6, #136	; 0x88
			TLV_SetDACValue(TLV_DAC_2, TLV_SPD_Fast, ADC.sample_buffer.channel[1]);
 392:	258a      	movs	r5, #138	; 0x8a
	// Initialize the 32-position selector
	Selector_Init(LPC_CMP);
	uint16_t last_count = 0;
	while(1)
	{
		MAX1164x_RequestNewSample(&ADC);
 394:	4668      	mov	r0, sp
 396:	f000 f91d 	bl	5d4 <MAX1164x_RequestNewSample>
		if (sample_count != last_count)
 39a:	8823      	ldrh	r3, [r4, #0]
 39c:	2b00      	cmp	r3, #0
 39e:	d0f9      	beq.n	394 <main+0x94>
		{
			TLV_SetDACValue(TLV_DAC_1, TLV_SPD_Fast, ADC.sample_buffer.channel[0]);
 3a0:	466b      	mov	r3, sp
 3a2:	5b9a      	ldrh	r2, [r3, r6]
 3a4:	2101      	movs	r1, #1
 3a6:	2000      	movs	r0, #0
 3a8:	f000 f96c 	bl	684 <TLV_SetDACValue>
			TLV_SetDACValue(TLV_DAC_2, TLV_SPD_Fast, ADC.sample_buffer.channel[1]);
 3ac:	466b      	mov	r3, sp
 3ae:	5b5a      	ldrh	r2, [r3, r5]
 3b0:	2101      	movs	r1, #1
 3b2:	2001      	movs	r0, #1
 3b4:	f000 f966 	bl	684 <TLV_SetDACValue>
 3b8:	e7ec      	b.n	394 <main+0x94>
 3ba:	46c0      	nop			; (mov r8, r8)
 3bc:	40048000 	.word	0x40048000
 3c0:	06ffffff 	.word	0x06ffffff
 3c4:	4000c000 	.word	0x4000c000
 3c8:	ff11ff07 	.word	0xff11ff07
 3cc:	0bffffff 	.word	0x0bffffff
 3d0:	40024000 	.word	0x40024000
 3d4:	10000028 	.word	0x10000028

000003d8 <SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void SystemInit(void)
{
 3d8:	b508      	push	{r3, lr}
#if defined(NO_BOARD_LIB)
	/* Chip specific SystemInit */
	Chip_SystemInit();
 3da:	f000 fb7b 	bl	ad4 <Chip_SystemInit>
#else
	/* Board specific SystemInit */
	Board_SystemInit();
#endif
}
 3de:	bd08      	pop	{r3, pc}

000003e0 <Selector_Init>:
 *      Author: Matt
 */

#include "BAP_32Sel.h"

void Selector_Init(LPC_CMP_T* ACMP){
 3e0:	b507      	push	{r0, r1, r2, lr}
	// Turn on the analog comparator
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_ACMP_PD);
 3e2:	2080      	movs	r0, #128	; 0x80
 3e4:	0200      	lsls	r0, r0, #8
 3e6:	f000 fb61 	bl	aac <Chip_SYSCTL_PowerUp>
 * @param	pACMP	: Pointer to Analog Comparator block
 * @return	Nothing
 */
STATIC INLINE void Chip_ACMP_EnableVoltLadder(LPC_CMP_T *pACMP)
{
	pACMP->LAD |= ACMP_LADENAB_BIT;
 3ea:	4806      	ldr	r0, [pc, #24]	; (404 <Selector_Init+0x24>)
 3ec:	2201      	movs	r2, #1
 3ee:	6843      	ldr	r3, [r0, #4]
	// Enable the voltage ladder
	Chip_ACMP_EnableVoltLadder(LPC_CMP);

	// Set up comparator:
	// set COMPEDGE on both edges, use the ACMP_in1 as the positive input, the ladder as the negative, with no hysteresis.
	Chip_ACMP_SetupAMCPRefs(LPC_CMP, ACMP_EDGESEL_BOTH, ACMP_POSIN_ACMP_I1, ACMP_NEGIN_VLO, ACMP_HYS_NONE);
 3f0:	2110      	movs	r1, #16
 3f2:	4313      	orrs	r3, r2
 3f4:	6043      	str	r3, [r0, #4]
 3f6:	2280      	movs	r2, #128	; 0x80
 3f8:	2300      	movs	r3, #0
 3fa:	9300      	str	r3, [sp, #0]
 3fc:	0052      	lsls	r2, r2, #1
 3fe:	f000 fa33 	bl	868 <Chip_ACMP_SetupAMCPRefs>
}
 402:	bd07      	pop	{r0, r1, r2, pc}
 404:	40024000 	.word	0x40024000

00000408 <CoreClockInit_30Hz>:

#include "BAP_Clk.h"

#define PLL_60MHZ (0x24)

void CoreClockInit_30Hz() {
 408:	b508      	push	{r3, lr}

	 /* Enable the PLL Clock for a maximum 30MHZ SystemCoreClock */
	LPC_SYSCTL->SYSPLLCTRL = PLL_60MHZ; /* 60 MHZ pll output clock*/
 40a:	4b0d      	ldr	r3, [pc, #52]	; (440 <CoreClockInit_30Hz+0x38>)
 40c:	2224      	movs	r2, #36	; 0x24
 40e:	609a      	str	r2, [r3, #8]
	LPC_SYSCTL->PDRUNCFG &= ~(0x1 << 7); /* Power-up SYSPLL          */
 410:	228e      	movs	r2, #142	; 0x8e
 412:	0092      	lsls	r2, r2, #2
 414:	5899      	ldr	r1, [r3, r2]
 416:	2080      	movs	r0, #128	; 0x80
 418:	4381      	bics	r1, r0
 41a:	5099      	str	r1, [r3, r2]

	while (!(LPC_SYSCTL->SYSPLLSTAT & 0x01)){/* Wait Until PLL Locked*/}
 41c:	68d8      	ldr	r0, [r3, #12]
 41e:	2101      	movs	r1, #1
 420:	4a07      	ldr	r2, [pc, #28]	; (440 <CoreClockInit_30Hz+0x38>)
 422:	4208      	tst	r0, r1
 424:	d0fa      	beq.n	41c <CoreClockInit_30Hz+0x14>

	LPC_SYSCTL->MAINCLKSEL = 3; /* Select PLL Clock Output  */
 426:	2003      	movs	r0, #3
 428:	6710      	str	r0, [r2, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN = 0x01; /* Update MCLK Clock Source */
 42a:	6751      	str	r1, [r2, #116]	; 0x74

	while (!(LPC_SYSCTL->MAINCLKUEN & 0x01)){/* Wait Until Updated*/}
 42c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 42e:	07d1      	lsls	r1, r2, #31
 430:	d5fc      	bpl.n	42c <CoreClockInit_30Hz+0x24>

	LPC_SYSCTL->SYSAHBCLKDIV  =  2; /* Divide by 2 to get the maximum 30MHZ SystemCoreClock */
 432:	4b03      	ldr	r3, [pc, #12]	; (440 <CoreClockInit_30Hz+0x38>)
 434:	2202      	movs	r2, #2
 436:	679a      	str	r2, [r3, #120]	; 0x78
	SystemCoreClockUpdate();
 438:	f000 fa24 	bl	884 <SystemCoreClockUpdate>
}
 43c:	bd08      	pop	{r3, pc}
 43e:	46c0      	nop			; (mov r8, r8)
 440:	40048000 	.word	0x40048000

00000444 <MAX1164x_WriteCmd>:
/////////////////// Static Global Variables //////////////////////////////
static I2C_HANDLE_T* localHandle;
////////////////////// Static Functions /////////////////////////////////

static void MAX1164x_WriteCmd(MAX1164x_t* MAX1164x, uint8_t cmd)
{
 444:	b570      	push	{r4, r5, r6, lr}
 446:	b08a      	sub	sp, #40	; 0x28
	// Maximum CMD is a two-byte write cycle following the 1 byte address & R/W indicator
	uint8_t SendData[2];
	int i = 0;

	SendData[i++] = (uint8_t) (MAX1164x_I2C_ADDR_7BIT << 1);
 448:	ab01      	add	r3, sp, #4
 44a:	226c      	movs	r2, #108	; 0x6c
 44c:	701a      	strb	r2, [r3, #0]
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
 44e:	9306      	str	r3, [sp, #24]
	// Maximum CMD is a two-byte write cycle following the 1 byte address & R/W indicator
	uint8_t SendData[2];
	int i = 0;

	SendData[i++] = (uint8_t) (MAX1164x_I2C_ADDR_7BIT << 1);
	SendData[i++] = cmd;
 450:	7059      	strb	r1, [r3, #1]

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
 452:	2300      	movs	r3, #0
 454:	9305      	str	r3, [sp, #20]
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 456:	2202      	movs	r2, #2
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 458:	1c03      	adds	r3, r0, #0
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 45a:	9204      	str	r2, [sp, #16]
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 45c:	338c      	adds	r3, #140	; 0x8c
 45e:	781b      	ldrb	r3, [r3, #0]
	   Setup Byte - ack
	   Config Byte - ack - stop */

	I2C_PARAM_T param;

	param.num_bytes_send    = i;
 460:	ac04      	add	r4, sp, #16
	param.stop_flag         = MAX1164x->UseStopFlag;

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 462:	4e09      	ldr	r6, [pc, #36]	; (488 <MAX1164x_WriteCmd+0x44>)
	I2C_PARAM_T param;

	param.num_bytes_send    = i;
	param.buffer_ptr_send   = &SendData[0];
	param.num_bytes_rec     = 0;
	param.stop_flag         = MAX1164x->UseStopFlag;
 464:	7523      	strb	r3, [r4, #20]

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 466:	6833      	ldr	r3, [r6, #0]
/////////////////// Static Global Variables //////////////////////////////
static I2C_HANDLE_T* localHandle;
////////////////////// Static Functions /////////////////////////////////

static void MAX1164x_WriteCmd(MAX1164x_t* MAX1164x, uint8_t cmd)
{
 468:	1c05      	adds	r5, r0, #0
	param.stop_flag         = MAX1164x->UseStopFlag;

	// Result for sake of keeping the API happy.
	I2C_RESULT_T result;

	LPC_I2CD_API->i2c_set_timeout(MAX1164x->i2cHandleMaster, 10000);
 46a:	695b      	ldr	r3, [r3, #20]
 46c:	4907      	ldr	r1, [pc, #28]	; (48c <MAX1164x_WriteCmd+0x48>)
 46e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 470:	6840      	ldr	r0, [r0, #4]
 472:	4798      	blx	r3
	LPC_I2CD_API->i2c_master_transmit_poll(MAX1164x->i2cHandleMaster, &param, &result);
 474:	6833      	ldr	r3, [r6, #0]
 476:	6868      	ldr	r0, [r5, #4]
 478:	695b      	ldr	r3, [r3, #20]
 47a:	1c21      	adds	r1, r4, #0
 47c:	685b      	ldr	r3, [r3, #4]
 47e:	aa02      	add	r2, sp, #8
 480:	4798      	blx	r3
}
 482:	b00a      	add	sp, #40	; 0x28
 484:	bd70      	pop	{r4, r5, r6, pc}
 486:	46c0      	nop			; (mov r8, r8)
 488:	1fff1ff8 	.word	0x1fff1ff8
 48c:	00002710 	.word	0x00002710

00000490 <MAX1164x_CBFunc>:

void MAX1164x_CBFunc(uint32_t err, uint32_t n)
{
	sample_count++;
 490:	4b02      	ldr	r3, [pc, #8]	; (49c <MAX1164x_CBFunc+0xc>)
 492:	881a      	ldrh	r2, [r3, #0]
 494:	3201      	adds	r2, #1
 496:	b292      	uxth	r2, r2
 498:	801a      	strh	r2, [r3, #0]
}
 49a:	4770      	bx	lr
 49c:	10000028 	.word	0x10000028

000004a0 <MAX1164x_UpdateConfig>:

////////////////////////// Public Functions ///////////////////////////////////

void MAX1164x_UpdateConfig(MAX1164x_t* MAX1164x)
{
 4a0:	b508      	push	{r3, lr}
	MAX1164x_WriteCmd(MAX1164x, MAX1164x->ConfigReg.Register);
 4a2:	7841      	ldrb	r1, [r0, #1]
 4a4:	f7ff ffce 	bl	444 <MAX1164x_WriteCmd>
}
 4a8:	bd08      	pop	{r3, pc}

000004aa <MAX1164x_UpdateSetup>:


void MAX1164x_UpdateSetup(MAX1164x_t* MAX1164x)
{
 4aa:	b508      	push	{r3, lr}
	MAX1164x_WriteCmd(MAX1164x, MAX1164x->SetupReg.Register);
 4ac:	7801      	ldrb	r1, [r0, #0]
 4ae:	f7ff ffc9 	bl	444 <MAX1164x_WriteCmd>
}
 4b2:	bd08      	pop	{r3, pc}

000004b4 <MAX1164x_Init>:
/***
 * Initialize the MAX1164x interface
 * Params: Speed, SDA pin, SCL pin
 */
void MAX1164x_Init(MAX1164x_t* MAX1164x, CHIP_PINx_T sda, CHIP_PINx_T scl)
{
 4b4:	b570      	push	{r4, r5, r6, lr}
 4b6:	1c0e      	adds	r6, r1, #0
 4b8:	1c04      	adds	r4, r0, #0
 4ba:	1c15      	adds	r5, r2, #0
	// Initialize the peripheral
	Chip_I2C_Init();
 4bc:	f000 fa7c 	bl	9b8 <Chip_I2C_Init>

	// Allow for 400kHz+ bit rate
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, sda, PIN_I2CMODE_FASTPLUS);
 4c0:	1c31      	adds	r1, r6, #0
 4c2:	4820      	ldr	r0, [pc, #128]	; (544 <MAX1164x_Init+0x90>)
 4c4:	2202      	movs	r2, #2
 4c6:	f000 fa87 	bl	9d8 <Chip_IOCON_PinSetI2CMode>
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, scl, PIN_I2CMODE_FASTPLUS);
 4ca:	1c29      	adds	r1, r5, #0
 4cc:	2202      	movs	r2, #2
 4ce:	481d      	ldr	r0, [pc, #116]	; (544 <MAX1164x_Init+0x90>)
 4d0:	f000 fa82 	bl	9d8 <Chip_IOCON_PinSetI2CMode>

	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
 4d4:	2382      	movs	r3, #130	; 0x82
 4d6:	7023      	strb	r3, [r4, #0]
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4d8:	4e1b      	ldr	r6, [pc, #108]	; (548 <MAX1164x_Init+0x94>)
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, sda, PIN_I2CMODE_FASTPLUS);
	Chip_IOCON_PinSetI2CMode(LPC_IOCON, scl, PIN_I2CMODE_FASTPLUS);

	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;
 4da:	2301      	movs	r3, #1
 4dc:	7063      	strb	r3, [r4, #1]

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4de:	6833      	ldr	r3, [r6, #0]
 4e0:	1c21      	adds	r1, r4, #0
 4e2:	695b      	ldr	r3, [r3, #20]
 4e4:	3108      	adds	r1, #8
 4e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 4e8:	4818      	ldr	r0, [pc, #96]	; (54c <MAX1164x_Init+0x98>)
 4ea:	4798      	blx	r3
 4ec:	4b18      	ldr	r3, [pc, #96]	; (550 <MAX1164x_Init+0x9c>)

	sample_count = 0;
 4ee:	2200      	movs	r2, #0
	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4f0:	6018      	str	r0, [r3, #0]

	sample_count = 0;
 4f2:	4b18      	ldr	r3, [pc, #96]	; (554 <MAX1164x_Init+0xa0>)
	// Initialize register models
	MAX1164x->SetupReg.Register = MAX1164x_SETUP_DEFAULT;
	MAX1164x->ConfigReg.Register = MAX1164x_CONFIG_DEFAULT;

	// Setup the I2C API handle
	localHandle = MAX1164x->i2cHandleMaster = LPC_I2CD_API->i2c_setup(LPC_I2C_BASE, MAX1164x->i2cMasterHandleMEM);
 4f4:	1c05      	adds	r5, r0, #0
 4f6:	6060      	str	r0, [r4, #4]

	sample_count = 0;
 4f8:	801a      	strh	r2, [r3, #0]

	if (MAX1164x->i2cHandleMaster == NULL)
 4fa:	4290      	cmp	r0, r2
 4fc:	d100      	bne.n	500 <MAX1164x_Init+0x4c>
 4fe:	e7fe      	b.n	4fe <MAX1164x_Init+0x4a>
		// If we get here, problems.  We should probably address this
		while(1){};
	}

	// Set I2C bitrate to normal "fast" mode
	if (LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE) != LPC_OK)
 500:	6833      	ldr	r3, [r6, #0]
 502:	695b      	ldr	r3, [r3, #20]
 504:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 506:	f000 fa4d 	bl	9a4 <Chip_Clock_GetSystemClockRate>
 50a:	4a13      	ldr	r2, [pc, #76]	; (558 <MAX1164x_Init+0xa4>)
 50c:	1c01      	adds	r1, r0, #0
 50e:	1c28      	adds	r0, r5, #0
 510:	47b0      	blx	r6
 512:	2800      	cmp	r0, #0
 514:	d000      	beq.n	518 <MAX1164x_Init+0x64>
 516:	e7fe      	b.n	516 <MAX1164x_Init+0x62>
		// If we get here, problems.  We should probably address this
		while(1){};
	}

	// Setup for use with external clock for max speed
	MAX1164x->SetupReg.BitField.clk = MAX1164x_EXT_CLK;
 518:	7823      	ldrb	r3, [r4, #0]
 51a:	2208      	movs	r2, #8
 51c:	4313      	orrs	r3, r2
 51e:	7023      	strb	r3, [r4, #0]

	// Set scan bits to scan up from in 0
	MAX1164x->ConfigReg.BitField.scan = MAX1164x_SCANFROMIN0;
 520:	7863      	ldrb	r3, [r4, #1]
	// Set scan to catch both inputs
	MAX1164x->ConfigReg.BitField.chan_sel = MAX1164x_CHAN_B;
 522:	2260      	movs	r2, #96	; 0x60
 524:	4393      	bics	r3, r2
 526:	2202      	movs	r2, #2
 528:	4313      	orrs	r3, r2
 52a:	7063      	strb	r3, [r4, #1]

	MAX1164x_UpdateSetup(MAX1164x);
 52c:	1c20      	adds	r0, r4, #0
 52e:	f7ff ffbc 	bl	4aa <MAX1164x_UpdateSetup>
	MAX1164x_UpdateConfig(MAX1164x);
 532:	1c20      	adds	r0, r4, #0
 534:	f7ff ffb4 	bl	4a0 <MAX1164x_UpdateConfig>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 538:	4b08      	ldr	r3, [pc, #32]	; (55c <MAX1164x_Init+0xa8>)
 53a:	2280      	movs	r2, #128	; 0x80
 53c:	0052      	lsls	r2, r2, #1
 53e:	601a      	str	r2, [r3, #0]

	NVIC_EnableIRQ(I2C_IRQn);
}
 540:	bd70      	pop	{r4, r5, r6, pc}
 542:	46c0      	nop			; (mov r8, r8)
 544:	40044000 	.word	0x40044000
 548:	1fff1ff8 	.word	0x1fff1ff8
 54c:	40050000 	.word	0x40050000
 550:	10000000 	.word	0x10000000
 554:	10000028 	.word	0x10000028
 558:	00061a80 	.word	0x00061a80
 55c:	e000e100 	.word	0xe000e100

00000560 <MAX1164x_SetSpeed>:


void MAX1164x_SetSpeed(MAX1164x_t* MAX1164x, bool spd)
{
 560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 562:	1c06      	adds	r6, r0, #0
 564:	4d17      	ldr	r5, [pc, #92]	; (5c4 <MAX1164x_SetSpeed+0x64>)
 566:	4c18      	ldr	r4, [pc, #96]	; (5c8 <MAX1164x_SetSpeed+0x68>)
	// Switch the clock to external if high-speed is requested
	// And speed up the bit i2C bit rate
	if (spd == MAX1164x_SPD_HI)
 568:	2900      	cmp	r1, #0
 56a:	d01a      	beq.n	5a2 <MAX1164x_SetSpeed+0x42>
	{
		BAP_I2C_InitiateHighSpeedMode();
 56c:	f000 f962 	bl	834 <BAP_I2C_InitiateHighSpeedMode>

		// Set I2C bitrate to normal "High Speed" mode
		if (LPC_I2CD_API->i2c_set_bitrate( localHandle,
 570:	682b      	ldr	r3, [r5, #0]
										   Chip_Clock_GetSystemClockRate(),
										   MAX1164x_HIGHSPEED_BITRATE) != LPC_OK )
 572:	6827      	ldr	r7, [r4, #0]
	if (spd == MAX1164x_SPD_HI)
	{
		BAP_I2C_InitiateHighSpeedMode();

		// Set I2C bitrate to normal "High Speed" mode
		if (LPC_I2CD_API->i2c_set_bitrate( localHandle,
 574:	695b      	ldr	r3, [r3, #20]
 576:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 578:	f000 fa14 	bl	9a4 <Chip_Clock_GetSystemClockRate>
 57c:	4a13      	ldr	r2, [pc, #76]	; (5cc <MAX1164x_SetSpeed+0x6c>)
 57e:	1c01      	adds	r1, r0, #0
 580:	1c38      	adds	r0, r7, #0
 582:	47b0      	blx	r6
 584:	2800      	cmp	r0, #0
 586:	d01b      	beq.n	5c0 <MAX1164x_SetSpeed+0x60>
										   Chip_Clock_GetSystemClockRate(),
										   MAX1164x_HIGHSPEED_BITRATE) != LPC_OK )
		{
			// If we get here, it means the bus can't move that quickly. Back it off a bit.
			BAP_I2C_DisableHighSpeedMode();
 588:	f000 f968 	bl	85c <BAP_I2C_DisableHighSpeedMode>
			LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE);
 58c:	682b      	ldr	r3, [r5, #0]
 58e:	6824      	ldr	r4, [r4, #0]
 590:	695b      	ldr	r3, [r3, #20]
 592:	6b9d      	ldr	r5, [r3, #56]	; 0x38
 594:	f000 fa06 	bl	9a4 <Chip_Clock_GetSystemClockRate>
 598:	4a0d      	ldr	r2, [pc, #52]	; (5d0 <MAX1164x_SetSpeed+0x70>)
 59a:	1c01      	adds	r1, r0, #0
 59c:	1c20      	adds	r0, r4, #0
 59e:	47a8      	blx	r5
 5a0:	e00e      	b.n	5c0 <MAX1164x_SetSpeed+0x60>
		}

	}
	else
	{
		BAP_I2C_DisableHighSpeedMode();
 5a2:	f000 f95b 	bl	85c <BAP_I2C_DisableHighSpeedMode>
		LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE);
 5a6:	682b      	ldr	r3, [r5, #0]
 5a8:	6824      	ldr	r4, [r4, #0]
 5aa:	695b      	ldr	r3, [r3, #20]
		MAX1164x->UseStopFlag = TRUE;
 5ac:	368c      	adds	r6, #140	; 0x8c

	}
	else
	{
		BAP_I2C_DisableHighSpeedMode();
		LPC_I2CD_API->i2c_set_bitrate(localHandle, Chip_Clock_GetSystemClockRate(), MAX1164x_FAST_BITRATE);
 5ae:	6b9d      	ldr	r5, [r3, #56]	; 0x38
 5b0:	f000 f9f8 	bl	9a4 <Chip_Clock_GetSystemClockRate>
 5b4:	4a06      	ldr	r2, [pc, #24]	; (5d0 <MAX1164x_SetSpeed+0x70>)
 5b6:	1c01      	adds	r1, r0, #0
 5b8:	1c20      	adds	r0, r4, #0
 5ba:	47a8      	blx	r5
		MAX1164x->UseStopFlag = TRUE;
 5bc:	2301      	movs	r3, #1
 5be:	7033      	strb	r3, [r6, #0]
	}
}
 5c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 5c2:	46c0      	nop			; (mov r8, r8)
 5c4:	1fff1ff8 	.word	0x1fff1ff8
 5c8:	10000000 	.word	0x10000000
 5cc:	000f4240 	.word	0x000f4240
 5d0:	00061a80 	.word	0x00061a80

000005d4 <MAX1164x_RequestNewSample>:



ErrorCode_t MAX1164x_RequestNewSample(MAX1164x_t* MAX1164x)
{
 5d4:	b500      	push	{lr}
 5d6:	b089      	sub	sp, #36	; 0x24
	I2C_PARAM_T param;

	// set the address
	uint8_t addr = (MAX1164x_I2C_ADDR_7BIT << 1);
 5d8:	466b      	mov	r3, sp
 5da:	226c      	movs	r2, #108	; 0x6c
 5dc:	71da      	strb	r2, [r3, #7]
 5de:	3307      	adds	r3, #7

	// fill out the parameter form
	param.num_bytes_send    = 1;
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
	param.buffer_ptr_send = &addr;
 5e0:	9304      	str	r3, [sp, #16]
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
	param.func_pt = MAX1164x_CBFunc;
 5e2:	4b0a      	ldr	r3, [pc, #40]	; (60c <MAX1164x_RequestNewSample+0x38>)

	// fill out the parameter form
	param.num_bytes_send    = 1;
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
	param.buffer_ptr_send = &addr;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
 5e4:	3088      	adds	r0, #136	; 0x88
	param.func_pt = MAX1164x_CBFunc;
 5e6:	9306      	str	r3, [sp, #24]

	/* Set timeout (much) greater than the transfer length */
	LPC_I2CD_API->i2c_set_timeout(localHandle, 100000);
 5e8:	4b09      	ldr	r3, [pc, #36]	; (610 <MAX1164x_RequestNewSample+0x3c>)

	// fill out the parameter form
	param.num_bytes_send    = 1;
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
	param.buffer_ptr_send = &addr;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
 5ea:	9005      	str	r0, [sp, #20]

	// set the address
	uint8_t addr = (MAX1164x_I2C_ADDR_7BIT << 1);

	// fill out the parameter form
	param.num_bytes_send    = 1;
 5ec:	2201      	movs	r2, #1
	param.buffer_ptr_send = &addr;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
	param.func_pt = MAX1164x_CBFunc;

	/* Set timeout (much) greater than the transfer length */
	LPC_I2CD_API->i2c_set_timeout(localHandle, 100000);
 5ee:	681b      	ldr	r3, [r3, #0]

	// set the address
	uint8_t addr = (MAX1164x_I2C_ADDR_7BIT << 1);

	// fill out the parameter form
	param.num_bytes_send    = 1;
 5f0:	9202      	str	r2, [sp, #8]
	param.num_bytes_rec     = MAX1164x_SAMPBYTECNT;
 5f2:	2204      	movs	r2, #4
 5f4:	9203      	str	r2, [sp, #12]
	param.buffer_ptr_send = &addr;
	param.buffer_ptr_rec = &MAX1164x->sample_buffer.buffer[0];
	param.func_pt = MAX1164x_CBFunc;

	/* Set timeout (much) greater than the transfer length */
	LPC_I2CD_API->i2c_set_timeout(localHandle, 100000);
 5f6:	695b      	ldr	r3, [r3, #20]
 5f8:	4a06      	ldr	r2, [pc, #24]	; (614 <MAX1164x_RequestNewSample+0x40>)
 5fa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 5fc:	6810      	ldr	r0, [r2, #0]
 5fe:	4906      	ldr	r1, [pc, #24]	; (618 <MAX1164x_RequestNewSample+0x44>)
 600:	4798      	blx	r3

	/* Do master read transfer */
	int error =  BAP_I2C_MasterProcessNewMessage(&param);
 602:	a802      	add	r0, sp, #8
 604:	f000 f8d8 	bl	7b8 <BAP_I2C_MasterProcessNewMessage>
	return error;
}
 608:	b009      	add	sp, #36	; 0x24
 60a:	bd00      	pop	{pc}
 60c:	00000491 	.word	0x00000491
 610:	1fff1ff8 	.word	0x1fff1ff8
 614:	10000000 	.word	0x10000000
 618:	000186a0 	.word	0x000186a0

0000061c <TLV_Init>:
RINGBUFF_T TLC_TxBuffer;



void TLV_Init()
{
 61c:	b538      	push	{r3, r4, r5, lr}
	// Prep the Transmit frame buffer
	RingBuffer_Init(&TLC_TxBuffer, &TLC_TxBufData, sizeof(uint16_t), TLV_BUFFER_SIZE);
 61e:	4913      	ldr	r1, [pc, #76]	; (66c <TLV_Init+0x50>)
 620:	2202      	movs	r2, #2
 622:	230a      	movs	r3, #10
 624:	4812      	ldr	r0, [pc, #72]	; (670 <TLV_Init+0x54>)
 626:	f000 f9e3 	bl	9f0 <RingBuffer_Init>
 * @note	The peripheral will stay in reset until reset is de-asserted. Call
 * Chip_SYSCTL_DeassertPeriphReset() to de-assert the reset
 */
STATIC INLINE void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL &= ~(1 << (uint32_t) periph);
 62a:	4b12      	ldr	r3, [pc, #72]	; (674 <TLV_Init+0x58>)
 62c:	2501      	movs	r5, #1
 62e:	685a      	ldr	r2, [r3, #4]
	Chip_SYSCTL_PeriphReset(RESET_SPI0);

	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_LO)) & ~((uint32_t) SPI_CFG_SPI_EN);
 630:	4c11      	ldr	r4, [pc, #68]	; (678 <TLV_Init+0x5c>)
 632:	43aa      	bics	r2, r5
 634:	605a      	str	r2, [r3, #4]
 * @param	periph	: Peripheral to de-assert reset for
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL |= (1 << (uint32_t) periph);
 636:	685a      	ldr	r2, [r3, #4]

	// Set the rate to 10MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 10000000));
 638:	1c20      	adds	r0, r4, #0
 63a:	432a      	orrs	r2, r5
 63c:	605a      	str	r2, [r3, #4]
	// Prep the Transmit frame buffer
	RingBuffer_Init(&TLC_TxBuffer, &TLC_TxBufData, sizeof(uint16_t), TLV_BUFFER_SIZE);
	Chip_SYSCTL_PeriphReset(RESET_SPI0);

	// SPI Configure
	LPC_SPI0->CFG = (((uint32_t) SPI_MODE_MASTER) | ((uint32_t) SPI_DATA_MSB_FIRST) | ((uint32_t) SPI_CLOCK_MODE2) | ((uint32_t) SPI_SSEL_ACTIVE_LO)) & ~((uint32_t) SPI_CFG_SPI_EN);
 63e:	2324      	movs	r3, #36	; 0x24
 640:	6023      	str	r3, [r4, #0]

	// Set the rate to 10MHz
	LPC_SPI0->DIV = SPI_DIV_VAL(Chip_SPI_CalClkRateDivider(LPC_SPI0, 10000000));
 642:	490e      	ldr	r1, [pc, #56]	; (67c <TLV_Init+0x60>)
 644:	f000 fa0e 	bl	a64 <Chip_SPI_CalClkRateDivider>
 648:	b280      	uxth	r0, r0
 64a:	6260      	str	r0, [r4, #36]	; 0x24
 * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_CLR_*)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
{
	pSPI->STAT |= Flag;
 64c:	68a3      	ldr	r3, [r4, #8]
 64e:	223c      	movs	r2, #60	; 0x3c
 650:	4313      	orrs	r3, r2
 652:	60a3      	str	r3, [r4, #8]

	// Clear status flags
	Chip_SPI_ClearStatus(LPC_SPI0, SPI_STAT_CLR_RXOV | SPI_STAT_CLR_TXUR | SPI_STAT_CLR_SSA | SPI_STAT_CLR_SSD);

	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN | SPI_INTENCLR_RXDYEN | SPI_INTENCLR_RXOVEN | SPI_INTENCLR_TXUREN, DISABLE);
 654:	1c20      	adds	r0, r4, #0
 656:	210f      	movs	r1, #15
 658:	2200      	movs	r2, #0
 65a:	f000 fa0b 	bl	a74 <Chip_SPI_Int_Cmd>
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
{
	pSPI->CFG |= SPI_CFG_SPI_EN;
 65e:	6823      	ldr	r3, [r4, #0]
 660:	432b      	orrs	r3, r5
 662:	6023      	str	r3, [r4, #0]
 664:	4b06      	ldr	r3, [pc, #24]	; (680 <TLV_Init+0x64>)
 666:	601d      	str	r5, [r3, #0]

	// Enable the SPI
	Chip_SPI_Enable(LPC_SPI0);
 	NVIC_EnableIRQ(SPI0_IRQn);
}
 668:	bd38      	pop	{r3, r4, r5, pc}
 66a:	46c0      	nop			; (mov r8, r8)
 66c:	10000044 	.word	0x10000044
 670:	10000030 	.word	0x10000030
 674:	40048000 	.word	0x40048000
 678:	40058000 	.word	0x40058000
 67c:	00989680 	.word	0x00989680
 680:	e000e100 	.word	0xe000e100

00000684 <TLV_SetDACValue>:

/***
 * Sets the value for the selected DAC.  Returns -1 on error, 0 on success
 */
int8_t TLV_SetDACValue(TLV_DACNumber DAC, TLV_Speed speed, uint16_t value)
{
 684:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint16_t frame = 0;

	// Code the frame with the right dac and speed
	switch(DAC)
 686:	2800      	cmp	r0, #0
 688:	d006      	beq.n	698 <TLV_SetDACValue+0x14>
 68a:	2801      	cmp	r0, #1
 68c:	d12c      	bne.n	6e8 <TLV_SetDACValue+0x64>
	{
	case(TLV_DAC_1):
			frame = TLV_R1(1) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 68e:	0512      	lsls	r2, r2, #20
 690:	0389      	lsls	r1, r1, #14
 692:	0d12      	lsrs	r2, r2, #20
 694:	4311      	orrs	r1, r2
 696:	e006      	b.n	6a6 <TLV_SetDACValue+0x22>

	// Code the frame with the right dac and speed
	switch(DAC)
	{
	case(TLV_DAC_1):
			frame = TLV_R1(1) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 698:	4b15      	ldr	r3, [pc, #84]	; (6f0 <TLV_SetDACValue+0x6c>)
 69a:	0512      	lsls	r2, r2, #20
 69c:	0d12      	lsrs	r2, r2, #20
 69e:	431a      	orrs	r2, r3
 6a0:	038b      	lsls	r3, r1, #14
 6a2:	1c11      	adds	r1, r2, #0
 6a4:	4319      	orrs	r1, r3
 * @param	pSPI	: The base of SPI peripheral on the chip
 * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
 */
STATIC INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
{
	return pSPI->STAT;
 6a6:	4813      	ldr	r0, [pc, #76]	; (6f4 <TLV_SetDACValue+0x70>)
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
 6a8:	466b      	mov	r3, sp
 6aa:	6884      	ldr	r4, [r0, #8]
 6ac:	80d9      	strh	r1, [r3, #6]
 6ae:	466a      	mov	r2, sp
		return -1; //Error: Not a valid dac number
		break;
	}

	// If the SPI is ready and the buffer is empty.
    if ((Chip_SPI_GetStatus(LPC_SPI0) & SPI_STAT_TXRDY) && RingBuffer_IsEmpty(&TLC_TxBuffer))
 6b0:	2102      	movs	r1, #2
 6b2:	3206      	adds	r2, #6
 6b4:	4b10      	ldr	r3, [pc, #64]	; (6f8 <TLV_SetDACValue+0x74>)
 6b6:	420c      	tst	r4, r1
 6b8:	d00d      	beq.n	6d6 <TLV_SetDACValue+0x52>
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 6ba:	68dd      	ldr	r5, [r3, #12]
 6bc:	691c      	ldr	r4, [r3, #16]
 6be:	42a5      	cmp	r5, r4
 6c0:	d109      	bne.n	6d6 <TLV_SetDACValue+0x52>
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 6c2:	8812      	ldrh	r2, [r2, #0]
 6c4:	23f7      	movs	r3, #247	; 0xf7
 6c6:	051b      	lsls	r3, r3, #20
 6c8:	4313      	orrs	r3, r2
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 6ca:	6183      	str	r3, [r0, #24]
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

		// enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN, ENABLE);
 6cc:	2201      	movs	r2, #1
 6ce:	f000 f9d1 	bl	a74 <Chip_SPI_Int_Cmd>
	// Otherwise insert the new frame onto the buffer
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
	{
    	return -1;
	}
    return 0;
 6d2:	2000      	movs	r0, #0
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

		// enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN, ENABLE);
 6d4:	e009      	b.n	6ea <TLV_SetDACValue+0x66>
    }

	// Otherwise insert the new frame onto the buffer
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
 6d6:	1c18      	adds	r0, r3, #0
 6d8:	1c11      	adds	r1, r2, #0
 6da:	f000 f991 	bl	a00 <RingBuffer_Insert>
 6de:	4243      	negs	r3, r0
 6e0:	4158      	adcs	r0, r3
 6e2:	4240      	negs	r0, r0
 6e4:	b2c0      	uxtb	r0, r0
 6e6:	e000      	b.n	6ea <TLV_SetDACValue+0x66>
			break;
	case(TLV_DAC_2):
			frame = TLV_R1(0) | TLV_SPD(speed) | TLV_R2(0) | TLV_Datamask(value);
			break;
	default:
		return -1; //Error: Not a valid dac number
 6e8:	20ff      	movs	r0, #255	; 0xff
 6ea:	b240      	sxtb	r0, r0
    else if (!RingBuffer_Insert(&TLC_TxBuffer, &frame))
	{
    	return -1;
	}
    return 0;
}
 6ec:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 6ee:	46c0      	nop			; (mov r8, r8)
 6f0:	ffff8000 	.word	0xffff8000
 6f4:	40058000 	.word	0x40058000
 6f8:	10000030 	.word	0x10000030

000006fc <SPI0_IRQHandler>:


void SPI0_IRQHandler(void)
{
 6fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Disable all interrupts
	Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENCLR_TXDYEN, DISABLE);
 6fe:	4c0e      	ldr	r4, [pc, #56]	; (738 <SPI0_IRQHandler+0x3c>)
 700:	2200      	movs	r2, #0
 702:	1c20      	adds	r0, r4, #0
 704:	2102      	movs	r1, #2
 706:	f000 f9b5 	bl	a74 <Chip_SPI_Int_Cmd>
 70a:	480c      	ldr	r0, [pc, #48]	; (73c <SPI0_IRQHandler+0x40>)
 70c:	68c2      	ldr	r2, [r0, #12]
 70e:	6903      	ldr	r3, [r0, #16]

	// If the buffer isn't empty, load up the next frame
	if (!RingBuffer_IsEmpty(&TLC_TxBuffer))
 710:	429a      	cmp	r2, r3
 712:	d010      	beq.n	736 <SPI0_IRQHandler+0x3a>
	{
		// Get the next value
		uint16_t frame = 0;
 714:	466d      	mov	r5, sp
 716:	2300      	movs	r3, #0
 718:	80eb      	strh	r3, [r5, #6]
 71a:	3506      	adds	r5, #6
		RingBuffer_Pop(&TLC_TxBuffer, &frame);
 71c:	1c29      	adds	r1, r5, #0
 71e:	f000 f989 	bl	a34 <RingBuffer_Pop>
					 SPI_TXDATCTL_FLEN(DataSize - 1) | SPI_TXDATCTL_DATA(Data);
 722:	882a      	ldrh	r2, [r5, #0]
 724:	23f7      	movs	r3, #247	; 0xf7
 726:	051b      	lsls	r3, r3, #20
 728:	4313      	orrs	r3, r2
 * @param	DataSize	:  Data Size (1-16)
 * @return	Nothing
 */
STATIC INLINE void Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI_T *pSPI, uint16_t Data, uint8_t DataSize)
{
	pSPI->TXDATCTL = SPI_TXDATCTL_ASSERT_SSEL | SPI_TXDATCTL_EOF | SPI_TXDATCTL_EOT | SPI_TXDATCTL_RXIGNORE |
 72a:	61a3      	str	r3, [r4, #24]
    	// and the full message fits with a frame,
    	// we assume this will be the final frame.
    	Chip_SPI_SendLastFrame_RxIgnore(LPC_SPI0, frame, 16);

    	// Enable the interrupt
		Chip_SPI_Int_Cmd(LPC_SPI0, SPI_INTENSET_TXDYEN , ENABLE);
 72c:	1c20      	adds	r0, r4, #0
 72e:	2102      	movs	r1, #2
 730:	2201      	movs	r2, #1
 732:	f000 f99f 	bl	a74 <Chip_SPI_Int_Cmd>
	}
}
 736:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 738:	40058000 	.word	0x40058000
 73c:	10000030 	.word	0x10000030

00000740 <I2C_IRQHandler>:

void I2C_IRQHandler(void)
{
	// Check what interrupt triggered the request
	// If it was the service becoming available, check on the status of the message
	if (BAP_I2C->INTSTAT & BAP_I2C_MSTPENDING)
 740:	4b19      	ldr	r3, [pc, #100]	; (7a8 <I2C_IRQHandler+0x68>)
	local_param.num_bytes_rec--;
}


void I2C_IRQHandler(void)
{
 742:	b570      	push	{r4, r5, r6, lr}
	// Check what interrupt triggered the request
	// If it was the service becoming available, check on the status of the message
	if (BAP_I2C->INTSTAT & BAP_I2C_MSTPENDING)
 744:	699a      	ldr	r2, [r3, #24]
 746:	2401      	movs	r4, #1
 748:	4222      	tst	r2, r4
 74a:	d02c      	beq.n	7a6 <I2C_IRQHandler+0x66>
	{
		// If the transmit isn't over, transmit! This should clear the interrupt on its own?
		if(local_param.num_bytes_send != 0)
 74c:	4a17      	ldr	r2, [pc, #92]	; (7ac <I2C_IRQHandler+0x6c>)
 74e:	6811      	ldr	r1, [r2, #0]
 750:	2900      	cmp	r1, #0
 752:	d00c      	beq.n	76e <I2C_IRQHandler+0x2e>


static void BAP_I2C_Master_TX_Continue()
{
	// Load the data register with the value under the index.
	BAP_I2C->MSTDAT = local_param.buffer_ptr_send[master_tx_index++];
 754:	4d16      	ldr	r5, [pc, #88]	; (7b0 <I2C_IRQHandler+0x70>)

	// continue the transfer
	BAP_I2C->MSTCTL |= BAP_I2C_MSTCONTINUE;

	// decrement the quantity of things we have to transmit
	local_param.num_bytes_send--;
 756:	3901      	subs	r1, #1


static void BAP_I2C_Master_TX_Continue()
{
	// Load the data register with the value under the index.
	BAP_I2C->MSTDAT = local_param.buffer_ptr_send[master_tx_index++];
 758:	6828      	ldr	r0, [r5, #0]
 75a:	1906      	adds	r6, r0, r4
 75c:	602e      	str	r6, [r5, #0]
 75e:	6895      	ldr	r5, [r2, #8]
 760:	5c28      	ldrb	r0, [r5, r0]
 762:	6258      	str	r0, [r3, #36]	; 0x24

	// continue the transfer
	BAP_I2C->MSTCTL |= BAP_I2C_MSTCONTINUE;
 764:	69d8      	ldr	r0, [r3, #28]
 766:	4304      	orrs	r4, r0
 768:	61dc      	str	r4, [r3, #28]

	// decrement the quantity of things we have to transmit
	local_param.num_bytes_send--;
 76a:	6011      	str	r1, [r2, #0]
 76c:	e01b      	b.n	7a6 <I2C_IRQHandler+0x66>
		{
			BAP_I2C_Master_TX_Continue();
		}

		// If the receive isn't over, receive!
		else if (local_param.num_bytes_rec != 0)
 76e:	6851      	ldr	r1, [r2, #4]
 770:	2900      	cmp	r1, #0
 772:	d00c      	beq.n	78e <I2C_IRQHandler+0x4e>


static void BAP_I2C_Master_RX_Continue()
{
	// Copy the byte into the buffer
	local_param.buffer_ptr_rec[master_rx_index++] = BAP_I2C->MSTDAT;
 774:	4d0f      	ldr	r5, [pc, #60]	; (7b4 <I2C_IRQHandler+0x74>)

	// Continue with the reception
	BAP_I2C->MSTCTL |= BAP_I2C_MSTCONTINUE;

	// decrement the quantity of things we have to receive
	local_param.num_bytes_rec--;
 776:	3901      	subs	r1, #1


static void BAP_I2C_Master_RX_Continue()
{
	// Copy the byte into the buffer
	local_param.buffer_ptr_rec[master_rx_index++] = BAP_I2C->MSTDAT;
 778:	6828      	ldr	r0, [r5, #0]
 77a:	1c46      	adds	r6, r0, #1
 77c:	602e      	str	r6, [r5, #0]
 77e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 780:	68d6      	ldr	r6, [r2, #12]
 782:	5435      	strb	r5, [r6, r0]

	// Continue with the reception
	BAP_I2C->MSTCTL |= BAP_I2C_MSTCONTINUE;
 784:	69d8      	ldr	r0, [r3, #28]
 786:	4304      	orrs	r4, r0
 788:	61dc      	str	r4, [r3, #28]

	// decrement the quantity of things we have to receive
	local_param.num_bytes_rec--;
 78a:	6051      	str	r1, [r2, #4]
 78c:	e00b      	b.n	7a6 <I2C_IRQHandler+0x66>
		}

		// If everything is done, turn off the interrupt, issue a stop or not, and fire the callback or not.
		else
		{
			BAP_I2C->INTENCLR = BAP_I2C_MSTPENDING;
 78e:	60dc      	str	r4, [r3, #12]
			BAP_I2C->MSTCTL |= BAP_I2C_MSTSTOP(local_param.stop_flag);
 790:	7d15      	ldrb	r5, [r2, #20]
 792:	69d8      	ldr	r0, [r3, #28]
 794:	402c      	ands	r4, r5
 796:	00a4      	lsls	r4, r4, #2
 798:	4304      	orrs	r4, r0
 79a:	61dc      	str	r4, [r3, #28]

			if(local_param.func_pt != NULL)
 79c:	6913      	ldr	r3, [r2, #16]
 79e:	2b00      	cmp	r3, #0
 7a0:	d001      	beq.n	7a6 <I2C_IRQHandler+0x66>
				local_param.func_pt(LPC_OK, 0);
 7a2:	1c08      	adds	r0, r1, #0
 7a4:	4798      	blx	r3
		}
	}
}
 7a6:	bd70      	pop	{r4, r5, r6, pc}
 7a8:	40050000 	.word	0x40050000
 7ac:	10000010 	.word	0x10000010
 7b0:	1000000c 	.word	0x1000000c
 7b4:	10000004 	.word	0x10000004

000007b8 <BAP_I2C_MasterProcessNewMessage>:
}

ErrorCode_t BAP_I2C_MasterProcessNewMessage(I2C_PARAM_T* param)
{
	// check to make sure everything will fit
	if (param->num_bytes_rec > mem_size || param->num_bytes_send > mem_size)
 7b8:	4a18      	ldr	r2, [pc, #96]	; (81c <BAP_I2C_MasterProcessNewMessage+0x64>)
{
	return LPC_OK; //TODO: write this code instead of relying entirely on the API
}

ErrorCode_t BAP_I2C_MasterProcessNewMessage(I2C_PARAM_T* param)
{
 7ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// check to make sure everything will fit
	if (param->num_bytes_rec > mem_size || param->num_bytes_send > mem_size)
 7bc:	6811      	ldr	r1, [r2, #0]
 7be:	6843      	ldr	r3, [r0, #4]
 7c0:	428b      	cmp	r3, r1
 7c2:	d828      	bhi.n	816 <BAP_I2C_MasterProcessNewMessage+0x5e>
 7c4:	6802      	ldr	r2, [r0, #0]
 7c6:	428a      	cmp	r2, r1
 7c8:	d825      	bhi.n	816 <BAP_I2C_MasterProcessNewMessage+0x5e>
	{
		return ERR_I2C_BUFFER_OVERFLOW;
	}

	// is the I2C bus finished processing the last message?
	if ((local_param.num_bytes_send == 0) && (local_param.num_bytes_rec == 0))
 7ca:	4c15      	ldr	r4, [pc, #84]	; (820 <BAP_I2C_MasterProcessNewMessage+0x68>)
		// Start the transmission
		BAP_I2C_Master_TX_Start();
	}
	else
	{
		return LPC_ERROR;
 7cc:	2501      	movs	r5, #1
	{
		return ERR_I2C_BUFFER_OVERFLOW;
	}

	// is the I2C bus finished processing the last message?
	if ((local_param.num_bytes_send == 0) && (local_param.num_bytes_rec == 0))
 7ce:	6821      	ldr	r1, [r4, #0]
 7d0:	2900      	cmp	r1, #0
 7d2:	d121      	bne.n	818 <BAP_I2C_MasterProcessNewMessage+0x60>
 7d4:	6866      	ldr	r6, [r4, #4]
 7d6:	2e00      	cmp	r6, #0
 7d8:	d11e      	bne.n	818 <BAP_I2C_MasterProcessNewMessage+0x60>
	{
		// Copy the relevant param items
		local_param.buffer_ptr_rec = param->buffer_ptr_rec;
		local_param.num_bytes_rec = param->num_bytes_rec;
 7da:	6063      	str	r3, [r4, #4]
		local_param.num_bytes_send = param->num_bytes_send;
		local_param.func_pt = param->func_pt;
 7dc:	6903      	ldr	r3, [r0, #16]

	// is the I2C bus finished processing the last message?
	if ((local_param.num_bytes_send == 0) && (local_param.num_bytes_rec == 0))
	{
		// Copy the relevant param items
		local_param.buffer_ptr_rec = param->buffer_ptr_rec;
 7de:	68c1      	ldr	r1, [r0, #12]
		local_param.num_bytes_send = param->num_bytes_send;
		local_param.func_pt = param->func_pt;

		// clear the indexes
		master_rx_index = 0;
		master_tx_index = 0;
 7e0:	4f10      	ldr	r7, [pc, #64]	; (824 <BAP_I2C_MasterProcessNewMessage+0x6c>)
	{
		// Copy the relevant param items
		local_param.buffer_ptr_rec = param->buffer_ptr_rec;
		local_param.num_bytes_rec = param->num_bytes_rec;
		local_param.num_bytes_send = param->num_bytes_send;
		local_param.func_pt = param->func_pt;
 7e2:	6123      	str	r3, [r4, #16]

		// clear the indexes
		master_rx_index = 0;
 7e4:	4b10      	ldr	r3, [pc, #64]	; (828 <BAP_I2C_MasterProcessNewMessage+0x70>)

	// is the I2C bus finished processing the last message?
	if ((local_param.num_bytes_send == 0) && (local_param.num_bytes_rec == 0))
	{
		// Copy the relevant param items
		local_param.buffer_ptr_rec = param->buffer_ptr_rec;
 7e6:	60e1      	str	r1, [r4, #12]
		// clear the indexes
		master_rx_index = 0;
		master_tx_index = 0;

		// Copy the buffer
		memcpy(local_param.buffer_ptr_send, param->buffer_ptr_send, param->num_bytes_send);
 7e8:	6881      	ldr	r1, [r0, #8]
 7ea:	68a0      	ldr	r0, [r4, #8]
	if ((local_param.num_bytes_send == 0) && (local_param.num_bytes_rec == 0))
	{
		// Copy the relevant param items
		local_param.buffer_ptr_rec = param->buffer_ptr_rec;
		local_param.num_bytes_rec = param->num_bytes_rec;
		local_param.num_bytes_send = param->num_bytes_send;
 7ec:	6022      	str	r2, [r4, #0]
		local_param.func_pt = param->func_pt;

		// clear the indexes
		master_rx_index = 0;
 7ee:	601e      	str	r6, [r3, #0]
		master_tx_index = 0;
 7f0:	603e      	str	r6, [r7, #0]

		// Copy the buffer
		memcpy(local_param.buffer_ptr_send, param->buffer_ptr_send, param->num_bytes_send);
 7f2:	f000 f99b 	bl	b2c <memcpy>

//// Static functions and IRQ
static void BAP_I2C_Master_TX_Start()
{
	// Load the data register with the value under the index.
	BAP_I2C->MSTDAT = local_param.buffer_ptr_send[master_tx_index++];
 7f6:	683b      	ldr	r3, [r7, #0]
 7f8:	68a2      	ldr	r2, [r4, #8]
 7fa:	1959      	adds	r1, r3, r5
 7fc:	5cd2      	ldrb	r2, [r2, r3]
 7fe:	4b0b      	ldr	r3, [pc, #44]	; (82c <BAP_I2C_MasterProcessNewMessage+0x74>)
 800:	6039      	str	r1, [r7, #0]
 802:	625a      	str	r2, [r3, #36]	; 0x24

	// enable the MSTPENDING interrupt flag
	BAP_I2C->INTENSET |= BAP_I2C_MSTPENDING;
 804:	689a      	ldr	r2, [r3, #8]

	// start the transfer
	BAP_I2C->MSTCTL |= BAP_I2C_MSTSTART;
 806:	2102      	movs	r1, #2
{
	// Load the data register with the value under the index.
	BAP_I2C->MSTDAT = local_param.buffer_ptr_send[master_tx_index++];

	// enable the MSTPENDING interrupt flag
	BAP_I2C->INTENSET |= BAP_I2C_MSTPENDING;
 808:	4315      	orrs	r5, r2
 80a:	609d      	str	r5, [r3, #8]

	// start the transfer
	BAP_I2C->MSTCTL |= BAP_I2C_MSTSTART;
 80c:	69da      	ldr	r2, [r3, #28]
	else
	{
		return LPC_ERROR;
	}
	
	return LPC_OK;
 80e:	1c35      	adds	r5, r6, #0

	// enable the MSTPENDING interrupt flag
	BAP_I2C->INTENSET |= BAP_I2C_MSTPENDING;

	// start the transfer
	BAP_I2C->MSTCTL |= BAP_I2C_MSTSTART;
 810:	430a      	orrs	r2, r1
 812:	61da      	str	r2, [r3, #28]
 814:	e000      	b.n	818 <BAP_I2C_MasterProcessNewMessage+0x60>
ErrorCode_t BAP_I2C_MasterProcessNewMessage(I2C_PARAM_T* param)
{
	// check to make sure everything will fit
	if (param->num_bytes_rec > mem_size || param->num_bytes_send > mem_size)
	{
		return ERR_I2C_BUFFER_OVERFLOW;
 816:	4d06      	ldr	r5, [pc, #24]	; (830 <BAP_I2C_MasterProcessNewMessage+0x78>)
	{
		return LPC_ERROR;
	}
	
	return LPC_OK;
}
 818:	1c28      	adds	r0, r5, #0
 81a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 81c:	10000008 	.word	0x10000008
 820:	10000010 	.word	0x10000010
 824:	1000000c 	.word	0x1000000c
 828:	10000004 	.word	0x10000004
 82c:	40050000 	.word	0x40050000
 830:	00060002 	.word	0x00060002

00000834 <BAP_I2C_InitiateHighSpeedMode>:

/***
 * Remember to set the pins to operate in high-speed mode if using this function
 */
ErrorCode_t BAP_I2C_InitiateHighSpeedMode()
{
 834:	b500      	push	{lr}
 836:	b089      	sub	sp, #36	; 0x24
	uint8_t hispeed = I2C_MASTERCMD_HIGHSPEED;
 838:	466b      	mov	r3, sp
 83a:	220f      	movs	r2, #15
 83c:	71da      	strb	r2, [r3, #7]
	I2C_PARAM_T param;

	param.num_bytes_send = 1;
 83e:	2201      	movs	r2, #1
 840:	9202      	str	r2, [sp, #8]
/***
 * Remember to set the pins to operate in high-speed mode if using this function
 */
ErrorCode_t BAP_I2C_InitiateHighSpeedMode()
{
	uint8_t hispeed = I2C_MASTERCMD_HIGHSPEED;
 842:	3307      	adds	r3, #7
	I2C_PARAM_T param;

	param.num_bytes_send = 1;
	param.buffer_ptr_send = &hispeed;
	param.num_bytes_rec = 0;
	local_param.stop_flag = 0; // No stop flags after going into high-speed mode!
 844:	4a04      	ldr	r2, [pc, #16]	; (858 <BAP_I2C_InitiateHighSpeedMode+0x24>)
{
	uint8_t hispeed = I2C_MASTERCMD_HIGHSPEED;
	I2C_PARAM_T param;

	param.num_bytes_send = 1;
	param.buffer_ptr_send = &hispeed;
 846:	9304      	str	r3, [sp, #16]
	param.num_bytes_rec = 0;
	local_param.stop_flag = 0; // No stop flags after going into high-speed mode!

	// Start the new message, return the errors.
	return  BAP_I2C_MasterProcessNewMessage(&param);
 848:	a802      	add	r0, sp, #8
	uint8_t hispeed = I2C_MASTERCMD_HIGHSPEED;
	I2C_PARAM_T param;

	param.num_bytes_send = 1;
	param.buffer_ptr_send = &hispeed;
	param.num_bytes_rec = 0;
 84a:	2300      	movs	r3, #0
 84c:	9303      	str	r3, [sp, #12]
	local_param.stop_flag = 0; // No stop flags after going into high-speed mode!
 84e:	7513      	strb	r3, [r2, #20]

	// Start the new message, return the errors.
	return  BAP_I2C_MasterProcessNewMessage(&param);
 850:	f7ff ffb2 	bl	7b8 <BAP_I2C_MasterProcessNewMessage>
}
 854:	b009      	add	sp, #36	; 0x24
 856:	bd00      	pop	{pc}
 858:	10000010 	.word	0x10000010

0000085c <BAP_I2C_DisableHighSpeedMode>:

void BAP_I2C_DisableHighSpeedMode(uint32_t newspeed)
{
	local_param.stop_flag = 1; // turn the stop-flag back on
 85c:	4b01      	ldr	r3, [pc, #4]	; (864 <BAP_I2C_DisableHighSpeedMode+0x8>)
 85e:	2201      	movs	r2, #1
 860:	751a      	strb	r2, [r3, #20]
	BAP_I2C_SetBaud(newspeed); // reset to new speed
}
 862:	4770      	bx	lr
 864:	10000010 	.word	0x10000010

00000868 <Chip_ACMP_SetupAMCPRefs>:

/* Helper function for setting up ACMP control */
void Chip_ACMP_SetupAMCPRefs(LPC_CMP_T *pACMP, ACMP_EDGESEL_T edgeSel,
							 ACMP_POS_INPUT_T Posinput, ACMP_NEG_INPUT_T Neginput,
							 ACMP_HYS_T hys)
{
 868:	b530      	push	{r4, r5, lr}
	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK |
 86a:	6805      	ldr	r5, [r0, #0]
 86c:	4c04      	ldr	r4, [pc, #16]	; (880 <Chip_ACMP_SetupAMCPRefs+0x18>)
 86e:	402c      	ands	r4, r5
								   ACMP_COMPVMSEL_MASK | ACMP_COMPVPSEL_MASK | ACMP_EDGESEL_MASK);

	/* Select negative input */
	pACMP->CTRL = reg | (uint32_t) edgeSel | (uint32_t) Posinput |
 870:	4321      	orrs	r1, r4
 872:	430a      	orrs	r2, r1
 874:	431a      	orrs	r2, r3
				  (uint32_t) Neginput | (uint32_t) hys;
 876:	9b03      	ldr	r3, [sp, #12]
 878:	431a      	orrs	r2, r3
{
	uint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK |
								   ACMP_COMPVMSEL_MASK | ACMP_COMPVPSEL_MASK | ACMP_EDGESEL_MASK);

	/* Select negative input */
	pACMP->CTRL = reg | (uint32_t) edgeSel | (uint32_t) Posinput |
 87a:	6002      	str	r2, [r0, #0]
				  (uint32_t) Neginput | (uint32_t) hys;
}
 87c:	bd30      	pop	{r4, r5, pc}
 87e:	46c0      	nop			; (mov r8, r8)
 880:	f9ffc0e7 	.word	0xf9ffc0e7

00000884 <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
 884:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
 886:	f000 f88d 	bl	9a4 <Chip_Clock_GetSystemClockRate>
 88a:	4b01      	ldr	r3, [pc, #4]	; (890 <SystemCoreClockUpdate+0xc>)
 88c:	6018      	str	r0, [r3, #0]
}
 88e:	bd08      	pop	{r3, pc}
 890:	10000058 	.word	0x10000058

00000894 <Chip_Clock_GetWDTLFORate>:
 * Private functions
 ****************************************************************************/

/* Compute a WDT or LFO rate */
static uint32_t Chip_Clock_GetWDTLFORate(uint32_t reg)
{
 894:	b508      	push	{r3, lr}
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 896:	05c2      	lsls	r2, r0, #23
 898:	0f12      	lsrs	r2, r2, #28
	div = reg & 0x1F;
 89a:	211f      	movs	r1, #31
 89c:	4001      	ands	r1, r0

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 89e:	0092      	lsls	r2, r2, #2
 8a0:	4b03      	ldr	r3, [pc, #12]	; (8b0 <Chip_Clock_GetWDTLFORate+0x1c>)
 8a2:	58d0      	ldr	r0, [r2, r3]
 8a4:	3101      	adds	r1, #1
 8a6:	0049      	lsls	r1, r1, #1
 8a8:	f000 f94b 	bl	b42 <__aeabi_uidiv>
}
 8ac:	bd08      	pop	{r3, pc}
 8ae:	46c0      	nop			; (mov r8, r8)
 8b0:	00000bec 	.word	0x00000bec

000008b4 <Chip_Clock_GetPLLFreq>:

/* Compute a PLL frequency */
static uint32_t Chip_Clock_GetPLLFreq(uint32_t PLLReg, uint32_t inputRate)
{
	uint32_t msel = ((PLLReg & 0x1F) + 1);
 8b4:	231f      	movs	r3, #31
 8b6:	4018      	ands	r0, r3
 8b8:	3001      	adds	r0, #1

	return inputRate * msel;
 8ba:	4348      	muls	r0, r1
}
 8bc:	4770      	bx	lr
 8be:	46c0      	nop			; (mov r8, r8)

000008c0 <Chip_Clock_SetSystemPLLSource>:
 ****************************************************************************/

/* Set System PLL clock source */
void Chip_Clock_SetSystemPLLSource(CHIP_SYSCTL_PLLCLKSRC_T src)
{
	LPC_SYSCTL->SYSPLLCLKSEL  = (uint32_t) src;
 8c0:	4b03      	ldr	r3, [pc, #12]	; (8d0 <Chip_Clock_SetSystemPLLSource+0x10>)
 8c2:	6418      	str	r0, [r3, #64]	; 0x40
	LPC_SYSCTL->SYSPLLCLKUEN  = 0;
 8c4:	2200      	movs	r2, #0
 8c6:	645a      	str	r2, [r3, #68]	; 0x44
	LPC_SYSCTL->SYSPLLCLKUEN  = 1;
 8c8:	2201      	movs	r2, #1
 8ca:	645a      	str	r2, [r3, #68]	; 0x44
}
 8cc:	4770      	bx	lr
 8ce:	46c0      	nop			; (mov r8, r8)
 8d0:	40048000 	.word	0x40048000

000008d4 <Chip_Clock_SetMainClockSource>:
}

/* Set main system clock source */
void Chip_Clock_SetMainClockSource(CHIP_SYSCTL_MAINCLKSRC_T src)
{
	LPC_SYSCTL->MAINCLKSEL  = (uint32_t) src;
 8d4:	4b03      	ldr	r3, [pc, #12]	; (8e4 <Chip_Clock_SetMainClockSource+0x10>)
 8d6:	6718      	str	r0, [r3, #112]	; 0x70
	LPC_SYSCTL->MAINCLKUEN  = 0;
 8d8:	2200      	movs	r2, #0
 8da:	675a      	str	r2, [r3, #116]	; 0x74
	LPC_SYSCTL->MAINCLKUEN  = 1;
 8dc:	2201      	movs	r2, #1
 8de:	675a      	str	r2, [r3, #116]	; 0x74
}
 8e0:	4770      	bx	lr
 8e2:	46c0      	nop			; (mov r8, r8)
 8e4:	40048000 	.word	0x40048000

000008e8 <Chip_Clock_SetCLKOUTSource>:

/* Set CLKOUT clock source and divider */
void Chip_Clock_SetCLKOUTSource(CHIP_SYSCTL_CLKOUTSRC_T src, uint32_t div)
{
	LPC_SYSCTL->CLKOUTSEL = (uint32_t) src;
 8e8:	4b05      	ldr	r3, [pc, #20]	; (900 <Chip_Clock_SetCLKOUTSource+0x18>)
 8ea:	22e0      	movs	r2, #224	; 0xe0
 8ec:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 0;
 8ee:	22e4      	movs	r2, #228	; 0xe4
 8f0:	2000      	movs	r0, #0
 8f2:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTUEN = 1;
 8f4:	2001      	movs	r0, #1
 8f6:	5098      	str	r0, [r3, r2]
	LPC_SYSCTL->CLKOUTDIV = div;
 8f8:	22e8      	movs	r2, #232	; 0xe8
 8fa:	5099      	str	r1, [r3, r2]
}
 8fc:	4770      	bx	lr
 8fe:	46c0      	nop			; (mov r8, r8)
 900:	40048000 	.word	0x40048000

00000904 <Chip_Clock_GetWDTOSCRate>:

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
 904:	b508      	push	{r3, lr}
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 906:	4b02      	ldr	r3, [pc, #8]	; (910 <Chip_Clock_GetWDTOSCRate+0xc>)
 908:	6a58      	ldr	r0, [r3, #36]	; 0x24
 90a:	f7ff ffc3 	bl	894 <Chip_Clock_GetWDTLFORate>
}
 90e:	bd08      	pop	{r3, pc}
 910:	40048000 	.word	0x40048000

00000914 <Chip_Clock_GetSystemPLLInClockRate>:
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 914:	4b09      	ldr	r3, [pc, #36]	; (93c <Chip_Clock_GetSystemPLLInClockRate+0x28>)
 916:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 918:	2303      	movs	r3, #3
 91a:	4013      	ands	r3, r2
 91c:	2b01      	cmp	r3, #1
 91e:	d005      	beq.n	92c <Chip_Clock_GetSystemPLLInClockRate+0x18>
 920:	2b03      	cmp	r3, #3
 922:	d006      	beq.n	932 <Chip_Clock_GetSystemPLLInClockRate+0x1e>
 924:	2b00      	cmp	r3, #0
 926:	d107      	bne.n	938 <Chip_Clock_GetSystemPLLInClockRate+0x24>
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 928:	4805      	ldr	r0, [pc, #20]	; (940 <Chip_Clock_GetSystemPLLInClockRate+0x2c>)
 92a:	e006      	b.n	93a <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 92c:	4b05      	ldr	r3, [pc, #20]	; (944 <Chip_Clock_GetSystemPLLInClockRate+0x30>)
 92e:	6818      	ldr	r0, [r3, #0]
		break;

	case SYSCTL_PLLCLKSRC_SYSOSC:
		clkRate = Chip_Clock_GetMainOscRate();
		break;
 930:	e003      	b.n	93a <Chip_Clock_GetSystemPLLInClockRate+0x26>
 * @brief	Returns the external clock input rate
 * @return	External clock input rate
 */
STATIC INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
{
	return ExtRateIn;
 932:	4b05      	ldr	r3, [pc, #20]	; (948 <Chip_Clock_GetSystemPLLInClockRate+0x34>)
 934:	6818      	ldr	r0, [r3, #0]

	case SYSCTL_PLLCLKSRC_EXT_CLKIN:
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
 936:	e000      	b.n	93a <Chip_Clock_GetSystemPLLInClockRate+0x26>

	default:
		clkRate = 0;
 938:	2000      	movs	r0, #0
		break;
	}

	return clkRate;
}
 93a:	4770      	bx	lr
 93c:	40048000 	.word	0x40048000
 940:	00b71b00 	.word	0x00b71b00
 944:	00000be4 	.word	0x00000be4
 948:	00000be8 	.word	0x00000be8

0000094c <Chip_Clock_GetSystemPLLOutClockRate>:

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
 94c:	b510      	push	{r4, lr}
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 94e:	4b04      	ldr	r3, [pc, #16]	; (960 <Chip_Clock_GetSystemPLLOutClockRate+0x14>)
 950:	689c      	ldr	r4, [r3, #8]
 952:	f7ff ffdf 	bl	914 <Chip_Clock_GetSystemPLLInClockRate>
 956:	1c01      	adds	r1, r0, #0
 958:	1c20      	adds	r0, r4, #0
 95a:	f7ff ffab 	bl	8b4 <Chip_Clock_GetPLLFreq>
								 Chip_Clock_GetSystemPLLInClockRate());
}
 95e:	bd10      	pop	{r4, pc}
 960:	40048000 	.word	0x40048000

00000964 <Chip_Clock_GetMainClockRate>:

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 964:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 966:	4b0d      	ldr	r3, [pc, #52]	; (99c <Chip_Clock_GetMainClockRate+0x38>)
 968:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 96a:	2303      	movs	r3, #3
 96c:	4013      	ands	r3, r2
 96e:	2b01      	cmp	r3, #1
 970:	d009      	beq.n	986 <Chip_Clock_GetMainClockRate+0x22>
 972:	dc02      	bgt.n	97a <Chip_Clock_GetMainClockRate+0x16>
 974:	2b00      	cmp	r3, #0
 976:	d00f      	beq.n	998 <Chip_Clock_GetMainClockRate+0x34>
 978:	e003      	b.n	982 <Chip_Clock_GetMainClockRate+0x1e>
 97a:	2b02      	cmp	r3, #2
 97c:	d006      	beq.n	98c <Chip_Clock_GetMainClockRate+0x28>
 97e:	2b03      	cmp	r3, #3
 980:	d007      	beq.n	992 <Chip_Clock_GetMainClockRate+0x2e>
}

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;
 982:	2000      	movs	r0, #0
 984:	e009      	b.n	99a <Chip_Clock_GetMainClockRate+0x36>
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
		break;

	case SYSCTL_MAINCLKSRC_PLLIN:
		clkRate = Chip_Clock_GetSystemPLLInClockRate();
 986:	f7ff ffc5 	bl	914 <Chip_Clock_GetSystemPLLInClockRate>
		break;
 98a:	e006      	b.n	99a <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
 98c:	f7ff ffba 	bl	904 <Chip_Clock_GetWDTOSCRate>
		break;
 990:	e003      	b.n	99a <Chip_Clock_GetMainClockRate+0x36>

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 992:	f7ff ffdb 	bl	94c <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 996:	e000      	b.n	99a <Chip_Clock_GetMainClockRate+0x36>
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
	case SYSCTL_MAINCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 998:	4801      	ldr	r0, [pc, #4]	; (9a0 <Chip_Clock_GetMainClockRate+0x3c>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 99a:	bd08      	pop	{r3, pc}
 99c:	40048000 	.word	0x40048000
 9a0:	00b71b00 	.word	0x00b71b00

000009a4 <Chip_Clock_GetSystemClockRate>:

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 9a4:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 9a6:	f7ff ffdd 	bl	964 <Chip_Clock_GetMainClockRate>
 9aa:	4b02      	ldr	r3, [pc, #8]	; (9b4 <Chip_Clock_GetSystemClockRate+0x10>)
 9ac:	6f99      	ldr	r1, [r3, #120]	; 0x78
 9ae:	f000 f8c8 	bl	b42 <__aeabi_uidiv>
}
 9b2:	bd08      	pop	{r3, pc}
 9b4:	40048000 	.word	0x40048000

000009b8 <Chip_I2C_Init>:
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 9b8:	4b06      	ldr	r3, [pc, #24]	; (9d4 <Chip_I2C_Init+0x1c>)
 9ba:	2280      	movs	r2, #128	; 0x80
 9bc:	5898      	ldr	r0, [r3, r2]
 9be:	2120      	movs	r1, #32
 9c0:	4301      	orrs	r1, r0
 9c2:	5099      	str	r1, [r3, r2]
 * @note	The peripheral will stay in reset until reset is de-asserted. Call
 * Chip_SYSCTL_DeassertPeriphReset() to de-assert the reset
 */
STATIC INLINE void Chip_SYSCTL_AssertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL &= ~(1 << (uint32_t) periph);
 9c4:	6859      	ldr	r1, [r3, #4]
 9c6:	2240      	movs	r2, #64	; 0x40
 9c8:	4391      	bics	r1, r2
 9ca:	6059      	str	r1, [r3, #4]
 * @param	periph	: Peripheral to de-assert reset for
 * @return	Nothing
 */
STATIC INLINE void Chip_SYSCTL_DeassertPeriphReset(CHIP_SYSCTL_PERIPH_RESET_T periph)
{
	LPC_SYSCTL->PRESETCTRL |= (1 << (uint32_t) periph);
 9cc:	6859      	ldr	r1, [r3, #4]
 9ce:	430a      	orrs	r2, r1
 9d0:	605a      	str	r2, [r3, #4]
{
	/* Enable I2C clock */
	Chip_Clock_EnablePeriphClock(SYSCTL_CLOCK_I2C);
	/* Peripheral reset control to I2C */
	Chip_SYSCTL_PeriphReset(RESET_I2C);
}
 9d2:	4770      	bx	lr
 9d4:	40048000 	.word	0x40048000

000009d8 <Chip_IOCON_PinSetI2CMode>:
	pIOCON->PIO0[pin] = reg | (clkdiv << PIN_CLKDIV_BITNUM);
}

/* Set the I2C mode for a pin. */
void Chip_IOCON_PinSetI2CMode(LPC_IOCON_T *pIOCON, CHIP_PINx_T pin, CHIP_PIN_I2CMODE_T mode)
{
 9d8:	b510      	push	{r4, lr}
	uint32_t reg;

	/* I2C mode bits only for I2C pins */
	reg = pIOCON->PIO0[pin] & ~(PIN_I2CMODE_MASK);
 9da:	0089      	lsls	r1, r1, #2
 9dc:	580c      	ldr	r4, [r1, r0]
 9de:	4b03      	ldr	r3, [pc, #12]	; (9ec <Chip_IOCON_PinSetI2CMode+0x14>)
 9e0:	4023      	ands	r3, r4
	pIOCON->PIO0[pin] = reg | (mode << PIN_I2CMODE_BITNUM);
 9e2:	0212      	lsls	r2, r2, #8
 9e4:	431a      	orrs	r2, r3
 9e6:	500a      	str	r2, [r1, r0]
}
 9e8:	bd10      	pop	{r4, pc}
 9ea:	46c0      	nop			; (mov r8, r8)
 9ec:	fffffcff 	.word	0xfffffcff

000009f0 <RingBuffer_Init>:
 ****************************************************************************/

/* Initialize ring buffer */
int RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count)
{
	RingBuff->data = buffer;
 9f0:	6001      	str	r1, [r0, #0]
	RingBuff->count = count;
 9f2:	6043      	str	r3, [r0, #4]
	RingBuff->itemSz = itemSize;
 9f4:	6082      	str	r2, [r0, #8]
	RingBuff->head = RingBuff->tail = 0;
 9f6:	2300      	movs	r3, #0
 9f8:	6103      	str	r3, [r0, #16]
 9fa:	60c3      	str	r3, [r0, #12]

	return 1;
}
 9fc:	2001      	movs	r0, #1
 9fe:	4770      	bx	lr

00000a00 <RingBuffer_Insert>:

/* Insert a single item into Ring Buffer */
int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
{
 a00:	b538      	push	{r3, r4, r5, lr}
 a02:	1c04      	adds	r4, r0, #0
	uint8_t *ptr = RingBuff->data;
 a04:	6805      	ldr	r5, [r0, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	Number of items in the ring buffer
 */
STATIC INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
 a06:	68c2      	ldr	r2, [r0, #12]
 a08:	6903      	ldr	r3, [r0, #16]
 a0a:	1ad2      	subs	r2, r2, r3
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is full, otherwise 0
 */
STATIC INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
{
	return (RingBuffer_GetCount(RingBuff) >= RingBuff->count);
 a0c:	6843      	ldr	r3, [r0, #4]

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
 a0e:	429a      	cmp	r2, r3
 a10:	da0d      	bge.n	a2e <RingBuffer_Insert+0x2e>
		return 0;

	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
 a12:	3b01      	subs	r3, #1
 a14:	68c2      	ldr	r2, [r0, #12]
 a16:	4013      	ands	r3, r2
 a18:	6882      	ldr	r2, [r0, #8]
 a1a:	1c10      	adds	r0, r2, #0
 a1c:	4358      	muls	r0, r3
 a1e:	1828      	adds	r0, r5, r0
	memcpy(ptr, data, RingBuff->itemSz);
 a20:	f000 f884 	bl	b2c <memcpy>
	RingBuff->head++;
 a24:	68e3      	ldr	r3, [r4, #12]
 a26:	3301      	adds	r3, #1
 a28:	60e3      	str	r3, [r4, #12]

	return 1;
 a2a:	2001      	movs	r0, #1
 a2c:	e000      	b.n	a30 <RingBuffer_Insert+0x30>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot insert when queue is full */
	if (RingBuffer_IsFull(RingBuff))
		return 0;
 a2e:	2000      	movs	r0, #0
	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
	memcpy(ptr, data, RingBuff->itemSz);
	RingBuff->head++;

	return 1;
}
 a30:	bd38      	pop	{r3, r4, r5, pc}
 a32:	46c0      	nop			; (mov r8, r8)

00000a34 <RingBuffer_Pop>:
	return cnt1 + cnt2;
}

/* Pop single item from Ring Buffer */
int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data)
{
 a34:	b510      	push	{r4, lr}
 a36:	1c04      	adds	r4, r0, #0
 a38:	1c08      	adds	r0, r1, #0
	uint8_t *ptr = RingBuff->data;
 a3a:	6821      	ldr	r1, [r4, #0]
 * @param	RingBuff	: Pointer to ring buffer
 * @return	1 if the ring buffer is empty, otherwise 0
 */
STATIC INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
{
	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
 a3c:	68e2      	ldr	r2, [r4, #12]
 a3e:	6923      	ldr	r3, [r4, #16]

	/* We cannot pop when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
 a40:	429a      	cmp	r2, r3
 a42:	d00d      	beq.n	a60 <RingBuffer_Pop+0x2c>
		return 0;

	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
 a44:	6863      	ldr	r3, [r4, #4]
 a46:	3b01      	subs	r3, #1
 a48:	6922      	ldr	r2, [r4, #16]
 a4a:	4013      	ands	r3, r2
 a4c:	68a2      	ldr	r2, [r4, #8]
 a4e:	4353      	muls	r3, r2
 a50:	18c9      	adds	r1, r1, r3
	memcpy(data, ptr, RingBuff->itemSz);
 a52:	f000 f86b 	bl	b2c <memcpy>
	RingBuff->tail++;
 a56:	6923      	ldr	r3, [r4, #16]
 a58:	3301      	adds	r3, #1
 a5a:	6123      	str	r3, [r4, #16]

	return 1;
 a5c:	2001      	movs	r0, #1
 a5e:	e000      	b.n	a62 <RingBuffer_Pop+0x2e>
{
	uint8_t *ptr = RingBuff->data;

	/* We cannot pop when queue is empty */
	if (RingBuffer_IsEmpty(RingBuff))
		return 0;
 a60:	2000      	movs	r0, #0
	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
	memcpy(data, ptr, RingBuff->itemSz);
	RingBuff->tail++;

	return 1;
}
 a62:	bd10      	pop	{r4, pc}

00000a64 <Chip_SPI_CalClkRateDivider>:
 * Public functions
 ****************************************************************************/

/* Calculate the Clock Rate Divider for SPI Peripheral */
uint32_t Chip_SPI_CalClkRateDivider(LPC_SPI_T *pSPI, uint32_t bitRate)
{
 a64:	b510      	push	{r4, lr}
 a66:	1c0c      	adds	r4, r1, #0
	uint32_t SPIClk;
	uint32_t DivVal = 1;

	/* Get SPI clock rate */
	SPIClk = Chip_Clock_GetSystemClockRate();	/*The peripheral clock for both SPIs is the system clock*/
 a68:	f7ff ff9c 	bl	9a4 <Chip_Clock_GetSystemClockRate>

	DivVal = SPIClk / bitRate;
 a6c:	1c21      	adds	r1, r4, #0
 a6e:	f000 f868 	bl	b42 <__aeabi_uidiv>

	return DivVal;
}
 a72:	bd10      	pop	{r4, pc}

00000a74 <Chip_SPI_Int_Cmd>:
}

/* Disable/Enable Interrupt */
void Chip_SPI_Int_Cmd(LPC_SPI_T *pSPI, uint32_t IntMask, FunctionalState NewState)
{
	if (NewState ==  ENABLE) {
 a74:	2a01      	cmp	r2, #1
 a76:	d103      	bne.n	a80 <Chip_SPI_Int_Cmd+0xc>
		pSPI->INTENSET |= IntMask;
 a78:	68c3      	ldr	r3, [r0, #12]
 a7a:	4319      	orrs	r1, r3
 a7c:	60c1      	str	r1, [r0, #12]
 a7e:	e002      	b.n	a86 <Chip_SPI_Int_Cmd+0x12>
	}
	else {
		pSPI->INTENCLR |= IntMask;
 a80:	6903      	ldr	r3, [r0, #16]
 a82:	4319      	orrs	r1, r3
 a84:	6101      	str	r1, [r0, #16]
	}
}
 a86:	4770      	bx	lr

00000a88 <Chip_SYSCTL_PowerDown>:
void Chip_SYSCTL_PowerDown(uint32_t powerdownmask)
{
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 a88:	4a05      	ldr	r2, [pc, #20]	; (aa0 <Chip_SYSCTL_PowerDown+0x18>)
 a8a:	238e      	movs	r3, #142	; 0x8e
 a8c:	009b      	lsls	r3, r3, #2
 a8e:	58d1      	ldr	r1, [r2, r3]

	/* Disable peripheral states by setting high */
	pdrun |= (powerdownmask & PDWAKEUPDATMASK);
 a90:	4308      	orrs	r0, r1
 a92:	4904      	ldr	r1, [pc, #16]	; (aa4 <Chip_SYSCTL_PowerDown+0x1c>)
 a94:	4008      	ands	r0, r1

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 a96:	4904      	ldr	r1, [pc, #16]	; (aa8 <Chip_SYSCTL_PowerDown+0x20>)
 a98:	4308      	orrs	r0, r1
 a9a:	50d0      	str	r0, [r2, r3]
}
 a9c:	4770      	bx	lr
 a9e:	46c0      	nop			; (mov r8, r8)
 aa0:	40048000 	.word	0x40048000
 aa4:	000080ef 	.word	0x000080ef
 aa8:	00006d10 	.word	0x00006d10

00000aac <Chip_SYSCTL_PowerUp>:

/* Power up one or more blocks or peripherals */
void Chip_SYSCTL_PowerUp(uint32_t powerupmask)
{
 aac:	b510      	push	{r4, lr}
	uint32_t pdrun;

	/* Get current power states */
	pdrun = LPC_SYSCTL->PDRUNCFG & PDWAKEUPDATMASK;
 aae:	4a06      	ldr	r2, [pc, #24]	; (ac8 <Chip_SYSCTL_PowerUp+0x1c>)
 ab0:	238e      	movs	r3, #142	; 0x8e
 ab2:	009b      	lsls	r3, r3, #2
 ab4:	58d4      	ldr	r4, [r2, r3]
 ab6:	4905      	ldr	r1, [pc, #20]	; (acc <Chip_SYSCTL_PowerUp+0x20>)
 ab8:	400c      	ands	r4, r1

	/* Enable peripheral states by setting low */
	pdrun &= ~(powerupmask & PDWAKEUPDATMASK);
 aba:	4001      	ands	r1, r0
 abc:	438c      	bics	r4, r1
 abe:	1c21      	adds	r1, r4, #0

	/* Update power states with required register bits */
	LPC_SYSCTL->PDRUNCFG = (PDWAKEUPWRMASK | pdrun);
 ac0:	4803      	ldr	r0, [pc, #12]	; (ad0 <Chip_SYSCTL_PowerUp+0x24>)
 ac2:	4301      	orrs	r1, r0
 ac4:	50d1      	str	r1, [r2, r3]
}
 ac6:	bd10      	pop	{r4, pc}
 ac8:	40048000 	.word	0x40048000
 acc:	000080ef 	.word	0x000080ef
 ad0:	00006d10 	.word	0x00006d10

00000ad4 <Chip_SystemInit>:
 * Public functions
 ****************************************************************************/

/* Set up and initialize hardware prior to call to main */
void Chip_SystemInit(void)
{
 ad4:	b508      	push	{r3, lr}
#if defined (USE_ROM_API)
	uint32_t cmd[4], resp[2];
#endif

	/* Turn on the IRC by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_IRC_PD);
 ad6:	2002      	movs	r0, #2
 ad8:	f7ff ffe8 	bl	aac <Chip_SYSCTL_PowerUp>

	/* Select the PLL input in the IRC */
	Chip_Clock_SetSystemPLLSource(SYSCTL_PLLCLKSRC_IRC);
 adc:	2000      	movs	r0, #0
 ade:	f7ff feef 	bl	8c0 <Chip_Clock_SetSystemPLLSource>
 * @note	For CPU speed up to 20MHz, use a value of 0. For up to 30MHz, use
 *			a value of 1
 */
STATIC INLINE void Chip_FMC_SetFLASHAccess(FMC_FLASHTIM_T clks)
{
	uint32_t tmp = LPC_FMC->FLASHCFG & (~(0x3));
 ae2:	4b10      	ldr	r3, [pc, #64]	; (b24 <Chip_SystemInit+0x50>)
 ae4:	691a      	ldr	r2, [r3, #16]
 ae6:	2103      	movs	r1, #3
 ae8:	438a      	bics	r2, r1

	/* Don't alter upper bits */
	LPC_FMC->FLASHCFG = tmp | clks;
 aea:	2101      	movs	r1, #1
 aec:	430a      	orrs	r2, r1
 aee:	611a      	str	r2, [r3, #16]
	/* Dead loop on fail */
	while (resp[0] != PLL_CMD_SUCCESS) {}

#else
	/* Power down PLL to change the PLL divider ratio */
	Chip_SYSCTL_PowerDown(SYSCTL_SLPWAKE_SYSPLL_PD);
 af0:	2080      	movs	r0, #128	; 0x80
 af2:	f7ff ffc9 	bl	a88 <Chip_SYSCTL_PowerDown>
 * @return	Nothing
 * @note	See the user manual for how to setup the PLL
 */
STATIC INLINE void Chip_Clock_SetupSystemPLL(uint8_t msel, uint8_t psel)
{
	LPC_SYSCTL->SYSPLLCTRL = (msel & 0x1F) | ((psel & 0x3) << 5);
 af6:	2241      	movs	r2, #65	; 0x41
 af8:	4b0b      	ldr	r3, [pc, #44]	; (b28 <Chip_SystemInit+0x54>)
 afa:	609a      	str	r2, [r3, #8]
	   FCLKOUT = FCLKIN * (MSEL + 1) = 12MHz * 2 = 24MHz
	   FCCO = FCLKOUT * 2 * P = 24MHz * 2 * 4 = 192MHz (within FCCO range) */
	Chip_Clock_SetupSystemPLL(1, 2);

	/* Turn on the PLL by clearing the power down bit */
	Chip_SYSCTL_PowerUp(SYSCTL_SLPWAKE_SYSPLL_PD);
 afc:	2080      	movs	r0, #128	; 0x80
 afe:	f7ff ffd5 	bl	aac <Chip_SYSCTL_PowerUp>
 * @brief	Read System PLL status
 * @return	true if the PLL is locked, false if not locked
 */
STATIC INLINE bool Chip_Clock_IsSystemPLLLocked(void)
{
	return (bool) ((LPC_SYSCTL->SYSPLLSTAT & 1) != 0);
 b02:	4909      	ldr	r1, [pc, #36]	; (b28 <Chip_SystemInit+0x54>)
 b04:	2201      	movs	r2, #1
 b06:	68cb      	ldr	r3, [r1, #12]

	/* Wait for PLL to lock */
	while (!Chip_Clock_IsSystemPLLLocked()) {}
 b08:	421a      	tst	r2, r3
 b0a:	d0fc      	beq.n	b06 <Chip_SystemInit+0x32>
 * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
{
	LPC_SYSCTL->SYSAHBCLKDIV  = div;
 b0c:	2201      	movs	r2, #1
 b0e:	4b06      	ldr	r3, [pc, #24]	; (b28 <Chip_SystemInit+0x54>)
 b10:	679a      	str	r2, [r3, #120]	; 0x78
	/* Set system clock divider to 1 */
	Chip_Clock_SetSysClockDiv(1);

	/* Set main clock source to the system PLL. This will drive 24MHz
	   for the main clock and 24MHz for the system clock */
	Chip_Clock_SetMainClockSource(SYSCTL_MAINCLKSRC_PLLOUT);
 b12:	2003      	movs	r0, #3
 b14:	f7ff fede 	bl	8d4 <Chip_Clock_SetMainClockSource>
#endif

	/* Select the CLKOUT clocking source */
	Chip_Clock_SetCLKOUTSource(SYSCTL_CLKOUTSRC_MAINSYSCLK, 1);
 b18:	2003      	movs	r0, #3
 b1a:	2101      	movs	r1, #1
 b1c:	f7ff fee4 	bl	8e8 <Chip_Clock_SetCLKOUTSource>
}
 b20:	bd08      	pop	{r3, pc}
 b22:	46c0      	nop			; (mov r8, r8)
 b24:	40040000 	.word	0x40040000
 b28:	40048000 	.word	0x40048000

00000b2c <memcpy>:
 b2c:	b508      	push	{r3, lr}
 b2e:	f000 f842 	bl	bb6 <__aeabi_memcpy>
 b32:	bd08      	pop	{r3, pc}

00000b34 <__weak_main>:
 b34:	b508      	push	{r3, lr}
 b36:	f7ff fbe3 	bl	300 <main>
 b3a:	bd08      	pop	{r3, pc}

00000b3c <__aeabi_idiv>:
 b3c:	0003      	movs	r3, r0
 b3e:	430b      	orrs	r3, r1
 b40:	d421      	bmi.n	b86 <idiv_negative>

00000b42 <__aeabi_uidiv>:
 b42:	2900      	cmp	r1, #0
 b44:	d031      	beq.n	baa <idiv_divzero>
 b46:	2201      	movs	r2, #1
 b48:	07d2      	lsls	r2, r2, #31
 b4a:	0903      	lsrs	r3, r0, #4
 b4c:	e001      	b.n	b52 <div_search4a>

00000b4e <div_search4>:
 b4e:	0109      	lsls	r1, r1, #4
 b50:	0912      	lsrs	r2, r2, #4

00000b52 <div_search4a>:
 b52:	4299      	cmp	r1, r3
 b54:	d9fb      	bls.n	b4e <div_search4>
 b56:	0843      	lsrs	r3, r0, #1
 b58:	e001      	b.n	b5e <div_search1a>

00000b5a <div_search1>:
 b5a:	0049      	lsls	r1, r1, #1
 b5c:	0852      	lsrs	r2, r2, #1

00000b5e <div_search1a>:
 b5e:	4299      	cmp	r1, r3
 b60:	d9fb      	bls.n	b5a <div_search1>
 b62:	e000      	b.n	b66 <div_loop1a>

00000b64 <div_loop1>:
 b64:	0849      	lsrs	r1, r1, #1

00000b66 <div_loop1a>:
 b66:	1a40      	subs	r0, r0, r1
 b68:	d307      	bcc.n	b7a <div1>

00000b6a <div2>:
 b6a:	4152      	adcs	r2, r2
 b6c:	d3fa      	bcc.n	b64 <div_loop1>
 b6e:	4601      	mov	r1, r0
 b70:	4610      	mov	r0, r2
 b72:	4770      	bx	lr

00000b74 <div_loop2>:
 b74:	0849      	lsrs	r1, r1, #1
 b76:	1840      	adds	r0, r0, r1
 b78:	d2f7      	bcs.n	b6a <div2>

00000b7a <div1>:
 b7a:	1892      	adds	r2, r2, r2
 b7c:	d3fa      	bcc.n	b74 <div_loop2>
 b7e:	1840      	adds	r0, r0, r1
 b80:	4601      	mov	r1, r0
 b82:	4610      	mov	r0, r2
 b84:	4770      	bx	lr

00000b86 <idiv_negative>:
 b86:	0fcb      	lsrs	r3, r1, #31
 b88:	d000      	beq.n	b8c <idiv_neg1>
 b8a:	4249      	negs	r1, r1

00000b8c <idiv_neg1>:
 b8c:	1002      	asrs	r2, r0, #32
 b8e:	d500      	bpl.n	b92 <idiv_neg2>
 b90:	4240      	negs	r0, r0

00000b92 <idiv_neg2>:
 b92:	4053      	eors	r3, r2
 b94:	b508      	push	{r3, lr}
 b96:	f7ff ffd4 	bl	b42 <__aeabi_uidiv>
 b9a:	bc0c      	pop	{r2, r3}

00000b9c <idiv_sign>:
 b9c:	1052      	asrs	r2, r2, #1
 b9e:	d300      	bcc.n	ba2 <idiv_sign1>
 ba0:	4240      	negs	r0, r0

00000ba2 <idiv_sign1>:
 ba2:	2a00      	cmp	r2, #0
 ba4:	d500      	bpl.n	ba8 <idiv_ret>
 ba6:	4249      	negs	r1, r1

00000ba8 <idiv_ret>:
 ba8:	4718      	bx	r3

00000baa <idiv_divzero>:
 baa:	46f4      	mov	ip, lr
 bac:	2000      	movs	r0, #0
 bae:	f000 f801 	bl	bb4 <__aeabi_idiv0>
 bb2:	4760      	bx	ip

00000bb4 <__aeabi_idiv0>:
 bb4:	4770      	bx	lr

00000bb6 <__aeabi_memcpy>:
 bb6:	4684      	mov	ip, r0
 bb8:	0783      	lsls	r3, r0, #30
 bba:	d108      	bne.n	bce <copy1_start>
 bbc:	078b      	lsls	r3, r1, #30
 bbe:	d106      	bne.n	bce <copy1_start>
 bc0:	1f13      	subs	r3, r2, #4
 bc2:	d304      	bcc.n	bce <copy1_start>

00000bc4 <copy4>:
 bc4:	c904      	ldmia	r1!, {r2}
 bc6:	c004      	stmia	r0!, {r2}
 bc8:	3b04      	subs	r3, #4
 bca:	d2fb      	bcs.n	bc4 <copy4>
 bcc:	1d1a      	adds	r2, r3, #4

00000bce <copy1_start>:
 bce:	4252      	negs	r2, r2
 bd0:	d005      	beq.n	bde <copy1_ret>
 bd2:	1a89      	subs	r1, r1, r2
 bd4:	1a80      	subs	r0, r0, r2

00000bd6 <copy1>:
 bd6:	5c8b      	ldrb	r3, [r1, r2]
 bd8:	5483      	strb	r3, [r0, r2]
 bda:	3201      	adds	r2, #1
 bdc:	d1fb      	bne.n	bd6 <copy1>

00000bde <copy1_ret>:
 bde:	4660      	mov	r0, ip
 be0:	4770      	bx	lr
	...

00000be4 <OscRateIn>:
 be4:	1b00 00b7                                   ....

00000be8 <ExtRateIn>:
 be8:	0000 0000                                   ....

00000bec <wdtOSCRate>:
 bec:	0000 0000 27c0 0009 0590 0010 5cc0 0015     .....'.......\..
 bfc:	b3f0 001a 0b20 0020 9f00 0024 32e0 0029     .... . ...$..2).
 c0c:	c6c0 002d 9750 0031 67e0 0035 3870 0039     ..-.P.1..g5.p89.
 c1c:	0900 003d 1640 0040 2380 0043 30c0 0046     ..=.@.@..#C..0F.
