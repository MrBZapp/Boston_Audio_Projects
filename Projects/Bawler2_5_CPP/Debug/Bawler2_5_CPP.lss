
Bawler2_5_CPP.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000058  00800060  000008e4  00000978  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001e  008000b8  008000b8  000009d0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000009d0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000498  00000000  00000000  00000a00  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00009a08  00000000  00000000  00000e98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000291e  00000000  00000000  0000a8a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002e4c  00000000  00000000  0000d1be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000b98  00000000  00000000  0001000c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00009d4d  00000000  00000000  00010ba4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003276  00000000  00000000  0001a8f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000640  00000000  00000000  0001db67  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000035da  00000000  00000000  0001e1a7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:


#include "Button.h"

// default constructor
Button::Button( SFRaddress port, unsigned char pin, PeripheralHandler* pPeripheralHandler )
   0:	16 c0       	rjmp	.+44     	; 0x2e <__dtors_end>
{
	m_pPeripheralHandler = pPeripheralHandler;
   2:	3a c0       	rjmp	.+116    	; 0x78 <__bad_interrupt>
   4:	39 c0       	rjmp	.+114    	; 0x78 <__bad_interrupt>
	io_Port = port;
   6:	38 c0       	rjmp	.+112    	; 0x78 <__bad_interrupt>
   8:	37 c0       	rjmp	.+110    	; 0x78 <__bad_interrupt>
	io_Pin = pin;
   a:	36 c0       	rjmp	.+108    	; 0x78 <__bad_interrupt>
   c:	f7 c2       	rjmp	.+1518   	; 0x5fc <__vector_6>


#include "FlagHandler.h"

// default constructor
FlagHandler::FlagHandler( SFRaddress gpio_address )
   e:	34 c0       	rjmp	.+104    	; 0x78 <__bad_interrupt>
  10:	33 c0       	rjmp	.+102    	; 0x78 <__bad_interrupt>

template <class T>	
class Buffer{
	public:
		Buffer( unsigned char specSize )
			: m_buffer (new TemplateBuffer<T>)
  12:	32 c0       	rjmp	.+100    	; 0x78 <__bad_interrupt>
  14:	31 c0       	rjmp	.+98     	; 0x78 <__bad_interrupt>
  16:	30 c0       	rjmp	.+96     	; 0x78 <__bad_interrupt>
  18:	2f c0       	rjmp	.+94     	; 0x78 <__bad_interrupt>
  1a:	2e c0       	rjmp	.+92     	; 0x78 <__bad_interrupt>
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
  1c:	2d c0       	rjmp	.+90     	; 0x78 <__bad_interrupt>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
  1e:	2c c0       	rjmp	.+88     	; 0x78 <__bad_interrupt>
				m_buffer->data = new T[specSize]; // create the internal array
  20:	2b c0       	rjmp	.+86     	; 0x78 <__bad_interrupt>
  22:	2a c0       	rjmp	.+84     	; 0x78 <__bad_interrupt>
  24:	29 c0       	rjmp	.+82     	; 0x78 <__bad_interrupt>
  26:	28 c0       	rjmp	.+80     	; 0x78 <__bad_interrupt>
  28:	27 c0       	rjmp	.+78     	; 0x78 <__bad_interrupt>

0000002a <__ctors_start>:
  2a:	d7 00       	.word	0x00d7	; ????

0000002c <__ctors_end>:
  2c:	e1 00       	.word	0x00e1	; ????

0000002e <__dtors_end>:
  2e:	11 24       	eor	r1, r1
				m_buffer->size = specSize; // set the size of the buffer to the specified
  30:	1f be       	out	0x3f, r1	; 63
  32:	cf e5       	ldi	r28, 0x5F	; 95
  34:	d1 e0       	ldi	r29, 0x01	; 1
  36:	de bf       	out	0x3e, r29	; 62
				m_buffer->length = 0;
  38:	cd bf       	out	0x3d, r28	; 61

0000003a <__do_copy_data>:
  3a:	10 e0       	ldi	r17, 0x00	; 0
  3c:	a0 e6       	ldi	r26, 0x60	; 96
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
  3e:	b0 e0       	ldi	r27, 0x00	; 0
:m_flagsInUse(8)
{
	unsigned char initializer = 0x00;
  40:	e4 ee       	ldi	r30, 0xE4	; 228
  42:	f8 e0       	ldi	r31, 0x08	; 8
	do{
		m_flagsInUse.AddToEnd( initializer );
		initializer++;
  44:	02 c0       	rjmp	.+4      	; 0x4a <__SREG__+0xb>
				}
			}
			return 0;
		};
		unsigned char SpaceRemaining(){// returns the size of the unused space in the buffer.  Can cast to bool to return false (0) when full.
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
  46:	05 90       	lpm	r0, Z+
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
  48:	0d 92       	st	X+, r0
				unsigned char bytesleft = m_buffer->size - m_buffer->length;
  4a:	a8 3b       	cpi	r26, 0xB8	; 184
  4c:	b1 07       	cpc	r27, r17
  4e:	d9 f7       	brne	.-10     	; 0x46 <__SREG__+0x7>

00000050 <__do_clear_bss>:
  50:	20 e0       	ldi	r18, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
  52:	a8 eb       	ldi	r26, 0xB8	; 184
// default constructor
FlagHandler::FlagHandler( SFRaddress gpio_address )
:m_flagsInUse(8)
{
	unsigned char initializer = 0x00;
	do{
  54:	b0 e0       	ldi	r27, 0x00	; 0
  56:	01 c0       	rjmp	.+2      	; 0x5a <.do_clear_bss_start>

00000058 <.do_clear_bss_loop>:
			}
		}; // create a buffer of "size" length

/////////Write Methods/////////
		bool AddToEnd( T newData ){
			if(m_buffer->length < m_buffer->size){ // make sure the buffer has room
  58:	1d 92       	st	X+, r1

0000005a <.do_clear_bss_start>:
  5a:	a6 3d       	cpi	r26, 0xD6	; 214
  5c:	b2 07       	cpc	r27, r18
  5e:	e1 f7       	brne	.-8      	; 0x58 <.do_clear_bss_loop>

00000060 <__do_global_ctors>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	cc e2       	ldi	r28, 0x2C	; 44
				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
  64:	d0 e0       	ldi	r29, 0x00	; 0
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
  66:	03 c0       	rjmp	.+6      	; 0x6e <__do_global_ctors+0xe>
					m_buffer->data[m_buffer->length % m_buffer->size] = newData; //Add the data to the address at which length points.
  68:	22 97       	sbiw	r28, 0x02	; 2
  6a:	fe 01       	movw	r30, r28
  6c:	04 d3       	rcall	.+1544   	; 0x676 <__tablejump__>
  6e:	ca 32       	cpi	r28, 0x2A	; 42
  70:	d1 07       	cpc	r29, r17
  72:	d1 f7       	brne	.-12     	; 0x68 <__do_global_ctors+0x8>
  74:	3f d0       	rcall	.+126    	; 0xf4 <main>
  76:	2a c4       	rjmp	.+2132   	; 0x8cc <__do_global_dtors>

00000078 <__bad_interrupt>:
  78:	c3 cf       	rjmp	.-122    	; 0x0 <__vectors>

0000007a <_ZN8CPPTimer5pauseEv>:
  7a:	fc 01       	movw	r30, r24
  7c:	84 81       	ldd	r24, Z+4	; 0x04
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
  7e:	95 81       	ldd	r25, Z+5	; 0x05
				}
				m_buffer->length++; // Update the length by one
  80:	08 95       	ret

00000082 <_ZN8CPPTimer5startEv>:
  82:	08 95       	ret

00000084 <_ZN8CPPTimer4stopEv>:
  84:	08 95       	ret

00000086 <_ZN8CPPTimer11setPrescaleE15prescaleSetting>:
  86:	fc 01       	movw	r30, r24
  88:	73 83       	std	Z+3, r23	; 0x03
  8a:	62 83       	std	Z+2, r22	; 0x02
		m_flagsInUse.AddToEnd( initializer );
		initializer++;
	} while (m_flagsInUse.SpaceRemaining());
	
	m_gpio_register = gpio_address; //set the FlagHandler to the I/O register
  8c:	08 95       	ret

0000008e <_ZN8CPPTimer11getPrescaleEv>:
  8e:	fc 01       	movw	r30, r24
	*m_gpio_register |= 0x00; //clear the I/O register to prepare for flag.
  90:	82 81       	ldd	r24, Z+2	; 0x02
  92:	93 81       	ldd	r25, Z+3	; 0x03
  94:	08 95       	ret

00000096 <_ZN8CPPTimer7getTimeEv>:
} //FlagHandler
  96:	fc 01       	movw	r30, r24
  98:	84 81       	ldd	r24, Z+4	; 0x04
  9a:	95 81       	ldd	r25, Z+5	; 0x05
  9c:	08 95       	ret

0000009e <_ZN8CPPTimer15getTime_NoClearEv>:
  9e:	fc 01       	movw	r30, r24
  a0:	84 81       	ldd	r24, Z+4	; 0x04
  a2:	95 81       	ldd	r25, Z+5	; 0x05
  a4:	08 95       	ret

000000a6 <_ZN8CPPTimer17getTime_NoUpdatesEv>:
			return m_Time;
		};
		
		virtual time getTime_NoUpdates(){
			return m_Time;
		};
  a6:	fc 01       	movw	r30, r24
  a8:	84 81       	ldd	r24, Z+4	; 0x04
  aa:	95 81       	ldd	r25, Z+5	; 0x05
  ac:	08 95       	ret

000000ae <_ZN8CPPTimerD1Ev>:
		
		void setOverageFunction( VoidFuncPtr func ){ 
			m_overageFunction = func;
		}
			
		virtual ~CPPTimer(){};
  ae:	28 e8       	ldi	r18, 0x88	; 136
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	fc 01       	movw	r30, r24
  b4:	31 83       	std	Z+1, r19	; 0x01
  b6:	20 83       	st	Z, r18
  b8:	08 95       	ret

000000ba <_ZN8CPPTimer10updateTimeEv>:
		prescaleSetting m_Prescale;
		time m_Time;
		time m_Timeout;
		VoidFuncPtr m_overageFunction;
		
		virtual void updateTime(){};
  ba:	08 95       	ret

000000bc <_Z9testFunc1v>:
#define  TAPS_REQUIRED 4 //Sequence starts at 1

bool debounce ( SFRaddress port, unsigned char pin );
unsigned int TapTempo();

void testFunc1(){ PORTD = 0x01;}
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	82 bb       	out	0x12, r24	; 18
  c0:	08 95       	ret

000000c2 <_Z9testFunc2v>:
void testFunc2(){ PORTD = 0x04;}
  c2:	84 e0       	ldi	r24, 0x04	; 4
  c4:	82 bb       	out	0x12, r24	; 18
  c6:	08 95       	ret

000000c8 <_Z9testFunc3v>:
void testFunc3(){ PORTD = 0x02;}
  c8:	82 e0       	ldi	r24, 0x02	; 2
  ca:	82 bb       	out	0x12, r24	; 18
  cc:	08 95       	ret

000000ce <_ZN8CPPTimerD0Ev>:
		
		void setOverageFunction( VoidFuncPtr func ){ 
			m_overageFunction = func;
		}
			
		virtual ~CPPTimer(){};
  ce:	28 e8       	ldi	r18, 0x88	; 136
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	fc 01       	movw	r30, r24
  d4:	31 83       	std	Z+1, r19	; 0x01
  d6:	20 83       	st	Z, r18
	return malloc(size);
}

void operator delete(void * ptr)
{
	free(ptr);
  d8:	6a c3       	rjmp	.+1748   	; 0x7ae <free>

000000da <_Z12SortOveragesv>:
	return 0;
}//End Tap Tempo

void SortOverages(){ 
	time newTime = { 0, 1 };
	EventSchedule.ProcessTime( newTime );
  da:	60 e0       	ldi	r22, 0x00	; 0
  dc:	71 e0       	ldi	r23, 0x01	; 1
  de:	88 eb       	ldi	r24, 0xB8	; 184
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	3e d1       	rcall	.+636    	; 0x360 <_ZN9Scheduler11ProcessTimeE4time>
  e4:	08 95       	ret

000000e6 <_Znwj>:
void * operator new(size_t size);
void operator delete(void * ptr);

void * operator new(size_t size)
{
	return malloc(size);
  e6:	cb c2       	rjmp	.+1430   	; 0x67e <malloc>

000000e8 <_ZdlPv>:
}

void operator delete(void * ptr)
{
	free(ptr);
  e8:	62 c3       	rjmp	.+1732   	; 0x7ae <free>

000000ea <_Znaj>:
}

void * operator new[](size_t size)
{
	return malloc(size);
  ea:	c9 c2       	rjmp	.+1426   	; 0x67e <malloc>

000000ec <_ZdaPv>:
}

void operator delete[](void * ptr)
{
	if (ptr)
  ec:	00 97       	sbiw	r24, 0x00	; 0
  ee:	09 f0       	breq	.+2      	; 0xf2 <_ZdaPv+0x6>
		free(ptr);
  f0:	5e c3       	rjmp	.+1724   	; 0x7ae <free>
  f2:	08 95       	ret

000000f4 <main>:
Scheduler EventSchedule( &CoreTimer );

//const CppDelegate::FastDelegate0<void> TestDelegate( &testFunc1 );
//const CBFunctor0 doofuss( makeFunctor( (CBFunctor0*)0,testFunc2 ) );

int main(void){
  f4:	cf 93       	push	r28
  f6:	df 93       	push	r29
  f8:	cd b7       	in	r28, 0x3d	; 61
  fa:	de b7       	in	r29, 0x3e	; 62
  fc:	6e 97       	sbiw	r28, 0x1e	; 30
  fe:	0f b6       	in	r0, 0x3f	; 63
 100:	f8 94       	cli
 102:	de bf       	out	0x3e, r29	; 62
 104:	0f be       	out	0x3f, r0	; 63
 106:	cd bf       	out	0x3d, r28	; 61
	wdt_disable();
 108:	88 e1       	ldi	r24, 0x18	; 24
 10a:	0f b6       	in	r0, 0x3f	; 63
 10c:	f8 94       	cli
 10e:	81 bd       	out	0x21, r24	; 33
 110:	11 bc       	out	0x21, r1	; 33
 112:	0f be       	out	0x3f, r0	; 63
	cli();
 114:	f8 94       	cli
		virtual time getTime_NoUpdates(){
			return m_Time;
		};
		
		void setOverageFunction( VoidFuncPtr func ){ 
			m_overageFunction = func;
 116:	8d e6       	ldi	r24, 0x6D	; 109
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	90 93 c7 00 	sts	0x00C7, r25
 11e:	80 93 c6 00 	sts	0x00C6, r24
	CoreTimer.setOverageFunction( &SortOverages );
	ScheduledEvent EventOne = { 0, 0x01, 0, 0, 255, 255, &testFunc1 };
 122:	8a e0       	ldi	r24, 0x0A	; 10
 124:	e6 e6       	ldi	r30, 0x66	; 102
 126:	f0 e0       	ldi	r31, 0x00	; 0
 128:	de 01       	movw	r26, r28
 12a:	55 96       	adiw	r26, 0x15	; 21
 12c:	01 90       	ld	r0, Z+
 12e:	0d 92       	st	X+, r0
 130:	8a 95       	dec	r24
 132:	e1 f7       	brne	.-8      	; 0x12c <main+0x38>
	ScheduledEvent EventTwo = { 0, 0x01, 0, 0, 254, 254, &testFunc2 };
 134:	8a e0       	ldi	r24, 0x0A	; 10
 136:	e0 e7       	ldi	r30, 0x70	; 112
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	de 01       	movw	r26, r28
 13c:	1b 96       	adiw	r26, 0x0b	; 11
 13e:	01 90       	ld	r0, Z+
 140:	0d 92       	st	X+, r0
 142:	8a 95       	dec	r24
 144:	e1 f7       	brne	.-8      	; 0x13e <main+0x4a>
	ScheduledEvent EventThree = { 0, 0xF0, 0, 0, 256, 256, &testFunc3 };
 146:	8a e0       	ldi	r24, 0x0A	; 10
 148:	ea e7       	ldi	r30, 0x7A	; 122
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	de 01       	movw	r26, r28
 14e:	11 96       	adiw	r26, 0x01	; 1
 150:	01 90       	ld	r0, Z+
 152:	0d 92       	st	X+, r0
 154:	8a 95       	dec	r24
 156:	e1 f7       	brne	.-8      	; 0x150 <main+0x5c>
	//CoreTimer.setOverageCallback(makeFunctor((CBFunctor0*)0, testFunc1));
	
	EventSchedule.ScheduleAnEvent(EventOne);
 158:	ed 88       	ldd	r14, Y+21	; 0x15
 15a:	fe 88       	ldd	r15, Y+22	; 0x16
 15c:	0f 89       	ldd	r16, Y+23	; 0x17
 15e:	18 8d       	ldd	r17, Y+24	; 0x18
 160:	29 8d       	ldd	r18, Y+25	; 0x19
 162:	3a 8d       	ldd	r19, Y+26	; 0x1a
 164:	4b 8d       	ldd	r20, Y+27	; 0x1b
 166:	5c 8d       	ldd	r21, Y+28	; 0x1c
 168:	6d 8d       	ldd	r22, Y+29	; 0x1d
 16a:	7e 8d       	ldd	r23, Y+30	; 0x1e
 16c:	88 eb       	ldi	r24, 0xB8	; 184
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	73 d0       	rcall	.+230    	; 0x258 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent>
	EventSchedule.ScheduleAnEvent(EventTwo);
 172:	eb 84       	ldd	r14, Y+11	; 0x0b
 174:	fc 84       	ldd	r15, Y+12	; 0x0c
 176:	0d 85       	ldd	r16, Y+13	; 0x0d
 178:	1e 85       	ldd	r17, Y+14	; 0x0e
 17a:	2f 85       	ldd	r18, Y+15	; 0x0f
 17c:	38 89       	ldd	r19, Y+16	; 0x10
 17e:	49 89       	ldd	r20, Y+17	; 0x11
 180:	5a 89       	ldd	r21, Y+18	; 0x12
 182:	6b 89       	ldd	r22, Y+19	; 0x13
 184:	7c 89       	ldd	r23, Y+20	; 0x14
 186:	88 eb       	ldi	r24, 0xB8	; 184
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	66 d0       	rcall	.+204    	; 0x258 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent>
	EventSchedule.ScheduleAnEvent(EventThree);
 18c:	e9 80       	ldd	r14, Y+1	; 0x01
 18e:	fa 80       	ldd	r15, Y+2	; 0x02
 190:	0b 81       	ldd	r16, Y+3	; 0x03
 192:	1c 81       	ldd	r17, Y+4	; 0x04
 194:	2d 81       	ldd	r18, Y+5	; 0x05
 196:	3e 81       	ldd	r19, Y+6	; 0x06
 198:	4f 81       	ldd	r20, Y+7	; 0x07
 19a:	58 85       	ldd	r21, Y+8	; 0x08
 19c:	69 85       	ldd	r22, Y+9	; 0x09
 19e:	7a 85       	ldd	r23, Y+10	; 0x0a
 1a0:	88 eb       	ldi	r24, 0xB8	; 184
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	59 d0       	rcall	.+178    	; 0x258 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent>
	PORTB ^= 0xFF;
 1a6:	88 b3       	in	r24, 0x18	; 24
 1a8:	80 95       	com	r24
 1aa:	88 bb       	out	0x18, r24	; 24
 1ac:	ff cf       	rjmp	.-2      	; 0x1ac <__stack+0x4d>

000001ae <_GLOBAL__sub_I__Znwj>:
void testFunc1(){ PORTD = 0x01;}
void testFunc2(){ PORTD = 0x04;}
void testFunc3(){ PORTD = 0x02;}
	
void SortOverages();
HardwareTimer_8Bit CoreTimer( TIMER_CLK_DIV8 );
 1ae:	68 e0       	ldi	r22, 0x08	; 8
 1b0:	70 e0       	ldi	r23, 0x00	; 0
 1b2:	8e eb       	ldi	r24, 0xBE	; 190
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	0d d2       	rcall	.+1050   	; 0x5d2 <_ZN18HardwareTimer_8BitC1E15prescaleSetting>
Scheduler EventSchedule( &CoreTimer );
 1b8:	6e eb       	ldi	r22, 0xBE	; 190
 1ba:	70 e0       	ldi	r23, 0x00	; 0
 1bc:	88 eb       	ldi	r24, 0xB8	; 184
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	0a c0       	rjmp	.+20     	; 0x1d6 <_ZN9SchedulerC1EP18HardwareTimer_8Bit>

000001c2 <_GLOBAL__sub_D__Znwj>:
 1c2:	88 eb       	ldi	r24, 0xB8	; 184
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	4d d1       	rcall	.+666    	; 0x462 <_ZN9SchedulerD1Ev>
		}
			
		virtual ~CPPTimer(){};
 1c8:	88 e8       	ldi	r24, 0x88	; 136
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	90 93 bf 00 	sts	0x00BF, r25
 1d0:	80 93 be 00 	sts	0x00BE, r24
 1d4:	08 95       	ret

000001d6 <_ZN9SchedulerC1EP18HardwareTimer_8Bit>:

#include "Scheduler.h"
#include "callback.h"

// default constructor
Scheduler::Scheduler( HardwareTimer_8Bit* htimer )
 1d6:	df 92       	push	r13
 1d8:	ef 92       	push	r14
 1da:	ff 92       	push	r15
 1dc:	0f 93       	push	r16
 1de:	1f 93       	push	r17
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
 1e4:	ec 01       	movw	r28, r24
 1e6:	7b 01       	movw	r14, r22

template <class T>	
class Buffer{
	public:
		Buffer( unsigned char specSize )
			: m_buffer (new TemplateBuffer<T>)
 1e8:	84 e0       	ldi	r24, 0x04	; 4
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	7c df       	rcall	.-264    	; 0xe6 <_Znwj>
 1ee:	99 83       	std	Y+1, r25	; 0x01
 1f0:	88 83       	st	Y, r24
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 1f2:	df b6       	in	r13, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 1f4:	f8 94       	cli
				m_buffer->data = new T[specSize]; // create the internal array
 1f6:	08 81       	ld	r16, Y
 1f8:	19 81       	ldd	r17, Y+1	; 0x01
 1fa:	82 e3       	ldi	r24, 0x32	; 50
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	75 df       	rcall	.-278    	; 0xea <_Znaj>
 200:	f8 01       	movw	r30, r16
 202:	91 83       	std	Z+1, r25	; 0x01
 204:	80 83       	st	Z, r24
				m_buffer->size = specSize; // set the size of the buffer to the specified
 206:	e8 81       	ld	r30, Y
 208:	f9 81       	ldd	r31, Y+1	; 0x01
 20a:	85 e0       	ldi	r24, 0x05	; 5
 20c:	82 83       	std	Z+2, r24	; 0x02
				m_buffer->length = 0;
 20e:	e8 81       	ld	r30, Y
 210:	f9 81       	ldd	r31, Y+1	; 0x01
 212:	13 82       	std	Z+3, r1	; 0x03
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 214:	df be       	out	0x3f, r13	; 63

template <class T>	
class Buffer{
	public:
		Buffer( unsigned char specSize )
			: m_buffer (new TemplateBuffer<T>)
 216:	84 e0       	ldi	r24, 0x04	; 4
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	65 df       	rcall	.-310    	; 0xe6 <_Znwj>
 21c:	9b 83       	std	Y+3, r25	; 0x03
 21e:	8a 83       	std	Y+2, r24	; 0x02
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 220:	df b6       	in	r13, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 222:	f8 94       	cli
				m_buffer->data = new T[specSize]; // create the internal array
 224:	0a 81       	ldd	r16, Y+2	; 0x02
 226:	1b 81       	ldd	r17, Y+3	; 0x03
 228:	82 e3       	ldi	r24, 0x32	; 50
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	5e df       	rcall	.-324    	; 0xea <_Znaj>
 22e:	f8 01       	movw	r30, r16
 230:	91 83       	std	Z+1, r25	; 0x01
 232:	80 83       	st	Z, r24
				m_buffer->size = specSize; // set the size of the buffer to the specified
 234:	ea 81       	ldd	r30, Y+2	; 0x02
 236:	fb 81       	ldd	r31, Y+3	; 0x03
 238:	85 e0       	ldi	r24, 0x05	; 5
 23a:	82 83       	std	Z+2, r24	; 0x02
				m_buffer->length = 0;
 23c:	ea 81       	ldd	r30, Y+2	; 0x02
 23e:	fb 81       	ldd	r31, Y+3	; 0x03
 240:	13 82       	std	Z+3, r1	; 0x03
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 242:	df be       	out	0x3f, r13	; 63
	: m_EventSchedule_noblock( EVENT_MAXIMUM )
	, m_EventSchedule_blocking( EVENT_MAXIMUM )
	, m_CoreTimer8(htimer)
 244:	fd 82       	std	Y+5, r15	; 0x05
 246:	ec 82       	std	Y+4, r14	; 0x04
{
//	m_CoreTimer8->setCallback( makeFunctor( (CBFunctor0*)0, *this, &Scheduler::tempInterruptHandler ) );
}
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	1f 91       	pop	r17
 24e:	0f 91       	pop	r16
 250:	ff 90       	pop	r15
 252:	ef 90       	pop	r14
 254:	df 90       	pop	r13
 256:	08 95       	ret

00000258 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent>:

unsigned char Scheduler::ScheduleAnEvent( ScheduledEvent newEvent ){
 258:	cf 92       	push	r12
 25a:	df 92       	push	r13
 25c:	ef 92       	push	r14
 25e:	ff 92       	push	r15
 260:	0f 93       	push	r16
 262:	1f 93       	push	r17
 264:	cf 93       	push	r28
 266:	df 93       	push	r29
 268:	cd b7       	in	r28, 0x3d	; 61
 26a:	de b7       	in	r29, 0x3e	; 62
 26c:	64 97       	sbiw	r28, 0x14	; 20
 26e:	0f b6       	in	r0, 0x3f	; 63
 270:	f8 94       	cli
 272:	de bf       	out	0x3e, r29	; 62
 274:	0f be       	out	0x3f, r0	; 63
 276:	cd bf       	out	0x3d, r28	; 61
 278:	6c 01       	movw	r12, r24
 27a:	eb 86       	std	Y+11, r14	; 0x0b
 27c:	fc 86       	std	Y+12, r15	; 0x0c
 27e:	0d 87       	std	Y+13, r16	; 0x0d
 280:	1e 87       	std	Y+14, r17	; 0x0e
 282:	2f 87       	std	Y+15, r18	; 0x0f
 284:	38 8b       	std	Y+16, r19	; 0x10
 286:	49 8b       	std	Y+17, r20	; 0x11
 288:	5a 8b       	std	Y+18, r21	; 0x12
 28a:	6b 8b       	std	Y+19, r22	; 0x13
 28c:	7c 8b       	std	Y+20, r23	; 0x14
				return bytesleft;
			}
		}
		
		inline unsigned char SpaceUsed(){//returns the size of the used space in the buffer.  Can cast to bool to return false (0) when empty.
			return m_buffer->length;
 28e:	dc 01       	movw	r26, r24
 290:	12 96       	adiw	r26, 0x02	; 2
 292:	2d 91       	ld	r18, X+
 294:	3c 91       	ld	r19, X
 296:	13 97       	sbiw	r26, 0x03	; 3
 298:	f9 01       	movw	r30, r18
 29a:	83 81       	ldd	r24, Z+3	; 0x03
	if ( m_EventSchedule_blocking.SpaceUsed() == 0 ){
 29c:	81 11       	cpse	r24, r1
 29e:	11 c0       	rjmp	.+34     	; 0x2c2 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent+0x6a>
		m_CoreTimer8->start();
 2a0:	14 96       	adiw	r26, 0x04	; 4
 2a2:	8d 91       	ld	r24, X+
 2a4:	9c 91       	ld	r25, X
 2a6:	15 97       	sbiw	r26, 0x05	; 5
 2a8:	dc 01       	movw	r26, r24
 2aa:	ed 91       	ld	r30, X+
 2ac:	fc 91       	ld	r31, X
 2ae:	02 80       	ldd	r0, Z+2	; 0x02
 2b0:	f3 81       	ldd	r31, Z+3	; 0x03
 2b2:	e0 2d       	mov	r30, r0
 2b4:	09 95       	icall
 2b6:	f6 01       	movw	r30, r12
 2b8:	22 81       	ldd	r18, Z+2	; 0x02
 2ba:	33 81       	ldd	r19, Z+3	; 0x03
 2bc:	d9 01       	movw	r26, r18
 2be:	13 96       	adiw	r26, 0x03	; 3
 2c0:	8c 91       	ld	r24, X
	}
	newEvent.EventNumber = (m_EventSchedule_blocking.SpaceUsed() + 1);
 2c2:	41 e0       	ldi	r20, 0x01	; 1
 2c4:	48 0f       	add	r20, r24
 2c6:	4b 87       	std	Y+11, r20	; 0x0b
 2c8:	9a e0       	ldi	r25, 0x0A	; 10
 2ca:	fe 01       	movw	r30, r28
 2cc:	3b 96       	adiw	r30, 0x0b	; 11
 2ce:	de 01       	movw	r26, r28
 2d0:	11 96       	adiw	r26, 0x01	; 1
 2d2:	01 90       	ld	r0, Z+
 2d4:	0d 92       	st	X+, r0
 2d6:	9a 95       	dec	r25
 2d8:	e1 f7       	brne	.-8      	; 0x2d2 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent+0x7a>
			}
		}; // create a buffer of "size" length

/////////Write Methods/////////
		bool AddToEnd( T newData ){
			if(m_buffer->length < m_buffer->size){ // make sure the buffer has room
 2da:	f9 01       	movw	r30, r18
 2dc:	92 81       	ldd	r25, Z+2	; 0x02
 2de:	89 17       	cp	r24, r25
 2e0:	78 f0       	brcs	.+30     	; 0x300 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent+0xa8>
	m_EventSchedule_blocking.AddToEnd(newEvent);
	return m_EventSchedule_blocking.SpaceUsed();
}
 2e2:	64 96       	adiw	r28, 0x14	; 20
 2e4:	0f b6       	in	r0, 0x3f	; 63
 2e6:	f8 94       	cli
 2e8:	de bf       	out	0x3e, r29	; 62
 2ea:	0f be       	out	0x3f, r0	; 63
 2ec:	cd bf       	out	0x3d, r28	; 61
 2ee:	df 91       	pop	r29
 2f0:	cf 91       	pop	r28
 2f2:	1f 91       	pop	r17
 2f4:	0f 91       	pop	r16
 2f6:	ff 90       	pop	r15
 2f8:	ef 90       	pop	r14
 2fa:	df 90       	pop	r13
 2fc:	cf 90       	pop	r12
 2fe:	08 95       	ret
				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 300:	5f b7       	in	r21, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 302:	f8 94       	cli
					m_buffer->data[m_buffer->length % m_buffer->size] = newData; //Add the data to the address at which length points.
 304:	d6 01       	movw	r26, r12
 306:	12 96       	adiw	r26, 0x02	; 2
 308:	ed 91       	ld	r30, X+
 30a:	fc 91       	ld	r31, X
 30c:	13 97       	sbiw	r26, 0x03	; 3
 30e:	83 81       	ldd	r24, Z+3	; 0x03
 310:	62 81       	ldd	r22, Z+2	; 0x02
 312:	a3 d1       	rcall	.+838    	; 0x65a <__udivmodqi4>
 314:	29 2f       	mov	r18, r25
 316:	30 e0       	ldi	r19, 0x00	; 0
 318:	c9 01       	movw	r24, r18
 31a:	88 0f       	add	r24, r24
 31c:	99 1f       	adc	r25, r25
 31e:	88 0f       	add	r24, r24
 320:	99 1f       	adc	r25, r25
 322:	82 0f       	add	r24, r18
 324:	93 1f       	adc	r25, r19
 326:	88 0f       	add	r24, r24
 328:	99 1f       	adc	r25, r25
 32a:	a0 81       	ld	r26, Z
 32c:	b1 81       	ldd	r27, Z+1	; 0x01
 32e:	a8 0f       	add	r26, r24
 330:	b9 1f       	adc	r27, r25
 332:	49 83       	std	Y+1, r20	; 0x01
 334:	8a e0       	ldi	r24, 0x0A	; 10
 336:	fe 01       	movw	r30, r28
 338:	31 96       	adiw	r30, 0x01	; 1
 33a:	01 90       	ld	r0, Z+
 33c:	0d 92       	st	X+, r0
 33e:	8a 95       	dec	r24
 340:	e1 f7       	brne	.-8      	; 0x33a <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent+0xe2>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 342:	5f bf       	out	0x3f, r21	; 63
				}
				m_buffer->length++; // Update the length by one
 344:	d6 01       	movw	r26, r12
 346:	12 96       	adiw	r26, 0x02	; 2
 348:	ed 91       	ld	r30, X+
 34a:	fc 91       	ld	r31, X
 34c:	13 97       	sbiw	r26, 0x03	; 3
 34e:	83 81       	ldd	r24, Z+3	; 0x03
 350:	8f 5f       	subi	r24, 0xFF	; 255
 352:	83 83       	std	Z+3, r24	; 0x03
 354:	12 96       	adiw	r26, 0x02	; 2
 356:	ed 91       	ld	r30, X+
 358:	fc 91       	ld	r31, X
 35a:	13 97       	sbiw	r26, 0x03	; 3
 35c:	83 81       	ldd	r24, Z+3	; 0x03
 35e:	c1 cf       	rjmp	.-126    	; 0x2e2 <_ZN9Scheduler15ScheduleAnEventE14ScheduledEvent+0x8a>

00000360 <_ZN9Scheduler11ProcessTimeE4time>:

void Scheduler::ProcessTime( time newTime ){
 360:	bf 92       	push	r11
 362:	cf 92       	push	r12
 364:	df 92       	push	r13
 366:	ef 92       	push	r14
 368:	ff 92       	push	r15
 36a:	0f 93       	push	r16
 36c:	1f 93       	push	r17
 36e:	cf 93       	push	r28
 370:	df 93       	push	r29
 372:	8c 01       	movw	r16, r24
				return bytesleft;
			}
		}
		
		inline unsigned char SpaceUsed(){//returns the size of the used space in the buffer.  Can cast to bool to return false (0) when empty.
			return m_buffer->length;
 374:	dc 01       	movw	r26, r24
 376:	12 96       	adiw	r26, 0x02	; 2
 378:	ed 91       	ld	r30, X+
 37a:	fc 91       	ld	r31, X
 37c:	13 97       	sbiw	r26, 0x03	; 3
	ScheduledEvent* testEvent;
	for(signed char i = m_EventSchedule_blocking.SpaceUsed(); i >= 0; i--){
 37e:	b3 80       	ldd	r11, Z+3	; 0x03
 380:	b7 fc       	sbrc	r11, 7
 382:	5d c0       	rjmp	.+186    	; 0x43e <_ZN9Scheduler11ProcessTimeE4time+0xde>
 384:	08 c0       	rjmp	.+16     	; 0x396 <_ZN9Scheduler11ProcessTimeE4time+0x36>
 386:	ba 94       	dec	r11
 388:	b7 fc       	sbrc	r11, 7
 38a:	59 c0       	rjmp	.+178    	; 0x43e <_ZN9Scheduler11ProcessTimeE4time+0xde>
 38c:	d8 01       	movw	r26, r16
 38e:	12 96       	adiw	r26, 0x02	; 2
 390:	ed 91       	ld	r30, X+
 392:	fc 91       	ld	r31, X
 394:	13 97       	sbiw	r26, 0x03	; 3
			}
		};
		
		// get the address of the object stored at the location of the index
		T* ReadAddressOfIndex( unsigned char index ){
			return &m_buffer->data[index % (m_buffer->size)];
 396:	62 81       	ldd	r22, Z+2	; 0x02
 398:	8b 2d       	mov	r24, r11
 39a:	5f d1       	rcall	.+702    	; 0x65a <__udivmodqi4>
 39c:	49 2f       	mov	r20, r25
 39e:	50 e0       	ldi	r21, 0x00	; 0
 3a0:	9a 01       	movw	r18, r20
 3a2:	22 0f       	add	r18, r18
 3a4:	33 1f       	adc	r19, r19
 3a6:	22 0f       	add	r18, r18
 3a8:	33 1f       	adc	r19, r19
 3aa:	24 0f       	add	r18, r20
 3ac:	35 1f       	adc	r19, r21
 3ae:	22 0f       	add	r18, r18
 3b0:	33 1f       	adc	r19, r19
 3b2:	c0 81       	ld	r28, Z
 3b4:	d1 81       	ldd	r29, Z+1	; 0x01
 3b6:	c2 0f       	add	r28, r18
 3b8:	d3 1f       	adc	r29, r19
		testEvent = m_EventSchedule_blocking.ReadAddressOfIndex(i);
			if ( testEvent->OverageDistance != 0 ){ // ignore non-events.
 3ba:	2c 81       	ldd	r18, Y+4	; 0x04
 3bc:	3d 81       	ldd	r19, Y+5	; 0x05
 3be:	23 2b       	or	r18, r19
 3c0:	11 f3       	breq	.-60     	; 0x386 <_ZN9Scheduler11ProcessTimeE4time+0x26>
				if ( testEvent->CurrentDistance - m_CoreTimer8->getPrescale() * 256 <= 0 )
 3c2:	ce 80       	ldd	r12, Y+6	; 0x06
 3c4:	df 80       	ldd	r13, Y+7	; 0x07
 3c6:	f8 01       	movw	r30, r16
 3c8:	84 81       	ldd	r24, Z+4	; 0x04
 3ca:	95 81       	ldd	r25, Z+5	; 0x05
 3cc:	dc 01       	movw	r26, r24
 3ce:	ed 91       	ld	r30, X+
 3d0:	fc 91       	ld	r31, X
 3d2:	00 84       	ldd	r0, Z+8	; 0x08
 3d4:	f1 85       	ldd	r31, Z+9	; 0x09
 3d6:	e0 2d       	mov	r30, r0
 3d8:	09 95       	icall
 3da:	ac 01       	movw	r20, r24
 3dc:	56 95       	lsr	r21
 3de:	54 2f       	mov	r21, r20
 3e0:	44 27       	eor	r20, r20
 3e2:	57 95       	ror	r21
 3e4:	47 95       	ror	r20
 3e6:	48 0f       	add	r20, r24
 3e8:	59 1f       	adc	r21, r25
 3ea:	44 0f       	add	r20, r20
 3ec:	55 1f       	adc	r21, r21
 3ee:	48 1b       	sub	r20, r24
 3f0:	59 0b       	sbc	r21, r25
 3f2:	9a 01       	movw	r18, r20
 3f4:	36 95       	lsr	r19
 3f6:	32 2f       	mov	r19, r18
 3f8:	22 27       	eor	r18, r18
 3fa:	37 95       	ror	r19
 3fc:	27 95       	ror	r18
 3fe:	24 1b       	sub	r18, r20
 400:	35 0b       	sbc	r19, r21
 402:	28 0f       	add	r18, r24
 404:	39 1f       	adc	r19, r25
 406:	22 0f       	add	r18, r18
 408:	33 1f       	adc	r19, r19
 40a:	2c 0d       	add	r18, r12
 40c:	3d 1d       	adc	r19, r13
 40e:	12 16       	cp	r1, r18
 410:	13 06       	cpc	r1, r19
 412:	fc f4       	brge	.+62     	; 0x452 <_ZN9Scheduler11ProcessTimeE4time+0xf2>
				{
					testEvent->CurrentDistance = testEvent->OverageDistance;
					testEvent->EventFunction();	
				} else {
					testEvent->CurrentDistance -= ( m_CoreTimer8->getPrescale() *256 );
 414:	f8 01       	movw	r30, r16
 416:	84 81       	ldd	r24, Z+4	; 0x04
 418:	95 81       	ldd	r25, Z+5	; 0x05
 41a:	dc 01       	movw	r26, r24
 41c:	ed 91       	ld	r30, X+
 41e:	fc 91       	ld	r31, X
 420:	00 84       	ldd	r0, Z+8	; 0x08
 422:	f1 85       	ldd	r31, Z+9	; 0x09
 424:	e0 2d       	mov	r30, r0
 426:	09 95       	icall
 428:	f8 2e       	mov	r15, r24
 42a:	e1 2c       	mov	r14, r1
 42c:	8e 81       	ldd	r24, Y+6	; 0x06
 42e:	9f 81       	ldd	r25, Y+7	; 0x07
 430:	8e 19       	sub	r24, r14
 432:	9f 09       	sbc	r25, r15
 434:	9f 83       	std	Y+7, r25	; 0x07
 436:	8e 83       	std	Y+6, r24	; 0x06
 438:	ba 94       	dec	r11
	return m_EventSchedule_blocking.SpaceUsed();
}

void Scheduler::ProcessTime( time newTime ){
	ScheduledEvent* testEvent;
	for(signed char i = m_EventSchedule_blocking.SpaceUsed(); i >= 0; i--){
 43a:	b7 fe       	sbrs	r11, 7
 43c:	a7 cf       	rjmp	.-178    	; 0x38c <_ZN9Scheduler11ProcessTimeE4time+0x2c>
				} else {
					testEvent->CurrentDistance -= ( m_CoreTimer8->getPrescale() *256 );
				}
			}
	}
}
 43e:	df 91       	pop	r29
 440:	cf 91       	pop	r28
 442:	1f 91       	pop	r17
 444:	0f 91       	pop	r16
 446:	ff 90       	pop	r15
 448:	ef 90       	pop	r14
 44a:	df 90       	pop	r13
 44c:	cf 90       	pop	r12
 44e:	bf 90       	pop	r11
 450:	08 95       	ret
	for(signed char i = m_EventSchedule_blocking.SpaceUsed(); i >= 0; i--){
		testEvent = m_EventSchedule_blocking.ReadAddressOfIndex(i);
			if ( testEvent->OverageDistance != 0 ){ // ignore non-events.
				if ( testEvent->CurrentDistance - m_CoreTimer8->getPrescale() * 256 <= 0 )
				{
					testEvent->CurrentDistance = testEvent->OverageDistance;
 452:	8c 81       	ldd	r24, Y+4	; 0x04
 454:	9d 81       	ldd	r25, Y+5	; 0x05
 456:	9f 83       	std	Y+7, r25	; 0x07
 458:	8e 83       	std	Y+6, r24	; 0x06
					testEvent->EventFunction();	
 45a:	e8 85       	ldd	r30, Y+8	; 0x08
 45c:	f9 85       	ldd	r31, Y+9	; 0x09
 45e:	09 95       	icall
 460:	92 cf       	rjmp	.-220    	; 0x386 <_ZN9Scheduler11ProcessTimeE4time+0x26>

00000462 <_ZN9SchedulerD1Ev>:
	m_CoreTimer8->start();//restart the core timer after sort is complete.
}//end updateTimerOrder
*/

// default destructor
Scheduler::~Scheduler()
 462:	cf 93       	push	r28
 464:	df 93       	push	r29
 466:	ec 01       	movw	r28, r24
		void Flush(){ //! flush (clear) the contents of the buffer WIP
			m_buffer->length = 0;
		};
		
		~Buffer(){ //destructor
			delete[] m_buffer->data;
 468:	ea 81       	ldd	r30, Y+2	; 0x02
 46a:	fb 81       	ldd	r31, Y+3	; 0x03
 46c:	80 81       	ld	r24, Z
 46e:	91 81       	ldd	r25, Z+1	; 0x01
 470:	00 97       	sbiw	r24, 0x00	; 0
 472:	19 f0       	breq	.+6      	; 0x47a <_ZN9SchedulerD1Ev+0x18>
 474:	3b de       	rcall	.-906    	; 0xec <_ZdaPv>
 476:	ea 81       	ldd	r30, Y+2	; 0x02
 478:	fb 81       	ldd	r31, Y+3	; 0x03
			delete m_buffer;
 47a:	cf 01       	movw	r24, r30
 47c:	35 de       	rcall	.-918    	; 0xe8 <_ZdlPv>
		void Flush(){ //! flush (clear) the contents of the buffer WIP
			m_buffer->length = 0;
		};
		
		~Buffer(){ //destructor
			delete[] m_buffer->data;
 47e:	e8 81       	ld	r30, Y
 480:	f9 81       	ldd	r31, Y+1	; 0x01
 482:	80 81       	ld	r24, Z
 484:	91 81       	ldd	r25, Z+1	; 0x01
 486:	00 97       	sbiw	r24, 0x00	; 0
 488:	19 f0       	breq	.+6      	; 0x490 <_ZN9SchedulerD1Ev+0x2e>
 48a:	30 de       	rcall	.-928    	; 0xec <_ZdaPv>
 48c:	e8 81       	ld	r30, Y
 48e:	f9 81       	ldd	r31, Y+1	; 0x01
			delete m_buffer;
 490:	cf 01       	movw	r24, r30
{
} //~Scheduler
 492:	df 91       	pop	r29
 494:	cf 91       	pop	r28
 496:	28 ce       	rjmp	.-944    	; 0xe8 <_ZdlPv>

00000498 <_ZN18HardwareTimer_8Bit5pauseEv>:
	accessTOIE0	= this; //Set ISR access
	TIMSK = (1<<TOIE0);	// enable TCNT0 overflow interrupt
}

time HardwareTimer_8Bit::pause(){
	TCCR0B =  ( (TCCR0B & ~TIMER_PRESCALE_MASK ) | TIMER_CLK_STOP );
 498:	23 b7       	in	r18, 0x33	; 51
 49a:	28 7f       	andi	r18, 0xF8	; 248
 49c:	23 bf       	out	0x33, r18	; 51
	m_Time.count = TCNT0;
 49e:	22 b7       	in	r18, 0x32	; 50
 4a0:	fc 01       	movw	r30, r24
 4a2:	24 83       	std	Z+4, r18	; 0x04
	return m_Time;
}
 4a4:	84 81       	ldd	r24, Z+4	; 0x04
 4a6:	95 81       	ldd	r25, Z+5	; 0x05
 4a8:	08 95       	ret

000004aa <_ZN18HardwareTimer_8Bit4stopEv>:

void HardwareTimer_8Bit::stop(){
	TCCR0B = ( (TCCR0B & ~TIMER_PRESCALE_MASK ) | TIMER_CLK_STOP );
 4aa:	23 b7       	in	r18, 0x33	; 51
 4ac:	28 7f       	andi	r18, 0xF8	; 248
 4ae:	23 bf       	out	0x33, r18	; 51
	// Clear count and time.
	TCNT0 = 0x00;
 4b0:	12 be       	out	0x32, r1	; 50
	m_Time.count = 0x00;
 4b2:	fc 01       	movw	r30, r24
 4b4:	14 82       	std	Z+4, r1	; 0x04
	m_Time.overs = 0x00;
 4b6:	15 82       	std	Z+5, r1	; 0x05
	// disable interrupt
	TIMSK = (0 << TOIE0 );
 4b8:	19 be       	out	0x39, r1	; 57
 4ba:	08 95       	ret

000004bc <_ZN18HardwareTimer_8Bit11getPrescaleEv>:
	
}
	
prescaleSetting HardwareTimer_8Bit::getPrescale(){
	return m_Prescale;
}
 4bc:	fc 01       	movw	r30, r24
 4be:	82 81       	ldd	r24, Z+2	; 0x02
 4c0:	93 81       	ldd	r25, Z+3	; 0x03
 4c2:	08 95       	ret

000004c4 <_ZN18HardwareTimer_8Bit5startEv>:

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
 4c4:	fc 01       	movw	r30, r24
 4c6:	24 81       	ldd	r18, Z+4	; 0x04
 4c8:	22 bf       	out	0x32, r18	; 50
void HardwareTimer_8Bit::setCallback( CBFunctor0 newCallback ){
	m_Callback = newCallback;
}*/

inline unsigned char HardwareTimer_8Bit::translatePrescale( prescaleSetting toTranslate ){
	switch ( toTranslate ){
 4ca:	82 81       	ldd	r24, Z+2	; 0x02
 4cc:	93 81       	ldd	r25, Z+3	; 0x03
 4ce:	80 34       	cpi	r24, 0x40	; 64
 4d0:	91 05       	cpc	r25, r1
 4d2:	09 f1       	breq	.+66     	; 0x516 <_ZN18HardwareTimer_8Bit5startEv+0x52>
 4d4:	4c f4       	brge	.+18     	; 0x4e8 <_ZN18HardwareTimer_8Bit5startEv+0x24>
 4d6:	81 30       	cpi	r24, 0x01	; 1
 4d8:	91 05       	cpc	r25, r1
 4da:	c9 f0       	breq	.+50     	; 0x50e <_ZN18HardwareTimer_8Bit5startEv+0x4a>
 4dc:	08 97       	sbiw	r24, 0x08	; 8
 4de:	79 f4       	brne	.+30     	; 0x4fe <_ZN18HardwareTimer_8Bit5startEv+0x3a>
		case TIMER_CLK_DIV1 :
			return 1;
			break;
		case TIMER_CLK_DIV8 :
			return 2;
 4e0:	82 e0       	ldi	r24, 0x02	; 2
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 4e2:	83 bf       	out	0x33, r24	; 51
	sei();
 4e4:	78 94       	sei
 4e6:	08 95       	ret
void HardwareTimer_8Bit::setCallback( CBFunctor0 newCallback ){
	m_Callback = newCallback;
}*/

inline unsigned char HardwareTimer_8Bit::translatePrescale( prescaleSetting toTranslate ){
	switch ( toTranslate ){
 4e8:	81 15       	cp	r24, r1
 4ea:	f1 e0       	ldi	r31, 0x01	; 1
 4ec:	9f 07       	cpc	r25, r31
 4ee:	59 f0       	breq	.+22     	; 0x506 <_ZN18HardwareTimer_8Bit5startEv+0x42>
 4f0:	81 15       	cp	r24, r1
 4f2:	94 40       	sbci	r25, 0x04	; 4
 4f4:	21 f4       	brne	.+8      	; 0x4fe <_ZN18HardwareTimer_8Bit5startEv+0x3a>
			break;
		case TIMER_CLK_DIV256 :
			return 4;
			break;	
		case TIMER_CLK_DIV1024 :
			return 5;
 4f6:	85 e0       	ldi	r24, 0x05	; 5
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 4f8:	83 bf       	out	0x33, r24	; 51
	sei();
 4fa:	78 94       	sei
 4fc:	08 95       	ret
			break;	
		case TIMER_CLK_DIV1024 :
			return 5;
			break;
		default:
			return 0;
 4fe:	80 e0       	ldi	r24, 0x00	; 0
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 500:	83 bf       	out	0x33, r24	; 51
	sei();
 502:	78 94       	sei
 504:	08 95       	ret
			break;
		case TIMER_CLK_DIV64 :
			return 3;
			break;
		case TIMER_CLK_DIV256 :
			return 4;
 506:	84 e0       	ldi	r24, 0x04	; 4
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 508:	83 bf       	out	0x33, r24	; 51
	sei();
 50a:	78 94       	sei
 50c:	08 95       	ret
}*/

inline unsigned char HardwareTimer_8Bit::translatePrescale( prescaleSetting toTranslate ){
	switch ( toTranslate ){
		case TIMER_CLK_DIV1 :
			return 1;
 50e:	81 e0       	ldi	r24, 0x01	; 1
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 510:	83 bf       	out	0x33, r24	; 51
	sei();
 512:	78 94       	sei
 514:	08 95       	ret
			break;
		case TIMER_CLK_DIV8 :
			return 2;
			break;
		case TIMER_CLK_DIV64 :
			return 3;
 516:	83 e0       	ldi	r24, 0x03	; 3
	return m_Prescale;
}

void HardwareTimer_8Bit::start(){
	TCNT0 = m_Time.count;	
	TCCR0B = translatePrescale( m_Prescale );
 518:	83 bf       	out	0x33, r24	; 51
	sei();
 51a:	78 94       	sei
 51c:	08 95       	ret

0000051e <_ZN18HardwareTimer_8Bit10updateTimeEv>:
}

//////////// Access Methods /////////////

 inline void HardwareTimer_8Bit::updateTime(){
	m_Time.count = TCNT0;	 
 51e:	22 b7       	in	r18, 0x32	; 50
 520:	fc 01       	movw	r30, r24
 522:	24 83       	std	Z+4, r18	; 0x04
 524:	08 95       	ret

00000526 <_ZN18HardwareTimer_8Bit7getTimeEv>:
 }
 
time HardwareTimer_8Bit::getTime(){
 526:	cf 93       	push	r28
 528:	df 93       	push	r29
 52a:	ec 01       	movw	r28, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 52c:	f8 94       	cli
	ATOMIC_BLOCK(ATOMIC_FORCEON){ // memory wall to force read the time before updating the time
		this->updateTime();
 52e:	e8 81       	ld	r30, Y
 530:	f9 81       	ldd	r31, Y+1	; 0x01
 532:	04 88       	ldd	r0, Z+20	; 0x14
 534:	f5 89       	ldd	r31, Z+21	; 0x15
 536:	e0 2d       	mov	r30, r0
 538:	09 95       	icall
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
 53a:	78 94       	sei
	}
	time tempTime = m_Time;
 53c:	8c 81       	ldd	r24, Y+4	; 0x04
 53e:	9d 81       	ldd	r25, Y+5	; 0x05
	m_Time.overs = 0;
 540:	1d 82       	std	Y+5, r1	; 0x05
	return tempTime;
}
 542:	df 91       	pop	r29
 544:	cf 91       	pop	r28
 546:	08 95       	ret

00000548 <_ZN18HardwareTimer_8Bit17getTime_NoUpdatesEv>:

time HardwareTimer_8Bit::getTime_NoUpdates(){
	return m_Time;
}
 548:	fc 01       	movw	r30, r24
 54a:	84 81       	ldd	r24, Z+4	; 0x04
 54c:	95 81       	ldd	r25, Z+5	; 0x05
 54e:	08 95       	ret

00000550 <_ZN18HardwareTimer_8Bit15getTime_NoClearEv>:

time HardwareTimer_8Bit::getTime_NoClear(){
 550:	cf 93       	push	r28
 552:	df 93       	push	r29
 554:	ec 01       	movw	r28, r24
	this->updateTime();
 556:	e8 81       	ld	r30, Y
 558:	f9 81       	ldd	r31, Y+1	; 0x01
 55a:	04 88       	ldd	r0, Z+20	; 0x14
 55c:	f5 89       	ldd	r31, Z+21	; 0x15
 55e:	e0 2d       	mov	r30, r0
 560:	09 95       	icall
	return m_Time;
}
 562:	8c 81       	ldd	r24, Y+4	; 0x04
 564:	9d 81       	ldd	r25, Y+5	; 0x05
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	08 95       	ret

0000056c <_ZN18HardwareTimer_8BitD1Ev>:
		
		void setOverageFunction( VoidFuncPtr func ){ 
			m_overageFunction = func;
		}
			
		virtual ~CPPTimer(){};
 56c:	28 e8       	ldi	r18, 0x88	; 136
 56e:	30 e0       	ldi	r19, 0x00	; 0
 570:	fc 01       	movw	r30, r24
 572:	31 83       	std	Z+1, r19	; 0x01
 574:	20 83       	st	Z, r18
 576:	08 95       	ret

00000578 <_ZN18HardwareTimer_8BitD0Ev>:
 578:	28 e8       	ldi	r18, 0x88	; 136
 57a:	30 e0       	ldi	r19, 0x00	; 0
 57c:	fc 01       	movw	r30, r24
 57e:	31 83       	std	Z+1, r19	; 0x01
 580:	20 83       	st	Z, r18
		
};*/

extern "C" void  TIMER0_OVF_vect(void) __attribute__ ((signal)); //required for interrupt handling in C++

class HardwareTimer_8Bit : public CPPTimer {
 582:	b2 cd       	rjmp	.-1180   	; 0xe8 <_ZdlPv>

00000584 <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting>:
	// disable interrupt
	TIMSK = (0 << TOIE0 );
}

void HardwareTimer_8Bit::setPrescale( prescaleSetting prescale ){
	m_Prescale = prescale;
 584:	fc 01       	movw	r30, r24
 586:	73 83       	std	Z+3, r23	; 0x03
 588:	62 83       	std	Z+2, r22	; 0x02
	if ( (TCCR0B & ~TIMER_PRESCALE_MASK) != 0 ){//if the timer is already running, update the prescale mask.  otherwise, just store it.
 58a:	83 b7       	in	r24, 0x33	; 51
 58c:	88 7f       	andi	r24, 0xF8	; 248
 58e:	79 f0       	breq	.+30     	; 0x5ae <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x2a>
		TCCR0B = ( (TCCR0B & ~TIMER_PRESCALE_MASK) | translatePrescale(prescale) );
 590:	83 b7       	in	r24, 0x33	; 51
 592:	88 7f       	andi	r24, 0xF8	; 248
void HardwareTimer_8Bit::setCallback( CBFunctor0 newCallback ){
	m_Callback = newCallback;
}*/

inline unsigned char HardwareTimer_8Bit::translatePrescale( prescaleSetting toTranslate ){
	switch ( toTranslate ){
 594:	60 34       	cpi	r22, 0x40	; 64
 596:	71 05       	cpc	r23, r1
 598:	c1 f0       	breq	.+48     	; 0x5ca <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x46>
 59a:	54 f4       	brge	.+20     	; 0x5b0 <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x2c>
 59c:	61 30       	cpi	r22, 0x01	; 1
 59e:	71 05       	cpc	r23, r1
 5a0:	81 f0       	breq	.+32     	; 0x5c2 <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x3e>
 5a2:	68 30       	cpi	r22, 0x08	; 8
 5a4:	71 05       	cpc	r23, r1
 5a6:	99 f4       	brne	.+38     	; 0x5ce <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x4a>
 5a8:	92 e0       	ldi	r25, 0x02	; 2
}

void HardwareTimer_8Bit::setPrescale( prescaleSetting prescale ){
	m_Prescale = prescale;
	if ( (TCCR0B & ~TIMER_PRESCALE_MASK) != 0 ){//if the timer is already running, update the prescale mask.  otherwise, just store it.
		TCCR0B = ( (TCCR0B & ~TIMER_PRESCALE_MASK) | translatePrescale(prescale) );
 5aa:	89 2b       	or	r24, r25
 5ac:	83 bf       	out	0x33, r24	; 51
 5ae:	08 95       	ret
void HardwareTimer_8Bit::setCallback( CBFunctor0 newCallback ){
	m_Callback = newCallback;
}*/

inline unsigned char HardwareTimer_8Bit::translatePrescale( prescaleSetting toTranslate ){
	switch ( toTranslate ){
 5b0:	61 15       	cp	r22, r1
 5b2:	f1 e0       	ldi	r31, 0x01	; 1
 5b4:	7f 07       	cpc	r23, r31
 5b6:	39 f0       	breq	.+14     	; 0x5c6 <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x42>
 5b8:	61 15       	cp	r22, r1
 5ba:	74 40       	sbci	r23, 0x04	; 4
 5bc:	41 f4       	brne	.+16     	; 0x5ce <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x4a>
 5be:	95 e0       	ldi	r25, 0x05	; 5
 5c0:	f4 cf       	rjmp	.-24     	; 0x5aa <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x26>
 5c2:	91 e0       	ldi	r25, 0x01	; 1
 5c4:	f2 cf       	rjmp	.-28     	; 0x5aa <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x26>
 5c6:	94 e0       	ldi	r25, 0x04	; 4
 5c8:	f0 cf       	rjmp	.-32     	; 0x5aa <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x26>
 5ca:	93 e0       	ldi	r25, 0x03	; 3
 5cc:	ee cf       	rjmp	.-36     	; 0x5aa <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x26>
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	ec cf       	rjmp	.-40     	; 0x5aa <_ZN18HardwareTimer_8Bit11setPrescaleE15prescaleSetting+0x26>

000005d2 <_ZN18HardwareTimer_8BitC1E15prescaleSetting>:
{
	TCNT0 = 0x00;
	accessTOIE0	= this; //Set ISR access
	TIMSK = (1<<TOIE0);	// enable TCNT0 overflow interrupt
}*/
HardwareTimer_8Bit::HardwareTimer_8Bit( prescaleSetting prescale ) 
 5d2:	fc 01       	movw	r30, r24
		{
		} //CPPTimer
		
		CPPTimer( prescaleSetting prescale )
			:m_Prescale(prescale)
			,m_overageFunction(0)
 5d4:	73 83       	std	Z+3, r23	; 0x03
 5d6:	62 83       	std	Z+2, r22	; 0x02
 5d8:	11 86       	std	Z+9, r1	; 0x09
 5da:	10 86       	std	Z+8, r1	; 0x08
	:CPPTimer( prescale )
 5dc:	82 ea       	ldi	r24, 0xA2	; 162
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	91 83       	std	Z+1, r25	; 0x01
 5e2:	80 83       	st	Z, r24

class CBFunctorBase{
public:
  typedef void (CBFunctorBase::*_MemFunc)();
  typedef void (*_Func)();
  CBFunctorBase():func(0),callee(0){}
 5e4:	13 86       	std	Z+11, r1	; 0x0b
 5e6:	12 86       	std	Z+10, r1	; 0x0a
 5e8:	17 86       	std	Z+15, r1	; 0x0f
 5ea:	16 86       	std	Z+14, r1	; 0x0e
{
	TCNT0 = 0x00;
 5ec:	12 be       	out	0x32, r1	; 50
	accessTOIE0	= this; //Set ISR access
 5ee:	f0 93 d1 00 	sts	0x00D1, r31
 5f2:	e0 93 d0 00 	sts	0x00D0, r30
	TIMSK = (1<<TOIE0);	// enable TCNT0 overflow interrupt
 5f6:	82 e0       	ldi	r24, 0x02	; 2
 5f8:	89 bf       	out	0x39, r24	; 57
 5fa:	08 95       	ret

000005fc <__vector_6>:
	}
}

/////////////Interrupt///////////////

void TIMER0_OVF_vect(){
 5fc:	1f 92       	push	r1
 5fe:	0f 92       	push	r0
 600:	0f b6       	in	r0, 0x3f	; 63
 602:	0f 92       	push	r0
 604:	11 24       	eor	r1, r1
 606:	2f 93       	push	r18
 608:	3f 93       	push	r19
 60a:	4f 93       	push	r20
 60c:	5f 93       	push	r21
 60e:	6f 93       	push	r22
 610:	7f 93       	push	r23
 612:	8f 93       	push	r24
 614:	9f 93       	push	r25
 616:	af 93       	push	r26
 618:	bf 93       	push	r27
 61a:	ef 93       	push	r30
 61c:	ff 93       	push	r31
	HardwareTimer_8Bit::accessTOIE0->m_Time.overs++;
 61e:	e0 91 d0 00 	lds	r30, 0x00D0
 622:	f0 91 d1 00 	lds	r31, 0x00D1
 626:	85 81       	ldd	r24, Z+5	; 0x05
 628:	8f 5f       	subi	r24, 0xFF	; 255
 62a:	85 83       	std	Z+5, r24	; 0x05
	HardwareTimer_8Bit::accessTOIE0->m_overageFunction();//FireOverflowInterrupt();
 62c:	00 84       	ldd	r0, Z+8	; 0x08
 62e:	f1 85       	ldd	r31, Z+9	; 0x09
 630:	e0 2d       	mov	r30, r0
 632:	09 95       	icall
	TIMSK = (1<< TOIE0);
 634:	82 e0       	ldi	r24, 0x02	; 2
 636:	89 bf       	out	0x39, r24	; 57
}
 638:	ff 91       	pop	r31
 63a:	ef 91       	pop	r30
 63c:	bf 91       	pop	r27
 63e:	af 91       	pop	r26
 640:	9f 91       	pop	r25
 642:	8f 91       	pop	r24
 644:	7f 91       	pop	r23
 646:	6f 91       	pop	r22
 648:	5f 91       	pop	r21
 64a:	4f 91       	pop	r20
 64c:	3f 91       	pop	r19
 64e:	2f 91       	pop	r18
 650:	0f 90       	pop	r0
 652:	0f be       	out	0x3f, r0	; 63
 654:	0f 90       	pop	r0
 656:	1f 90       	pop	r1
 658:	18 95       	reti

0000065a <__udivmodqi4>:
 65a:	99 1b       	sub	r25, r25
 65c:	79 e0       	ldi	r23, 0x09	; 9
 65e:	04 c0       	rjmp	.+8      	; 0x668 <__udivmodqi4_ep>

00000660 <__udivmodqi4_loop>:
 660:	99 1f       	adc	r25, r25
 662:	96 17       	cp	r25, r22
 664:	08 f0       	brcs	.+2      	; 0x668 <__udivmodqi4_ep>
 666:	96 1b       	sub	r25, r22

00000668 <__udivmodqi4_ep>:
 668:	88 1f       	adc	r24, r24
 66a:	7a 95       	dec	r23
 66c:	c9 f7       	brne	.-14     	; 0x660 <__udivmodqi4_loop>
 66e:	80 95       	com	r24
 670:	08 95       	ret

00000672 <__tablejump2__>:
 672:	ee 0f       	add	r30, r30
 674:	ff 1f       	adc	r31, r31

00000676 <__tablejump__>:
 676:	05 90       	lpm	r0, Z+
 678:	f4 91       	lpm	r31, Z
 67a:	e0 2d       	mov	r30, r0
 67c:	09 94       	ijmp

0000067e <malloc>:
 67e:	cf 93       	push	r28
 680:	df 93       	push	r29
 682:	82 30       	cpi	r24, 0x02	; 2
 684:	91 05       	cpc	r25, r1
 686:	10 f4       	brcc	.+4      	; 0x68c <malloc+0xe>
 688:	82 e0       	ldi	r24, 0x02	; 2
 68a:	90 e0       	ldi	r25, 0x00	; 0
 68c:	e0 91 d4 00 	lds	r30, 0x00D4
 690:	f0 91 d5 00 	lds	r31, 0x00D5
 694:	20 e0       	ldi	r18, 0x00	; 0
 696:	30 e0       	ldi	r19, 0x00	; 0
 698:	a0 e0       	ldi	r26, 0x00	; 0
 69a:	b0 e0       	ldi	r27, 0x00	; 0
 69c:	30 97       	sbiw	r30, 0x00	; 0
 69e:	39 f1       	breq	.+78     	; 0x6ee <malloc+0x70>
 6a0:	40 81       	ld	r20, Z
 6a2:	51 81       	ldd	r21, Z+1	; 0x01
 6a4:	48 17       	cp	r20, r24
 6a6:	59 07       	cpc	r21, r25
 6a8:	b8 f0       	brcs	.+46     	; 0x6d8 <malloc+0x5a>
 6aa:	48 17       	cp	r20, r24
 6ac:	59 07       	cpc	r21, r25
 6ae:	71 f4       	brne	.+28     	; 0x6cc <malloc+0x4e>
 6b0:	82 81       	ldd	r24, Z+2	; 0x02
 6b2:	93 81       	ldd	r25, Z+3	; 0x03
 6b4:	10 97       	sbiw	r26, 0x00	; 0
 6b6:	29 f0       	breq	.+10     	; 0x6c2 <malloc+0x44>
 6b8:	13 96       	adiw	r26, 0x03	; 3
 6ba:	9c 93       	st	X, r25
 6bc:	8e 93       	st	-X, r24
 6be:	12 97       	sbiw	r26, 0x02	; 2
 6c0:	2c c0       	rjmp	.+88     	; 0x71a <malloc+0x9c>
 6c2:	90 93 d5 00 	sts	0x00D5, r25
 6c6:	80 93 d4 00 	sts	0x00D4, r24
 6ca:	27 c0       	rjmp	.+78     	; 0x71a <malloc+0x9c>
 6cc:	21 15       	cp	r18, r1
 6ce:	31 05       	cpc	r19, r1
 6d0:	31 f0       	breq	.+12     	; 0x6de <malloc+0x60>
 6d2:	42 17       	cp	r20, r18
 6d4:	53 07       	cpc	r21, r19
 6d6:	18 f0       	brcs	.+6      	; 0x6de <malloc+0x60>
 6d8:	a9 01       	movw	r20, r18
 6da:	db 01       	movw	r26, r22
 6dc:	01 c0       	rjmp	.+2      	; 0x6e0 <malloc+0x62>
 6de:	ef 01       	movw	r28, r30
 6e0:	9a 01       	movw	r18, r20
 6e2:	bd 01       	movw	r22, r26
 6e4:	df 01       	movw	r26, r30
 6e6:	02 80       	ldd	r0, Z+2	; 0x02
 6e8:	f3 81       	ldd	r31, Z+3	; 0x03
 6ea:	e0 2d       	mov	r30, r0
 6ec:	d7 cf       	rjmp	.-82     	; 0x69c <malloc+0x1e>
 6ee:	21 15       	cp	r18, r1
 6f0:	31 05       	cpc	r19, r1
 6f2:	f9 f0       	breq	.+62     	; 0x732 <malloc+0xb4>
 6f4:	28 1b       	sub	r18, r24
 6f6:	39 0b       	sbc	r19, r25
 6f8:	24 30       	cpi	r18, 0x04	; 4
 6fa:	31 05       	cpc	r19, r1
 6fc:	80 f4       	brcc	.+32     	; 0x71e <malloc+0xa0>
 6fe:	8a 81       	ldd	r24, Y+2	; 0x02
 700:	9b 81       	ldd	r25, Y+3	; 0x03
 702:	61 15       	cp	r22, r1
 704:	71 05       	cpc	r23, r1
 706:	21 f0       	breq	.+8      	; 0x710 <malloc+0x92>
 708:	fb 01       	movw	r30, r22
 70a:	93 83       	std	Z+3, r25	; 0x03
 70c:	82 83       	std	Z+2, r24	; 0x02
 70e:	04 c0       	rjmp	.+8      	; 0x718 <malloc+0x9a>
 710:	90 93 d5 00 	sts	0x00D5, r25
 714:	80 93 d4 00 	sts	0x00D4, r24
 718:	fe 01       	movw	r30, r28
 71a:	32 96       	adiw	r30, 0x02	; 2
 71c:	44 c0       	rjmp	.+136    	; 0x7a6 <malloc+0x128>
 71e:	fe 01       	movw	r30, r28
 720:	e2 0f       	add	r30, r18
 722:	f3 1f       	adc	r31, r19
 724:	81 93       	st	Z+, r24
 726:	91 93       	st	Z+, r25
 728:	22 50       	subi	r18, 0x02	; 2
 72a:	31 09       	sbc	r19, r1
 72c:	39 83       	std	Y+1, r19	; 0x01
 72e:	28 83       	st	Y, r18
 730:	3a c0       	rjmp	.+116    	; 0x7a6 <malloc+0x128>
 732:	20 91 d2 00 	lds	r18, 0x00D2
 736:	30 91 d3 00 	lds	r19, 0x00D3
 73a:	23 2b       	or	r18, r19
 73c:	41 f4       	brne	.+16     	; 0x74e <malloc+0xd0>
 73e:	20 91 62 00 	lds	r18, 0x0062
 742:	30 91 63 00 	lds	r19, 0x0063
 746:	30 93 d3 00 	sts	0x00D3, r19
 74a:	20 93 d2 00 	sts	0x00D2, r18
 74e:	20 91 60 00 	lds	r18, 0x0060
 752:	30 91 61 00 	lds	r19, 0x0061
 756:	21 15       	cp	r18, r1
 758:	31 05       	cpc	r19, r1
 75a:	41 f4       	brne	.+16     	; 0x76c <malloc+0xee>
 75c:	2d b7       	in	r18, 0x3d	; 61
 75e:	3e b7       	in	r19, 0x3e	; 62
 760:	40 91 64 00 	lds	r20, 0x0064
 764:	50 91 65 00 	lds	r21, 0x0065
 768:	24 1b       	sub	r18, r20
 76a:	35 0b       	sbc	r19, r21
 76c:	e0 91 d2 00 	lds	r30, 0x00D2
 770:	f0 91 d3 00 	lds	r31, 0x00D3
 774:	e2 17       	cp	r30, r18
 776:	f3 07       	cpc	r31, r19
 778:	a0 f4       	brcc	.+40     	; 0x7a2 <malloc+0x124>
 77a:	2e 1b       	sub	r18, r30
 77c:	3f 0b       	sbc	r19, r31
 77e:	28 17       	cp	r18, r24
 780:	39 07       	cpc	r19, r25
 782:	78 f0       	brcs	.+30     	; 0x7a2 <malloc+0x124>
 784:	ac 01       	movw	r20, r24
 786:	4e 5f       	subi	r20, 0xFE	; 254
 788:	5f 4f       	sbci	r21, 0xFF	; 255
 78a:	24 17       	cp	r18, r20
 78c:	35 07       	cpc	r19, r21
 78e:	48 f0       	brcs	.+18     	; 0x7a2 <malloc+0x124>
 790:	4e 0f       	add	r20, r30
 792:	5f 1f       	adc	r21, r31
 794:	50 93 d3 00 	sts	0x00D3, r21
 798:	40 93 d2 00 	sts	0x00D2, r20
 79c:	81 93       	st	Z+, r24
 79e:	91 93       	st	Z+, r25
 7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <malloc+0x128>
 7a2:	e0 e0       	ldi	r30, 0x00	; 0
 7a4:	f0 e0       	ldi	r31, 0x00	; 0
 7a6:	cf 01       	movw	r24, r30
 7a8:	df 91       	pop	r29
 7aa:	cf 91       	pop	r28
 7ac:	08 95       	ret

000007ae <free>:
 7ae:	cf 93       	push	r28
 7b0:	df 93       	push	r29
 7b2:	00 97       	sbiw	r24, 0x00	; 0
 7b4:	09 f4       	brne	.+2      	; 0x7b8 <free+0xa>
 7b6:	87 c0       	rjmp	.+270    	; 0x8c6 <free+0x118>
 7b8:	fc 01       	movw	r30, r24
 7ba:	32 97       	sbiw	r30, 0x02	; 2
 7bc:	13 82       	std	Z+3, r1	; 0x03
 7be:	12 82       	std	Z+2, r1	; 0x02
 7c0:	c0 91 d4 00 	lds	r28, 0x00D4
 7c4:	d0 91 d5 00 	lds	r29, 0x00D5
 7c8:	20 97       	sbiw	r28, 0x00	; 0
 7ca:	81 f4       	brne	.+32     	; 0x7ec <free+0x3e>
 7cc:	20 81       	ld	r18, Z
 7ce:	31 81       	ldd	r19, Z+1	; 0x01
 7d0:	28 0f       	add	r18, r24
 7d2:	39 1f       	adc	r19, r25
 7d4:	80 91 d2 00 	lds	r24, 0x00D2
 7d8:	90 91 d3 00 	lds	r25, 0x00D3
 7dc:	82 17       	cp	r24, r18
 7de:	93 07       	cpc	r25, r19
 7e0:	79 f5       	brne	.+94     	; 0x840 <free+0x92>
 7e2:	f0 93 d3 00 	sts	0x00D3, r31
 7e6:	e0 93 d2 00 	sts	0x00D2, r30
 7ea:	6d c0       	rjmp	.+218    	; 0x8c6 <free+0x118>
 7ec:	de 01       	movw	r26, r28
 7ee:	20 e0       	ldi	r18, 0x00	; 0
 7f0:	30 e0       	ldi	r19, 0x00	; 0
 7f2:	ae 17       	cp	r26, r30
 7f4:	bf 07       	cpc	r27, r31
 7f6:	50 f4       	brcc	.+20     	; 0x80c <free+0x5e>
 7f8:	12 96       	adiw	r26, 0x02	; 2
 7fa:	4d 91       	ld	r20, X+
 7fc:	5c 91       	ld	r21, X
 7fe:	13 97       	sbiw	r26, 0x03	; 3
 800:	9d 01       	movw	r18, r26
 802:	41 15       	cp	r20, r1
 804:	51 05       	cpc	r21, r1
 806:	09 f1       	breq	.+66     	; 0x84a <free+0x9c>
 808:	da 01       	movw	r26, r20
 80a:	f3 cf       	rjmp	.-26     	; 0x7f2 <free+0x44>
 80c:	b3 83       	std	Z+3, r27	; 0x03
 80e:	a2 83       	std	Z+2, r26	; 0x02
 810:	40 81       	ld	r20, Z
 812:	51 81       	ldd	r21, Z+1	; 0x01
 814:	84 0f       	add	r24, r20
 816:	95 1f       	adc	r25, r21
 818:	8a 17       	cp	r24, r26
 81a:	9b 07       	cpc	r25, r27
 81c:	71 f4       	brne	.+28     	; 0x83a <free+0x8c>
 81e:	8d 91       	ld	r24, X+
 820:	9c 91       	ld	r25, X
 822:	11 97       	sbiw	r26, 0x01	; 1
 824:	84 0f       	add	r24, r20
 826:	95 1f       	adc	r25, r21
 828:	02 96       	adiw	r24, 0x02	; 2
 82a:	91 83       	std	Z+1, r25	; 0x01
 82c:	80 83       	st	Z, r24
 82e:	12 96       	adiw	r26, 0x02	; 2
 830:	8d 91       	ld	r24, X+
 832:	9c 91       	ld	r25, X
 834:	13 97       	sbiw	r26, 0x03	; 3
 836:	93 83       	std	Z+3, r25	; 0x03
 838:	82 83       	std	Z+2, r24	; 0x02
 83a:	21 15       	cp	r18, r1
 83c:	31 05       	cpc	r19, r1
 83e:	29 f4       	brne	.+10     	; 0x84a <free+0x9c>
 840:	f0 93 d5 00 	sts	0x00D5, r31
 844:	e0 93 d4 00 	sts	0x00D4, r30
 848:	3e c0       	rjmp	.+124    	; 0x8c6 <free+0x118>
 84a:	d9 01       	movw	r26, r18
 84c:	13 96       	adiw	r26, 0x03	; 3
 84e:	fc 93       	st	X, r31
 850:	ee 93       	st	-X, r30
 852:	12 97       	sbiw	r26, 0x02	; 2
 854:	4d 91       	ld	r20, X+
 856:	5d 91       	ld	r21, X+
 858:	a4 0f       	add	r26, r20
 85a:	b5 1f       	adc	r27, r21
 85c:	ea 17       	cp	r30, r26
 85e:	fb 07       	cpc	r31, r27
 860:	79 f4       	brne	.+30     	; 0x880 <free+0xd2>
 862:	80 81       	ld	r24, Z
 864:	91 81       	ldd	r25, Z+1	; 0x01
 866:	84 0f       	add	r24, r20
 868:	95 1f       	adc	r25, r21
 86a:	02 96       	adiw	r24, 0x02	; 2
 86c:	d9 01       	movw	r26, r18
 86e:	11 96       	adiw	r26, 0x01	; 1
 870:	9c 93       	st	X, r25
 872:	8e 93       	st	-X, r24
 874:	82 81       	ldd	r24, Z+2	; 0x02
 876:	93 81       	ldd	r25, Z+3	; 0x03
 878:	13 96       	adiw	r26, 0x03	; 3
 87a:	9c 93       	st	X, r25
 87c:	8e 93       	st	-X, r24
 87e:	12 97       	sbiw	r26, 0x02	; 2
 880:	e0 e0       	ldi	r30, 0x00	; 0
 882:	f0 e0       	ldi	r31, 0x00	; 0
 884:	8a 81       	ldd	r24, Y+2	; 0x02
 886:	9b 81       	ldd	r25, Y+3	; 0x03
 888:	00 97       	sbiw	r24, 0x00	; 0
 88a:	19 f0       	breq	.+6      	; 0x892 <free+0xe4>
 88c:	fe 01       	movw	r30, r28
 88e:	ec 01       	movw	r28, r24
 890:	f9 cf       	rjmp	.-14     	; 0x884 <free+0xd6>
 892:	ce 01       	movw	r24, r28
 894:	02 96       	adiw	r24, 0x02	; 2
 896:	28 81       	ld	r18, Y
 898:	39 81       	ldd	r19, Y+1	; 0x01
 89a:	82 0f       	add	r24, r18
 89c:	93 1f       	adc	r25, r19
 89e:	20 91 d2 00 	lds	r18, 0x00D2
 8a2:	30 91 d3 00 	lds	r19, 0x00D3
 8a6:	28 17       	cp	r18, r24
 8a8:	39 07       	cpc	r19, r25
 8aa:	69 f4       	brne	.+26     	; 0x8c6 <free+0x118>
 8ac:	30 97       	sbiw	r30, 0x00	; 0
 8ae:	29 f4       	brne	.+10     	; 0x8ba <free+0x10c>
 8b0:	10 92 d5 00 	sts	0x00D5, r1
 8b4:	10 92 d4 00 	sts	0x00D4, r1
 8b8:	02 c0       	rjmp	.+4      	; 0x8be <free+0x110>
 8ba:	13 82       	std	Z+3, r1	; 0x03
 8bc:	12 82       	std	Z+2, r1	; 0x02
 8be:	d0 93 d3 00 	sts	0x00D3, r29
 8c2:	c0 93 d2 00 	sts	0x00D2, r28
 8c6:	df 91       	pop	r29
 8c8:	cf 91       	pop	r28
 8ca:	08 95       	ret

000008cc <__do_global_dtors>:
 8cc:	10 e0       	ldi	r17, 0x00	; 0
 8ce:	cc e2       	ldi	r28, 0x2C	; 44
 8d0:	d0 e0       	ldi	r29, 0x00	; 0
 8d2:	03 c0       	rjmp	.+6      	; 0x8da <__do_global_dtors+0xe>
 8d4:	fe 01       	movw	r30, r28
 8d6:	cf de       	rcall	.-610    	; 0x676 <__tablejump__>
 8d8:	22 96       	adiw	r28, 0x02	; 2
 8da:	ce 32       	cpi	r28, 0x2E	; 46
 8dc:	d1 07       	cpc	r29, r17
 8de:	d1 f7       	brne	.-12     	; 0x8d4 <__do_global_dtors+0x8>
 8e0:	f8 94       	cli

000008e2 <__stop_program>:
 8e2:	ff cf       	rjmp	.-2      	; 0x8e2 <__stop_program>
